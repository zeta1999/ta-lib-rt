/* TA-LIB Copyright (c) 1999-2008, Mario Fortier
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 * - Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in
 *   the documentation and/or other materials provided with the
 *   distribution.
 *
 * - Neither name of author nor the names of its contributors
 *   may be used to endorse or promote products derived from this
 *   software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* List of contributors:
 *
 *  Initial  Name/description
 *  -------------------------------------------------------------------
 *  MF       Mario Fortier
 *  BT       Barry Tsung
 *
 * Change history:
 *
 *  MMDDYY BY     Description
 *  -------------------------------------------------------------------
 *  121005 MF     First Version
 *  022206 BT     1. initialization of candleSettings
 *                2. add SetCompatibility and GetCompatibility
 *                3. add SetUnstablePeriod, GetUnstablePeriod
 */

package com.tictactec.ta.lib;

public class Core {
   
   private int[] unstablePeriod;
   
   private CandleSetting[] candleSettings;
   
   private Compatibility compatibility;
   
   /** Creates a new instance of Core */
   public Core() {
      unstablePeriod = new int[com.tictactec.ta.lib.FuncUnstId.All
         .ordinal()];
      compatibility = Compatibility.Default;
      candleSettings = new CandleSetting[com.tictactec.ta.lib.CandleSettingType.AllCandleSettings
         .ordinal()];
      for(int i=0;i<candleSettings.length;i++){
         candleSettings[i] = new CandleSetting(TA_CandleDefaultSettings[i]);
      }
   }
   
   public RetCode SetCandleSettings(CandleSettingType settingType,
      RangeType rangeType, int avgPeriod, double factor) {
      if (settingType.ordinal() >= CandleSettingType.AllCandleSettings
         .ordinal())
         return RetCode.BadParam;
      candleSettings[settingType.ordinal()].settingType = settingType;
      candleSettings[settingType.ordinal()].rangeType = rangeType;
      candleSettings[settingType.ordinal()].avgPeriod = avgPeriod;
      candleSettings[settingType.ordinal()].factor = factor;
      return RetCode.Success;
   }
   
   final private CandleSetting TA_CandleDefaultSettings[] = {
      /*
      * real body is long when it's longer than the average of the 10
      * previous candles' real body
      */
      new CandleSetting(CandleSettingType.BodyLong,
         RangeType.RealBody, 10, 1.0),
      /*
      * real body is very long when it's longer than 3 times the average
      * of the 10 previous candles' real body
      */
      new CandleSetting(CandleSettingType.BodyVeryLong,
         RangeType.RealBody, 10, 3.0),
      /*
      * real body is short when it's shorter than the average of the 10
      * previous candles' real bodies
      */
      new CandleSetting(CandleSettingType.BodyShort,
         RangeType.RealBody, 10, 1.0),
      /*
      * real body is like doji's body when it's shorter than 10% the
      * average of the 10 previous candles' high-low range
      */
      new CandleSetting(CandleSettingType.BodyDoji,
         RangeType.HighLow, 10, 0.1),
      /* shadow is long when it's longer than the real body */
      new CandleSetting(CandleSettingType.ShadowLong,
         RangeType.RealBody, 0, 1.0),
      /* shadow is very long when it's longer than 2 times the real body */
      new CandleSetting(CandleSettingType.ShadowVeryLong,
         RangeType.RealBody, 0, 2.0),
      /*
      * shadow is short when it's shorter than half the average of the 10
      * previous candles' sum of shadows
      */
      new CandleSetting(CandleSettingType.ShadowShort,
         RangeType.Shadows, 10, 1.0),
      /*
      * shadow is very short when it's shorter than 10% the average of
      * the 10 previous candles' high-low range
      */
      new CandleSetting(CandleSettingType.ShadowVeryShort,
         RangeType.HighLow, 10, 0.1),
      /* when measuring distance between parts of candles or width of gaps */
      /*
      * "near" means "<= 20% of the average of the 5 previous candles'
      * high-low range"
      */
      new CandleSetting(CandleSettingType.Near,
         RangeType.HighLow, 5, 0.2),
      /* when measuring distance between parts of candles or width of gaps */
      /*
      * "far" means ">= 60% of the average of the 5 previous candles'
      * high-low range"
      */
      new CandleSetting(CandleSettingType.Far,
         RangeType.HighLow, 5, 0.6),
      /* when measuring distance between parts of candles or width of gaps */
      /*
      * "equal" means "<= 5% of the average of the 5 previous candles'
      * high-low range"
      */
      new CandleSetting(CandleSettingType.Equal,
         RangeType.HighLow, 5, 0.05) };
   
   public RetCode RestoreCandleDefaultSettings(
      CandleSettingType settingType) {
      int i;
      if (settingType.ordinal() > CandleSettingType.AllCandleSettings
         .ordinal())
         return RetCode.BadParam;
      if (settingType == CandleSettingType.AllCandleSettings) {
         for (i = 0; i < CandleSettingType.AllCandleSettings.ordinal(); ++i) {
            candleSettings[i].CopyFrom(TA_CandleDefaultSettings[i]);
         }
      } else {
         candleSettings[settingType.ordinal()]
            .CopyFrom(TA_CandleDefaultSettings[settingType.ordinal()]);
      }
      return RetCode.Success;
   }
   
   public RetCode SetUnstablePeriod(FuncUnstId id, int period)
   {
      if (id.ordinal() >= FuncUnstId.All
         .ordinal())
         return RetCode.BadParam;
      unstablePeriod[id.ordinal()] = period;
      return RetCode.Success;
   }
   
   public int GetUnstablePeriod(FuncUnstId id)
   {
      return unstablePeriod[id.ordinal()];
   }
   
   public void SetCompatibility(Compatibility compatibility)
   {
      this.compatibility = compatibility;
   }
   
   public Compatibility getCompatibility()
   {
      return compatibility;
   }
   
   /**** START GENCODE SECTION 1 - DO NOT DELETE THIS LINE ****/
   public int accbandsLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 20;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return smaLookback ( optInTimePeriod );
   }
   public RetCode accbands( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outRealUpperBand[],
      double outRealMiddleBand[],
      double outRealLowerBand[] )
   {
      RetCode retCode;
      double []tempBuffer1 ;
      double []tempBuffer2 ;
      MInteger outBegIdxDummy = new MInteger() ;
      MInteger outNbElementDummy = new MInteger() ;
      int i, j, outputSize, bufferSize, lookbackTotal;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 20;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = smaLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outputSize = endIdx-startIdx+1;
      bufferSize = outputSize+lookbackTotal;
      tempBuffer1 = new double[bufferSize] ;
      tempBuffer2 = new double[bufferSize] ;
      for(j=0, i=startIdx-lookbackTotal; i<=endIdx; i++, j++)
      {
         tempReal = inHigh[i]+inLow[i];
         if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
         {
            tempReal = 4*(inHigh[i]-inLow[i])/tempReal;
            tempBuffer1[j] = inHigh[i]*(1+tempReal);
            tempBuffer2[j] = inLow[i]*(1-tempReal);
         }
         else
         {
            tempBuffer1[j] = inHigh[i];
            tempBuffer2[j] = inLow[i];
         }
      }
      retCode = sma ( startIdx, endIdx, inClose,
         optInTimePeriod,
         outBegIdxDummy , outNbElementDummy , outRealMiddleBand );
      if( (retCode != RetCode.Success ) || ((int) outNbElementDummy.value != outputSize) )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      retCode = sma ( 0, bufferSize-1, tempBuffer1,
         optInTimePeriod,
         outBegIdxDummy , outNbElementDummy ,
         outRealUpperBand );
      if( (retCode != RetCode.Success ) || ((int) outNbElementDummy.value != outputSize) )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      retCode = sma ( 0, bufferSize-1, tempBuffer2,
         optInTimePeriod,
         outBegIdxDummy , outNbElementDummy ,
         outRealLowerBand );
      if( (retCode != RetCode.Success ) || ((int) outNbElementDummy.value != outputSize) )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outputSize;
      return RetCode.Success ;
   }
   public RetCode accbandsStateInit( struct TA_accbands_State** _state,
      int optInTimePeriod )
   {
      TA_RetCode retCode;
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 20;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct accbands ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = accbandsLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      retCode = sma ( (struct sma **) & _state.value .value .stateSMA1, optInTimePeriod );
      if (retCode != RetCode.Success ) return retCode;
      retCode = sma ( (struct sma **) & _state.value .value .stateSMA2, optInTimePeriod );
      if (retCode != RetCode.Success ) return retCode;
      retCode = sma ( (struct sma **) & _state.value .value .stateSMA3, optInTimePeriod );
      if (retCode != RetCode.Success ) return retCode;
      return RetCode.Success ;
   }
   public RetCode accbandsState( struct TA_accbands_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outRealUpperBand,
      double *outRealMiddleBand,
      double *outRealLowerBand )
   {
      TA_RetCode retCode1, retCode2, retCode3;
      double tempReal,tempReal1,tempReal2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      tempReal = inHigh+inLow;
      if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
      {
         tempReal = 4*(inHigh-inLow)/tempReal;
         tempReal1 = inHigh*(1+tempReal);
         tempReal2 = inLow*(1-tempReal);
      }
      else
      {
         tempReal1 = inHigh;
         tempReal2 = inLow;
      }
      retCode1 = sma ( (struct sma *) _state.value .stateSMA1, inClose, outRealMiddleBand );
      retCode2 = sma ( (struct sma *) _state.value .stateSMA2, tempReal1, outRealUpperBand );
      retCode3 = sma ( (struct sma *) _state.value .stateSMA3, tempReal2, outRealLowerBand );
      return retCode1 | retCode2 | retCode3;
   }
   public RetCode accbandsStateFree( struct TA_accbands_State** _state )
   {
      TA_RetCode retCode;
      retCode = sma ( (struct sma **) & _state.value .value .stateSMA1 );
      if (retCode != RetCode.Success ) return retCode;
      retCode = sma ( (struct sma **) & _state.value .value .stateSMA2 );
      if (retCode != RetCode.Success ) return retCode;
      retCode = sma ( (struct sma **) & _state.value .value .stateSMA3 );
      if (retCode != RetCode.Success ) return retCode;
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode accbandsStateSave( struct TA_accbands_State* _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_ACCBANDS_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_SMA_StateSave ( (struct sma *) _state.value .stateSMA1, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_SMA_StateSave ( (struct sma *) _state.value .stateSMA2, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_SMA_StateSave ( (struct sma *) _state.value .stateSMA3, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode accbandsStateLoad( struct TA_accbands_State** _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct accbands ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_ACCBANDS_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_ACCBANDS_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_SMA_StateLoad ( (struct sma **) & _state.value .value .stateSMA1, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_SMA_StateLoad ( (struct sma **) & _state.value .value .stateSMA2, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_SMA_StateLoad ( (struct sma **) & _state.value .value .stateSMA3, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode accbands( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outRealUpperBand[],
      double outRealMiddleBand[],
      double outRealLowerBand[] )
   {
      RetCode retCode;
      double []tempBuffer1 ;
      double []tempBuffer2 ;
      MInteger outBegIdxDummy = new MInteger() ;
      MInteger outNbElementDummy = new MInteger() ;
      int i, j, outputSize, bufferSize, lookbackTotal;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 20;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = smaLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outputSize = endIdx-startIdx+1;
      bufferSize = outputSize+lookbackTotal;
      tempBuffer1 = new double[bufferSize] ;
      tempBuffer2 = new double[bufferSize] ;
      for(j=0, i=startIdx-lookbackTotal; i<=endIdx; i++, j++)
      {
         tempReal = inHigh[i]+inLow[i];
         if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
         {
            tempReal = 4*(inHigh[i]-inLow[i])/tempReal;
            tempBuffer1[j] = inHigh[i]*(1+tempReal);
            tempBuffer2[j] = inLow[i]*(1-tempReal);
         }
         else
         {
            tempBuffer1[j] = inHigh[i];
            tempBuffer2[j] = inLow[i];
         }
      }
      retCode = sma ( startIdx, endIdx, inClose,
         optInTimePeriod,
         outBegIdxDummy , outNbElementDummy , outRealMiddleBand );
      if( (retCode != RetCode.Success ) || ((int) outNbElementDummy.value != outputSize) )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      retCode = sma ( 0, bufferSize-1, tempBuffer1,
         optInTimePeriod,
         outBegIdxDummy , outNbElementDummy ,
         outRealUpperBand );
      if( (retCode != RetCode.Success ) || ((int) outNbElementDummy.value != outputSize) )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      retCode = sma ( 0, bufferSize-1, tempBuffer2,
         optInTimePeriod,
         outBegIdxDummy , outNbElementDummy ,
         outRealLowerBand );
      if( (retCode != RetCode.Success ) || ((int) outNbElementDummy.value != outputSize) )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outputSize;
      return RetCode.Success ;
   }
   /* Generated */
   public int acosLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode acos( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.acos (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode acosStateInit( struct TA_acos_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct acos ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = acosLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_ACOS_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode acosState( struct TA_acos_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.acos (inReal);
      return RetCode.Success ;
   }
   public RetCode acosStateFree( struct TA_acos_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode acosStateSave( struct TA_acos_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_ACOS_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode acosStateLoad( struct TA_acos_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct acos ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_ACOS_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_ACOS_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode acos( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.acos (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int adLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode ad( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      double inVolume[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int nbBar, currentBar, outIdx;
      double high, low, close, tmp;
      double ad;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      nbBar = endIdx-startIdx+1;
      outNBElement.value = nbBar;
      outBegIdx.value = startIdx;
      currentBar = startIdx;
      outIdx = 0;
      ad = 0.0;
      while( nbBar != 0 )
      {
         high = inHigh[currentBar];
         low = inLow[currentBar];
         tmp = high-low;
         close = inClose[currentBar];
         if( tmp > 0.0 )
            ad += (((close-low)-(high-close))/tmp)*((double)inVolume[currentBar]);
         outReal[outIdx++] = ad;
         currentBar++;
         nbBar--;
      }
      return RetCode.Success ;
   }
   public RetCode adStateInit( struct TA_ad_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct ad ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = adLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_AD_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode adState( struct TA_ad_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double inVolume,
      double *outReal )
   {
      double tmp;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         ( _state.value .memory+_cur_idx).value .inVolume = inVolume ;
         return RetCode.NeedMoreData ; }
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .ad = 0;
      }
      tmp = inHigh - inLow;
      if( tmp > 0.0 )
         _state.value .ad += (((inClose-inLow)-(inHigh-inClose))/tmp)*((double)inVolume);
      outReal.value = _state.value .ad;
      return RetCode.Success ;
   }
   public RetCode adStateFree( struct TA_ad_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode adStateSave( struct TA_ad_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_AD_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .ad,sizeof( _state.value .ad),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode adStateLoad( struct TA_ad_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct ad ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_AD_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_AD_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .ad,sizeof( _state.value .value .ad),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode ad( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      float inVolume[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int nbBar, currentBar, outIdx;
      double high, low, close, tmp;
      double ad;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      nbBar = endIdx-startIdx+1;
      outNBElement.value = nbBar;
      outBegIdx.value = startIdx;
      currentBar = startIdx;
      outIdx = 0;
      ad = 0.0;
      while( nbBar != 0 )
      {
         high = inHigh[currentBar];
         low = inLow[currentBar];
         tmp = high-low;
         close = inClose[currentBar];
         if( tmp > 0.0 )
            ad += (((close-low)-(high-close))/tmp)*((double)inVolume[currentBar]);
         outReal[outIdx++] = ad;
         currentBar++;
         nbBar--;
      }
      return RetCode.Success ;
   }
   /* Generated */
   public int addLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode add( int startIdx,
      int endIdx,
      double inReal0[],
      double inReal1[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = inReal0[i]+inReal1[i];
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode addStateInit( struct TA_add_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct add ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = addLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_ADD_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode addState( struct TA_add_State* _state,
      double inReal0,
      double inReal1,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal0 = inReal0 ;
         ( _state.value .memory+_cur_idx).value .inReal1 = inReal1 ;
         return RetCode.NeedMoreData ; }
      outReal.value = inReal0 + inReal1;
      return RetCode.Success ;
   }
   public RetCode addStateFree( struct TA_add_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode addStateSave( struct TA_add_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_ADD_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode addStateLoad( struct TA_add_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct add ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_ADD_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_ADD_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode add( int startIdx,
      int endIdx,
      float inReal0[],
      float inReal1[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = inReal0[i]+inReal1[i];
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int adOscLookback( int optInFastPeriod,
      int optInSlowPeriod )
   {
      int slowestPeriod;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 3;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return -1;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 10;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return -1;
      if( optInFastPeriod < optInSlowPeriod )
         slowestPeriod = optInSlowPeriod;
      else
         slowestPeriod = optInFastPeriod;
      return emaLookback ( slowestPeriod );
   }
   public RetCode adOsc( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      double inVolume[],
      int optInFastPeriod,
      int optInSlowPeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, outIdx, lookbackTotal;
      int slowestPeriod;
      double high, low, close, tmp;
      double slowEMA, slowk, one_minus_slowk;
      double fastEMA, fastk, one_minus_fastk;
      double ad;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 3;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 10;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      if( optInFastPeriod < optInSlowPeriod )
         slowestPeriod = optInSlowPeriod;
      else
         slowestPeriod = optInFastPeriod;
      lookbackTotal = emaLookback ( slowestPeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      today = startIdx-lookbackTotal;
      ad = 0.0;
      fastk = ((double)2.0 / ((double)(optInFastPeriod + 1))) ;
      one_minus_fastk = 1.0 - fastk;
      slowk = ((double)2.0 / ((double)(optInSlowPeriod + 1))) ;
      one_minus_slowk = 1.0 - slowk;
      { high = inHigh[today]; low = inLow[today]; tmp = high-low; close = inClose[today]; if( tmp > 0.0 ) ad += (((close-low)-(high-close))/tmp)*((double)inVolume[today]); today++; } ;
      fastEMA = ad;
      slowEMA = ad;
      while( today < startIdx )
      {
         { high = inHigh[today]; low = inLow[today]; tmp = high-low; close = inClose[today]; if( tmp > 0.0 ) ad += (((close-low)-(high-close))/tmp)*((double)inVolume[today]); today++; } ;
         fastEMA = (fastk*ad)+(one_minus_fastk*fastEMA);
         slowEMA = (slowk*ad)+(one_minus_slowk*slowEMA);
      }
      outIdx = 0;
      while( today <= endIdx )
      {
         { high = inHigh[today]; low = inLow[today]; tmp = high-low; close = inClose[today]; if( tmp > 0.0 ) ad += (((close-low)-(high-close))/tmp)*((double)inVolume[today]); today++; } ;
         fastEMA = (fastk*ad)+(one_minus_fastk*fastEMA);
         slowEMA = (slowk*ad)+(one_minus_slowk*slowEMA);
         outReal[outIdx++] = fastEMA - slowEMA;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode adOscStateInit( struct TA_adOsc_State** _state,
      int optInFastPeriod,
      int optInSlowPeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 3;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 10;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct adOsc ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInFastPeriod = optInFastPeriod;
      _state.value .value .optInSlowPeriod = optInSlowPeriod;
      _state.value .value .mem_size = adOscLookback (optInFastPeriod, optInSlowPeriod );
      _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode adOscState( struct TA_adOsc_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double inVolume,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .fastk = ((double)2.0 / ((double)( _state.value .optInFastPeriod + 1))) ;
         _state.value .one_minus_fastk = 1.0 - _state.value .fastk;
         _state.value .slowk = ((double)2.0 / ((double)( _state.value .optInSlowPeriod + 1))) ;
         _state.value .one_minus_slowk = 1.0 - _state.value .slowk;
         _state.value .ad = 0;
         { if( inHigh > inLow ) _state.value .ad += (((inClose-inLow)-(inHigh-inClose))/(inHigh-inLow))*((double)inVolume); } ;
         _state.value .fastEMA = _state.value .ad;
         _state.value .slowEMA = _state.value .ad;
         return RetCode.NeedMoreData ;
      }
      { if( inHigh > inLow ) _state.value .ad += (((inClose-inLow)-(inHigh-inClose))/(inHigh-inLow))*((double)inVolume); } ;
      _state.value .fastEMA = ( _state.value .fastk* _state.value .ad)+( _state.value .one_minus_fastk* _state.value .fastEMA);
      _state.value .slowEMA = ( _state.value .slowk* _state.value .ad)+( _state.value .one_minus_slowk* _state.value .slowEMA);
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      outReal.value = _state.value .fastEMA - _state.value .slowEMA;
      return RetCode.Success ;
   }
   public RetCode adOscStateFree( struct TA_adOsc_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode adOscStateSave( struct TA_adOsc_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_ADOSC_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInFastPeriod,sizeof( _state.value .optInFastPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInSlowPeriod,sizeof( _state.value .optInSlowPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .slowk,sizeof( _state.value .slowk),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .one_minus_slowk,sizeof( _state.value .one_minus_slowk),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .fastk,sizeof( _state.value .fastk),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .one_minus_fastk,sizeof( _state.value .one_minus_fastk),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ad,sizeof( _state.value .ad),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .fastEMA,sizeof( _state.value .fastEMA),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .slowEMA,sizeof( _state.value .slowEMA),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode adOscStateLoad( struct TA_adOsc_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct adOsc ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_ADOSC_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_ADOSC_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInFastPeriod,sizeof( _state.value .value .optInFastPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInSlowPeriod,sizeof( _state.value .value .optInSlowPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .slowk,sizeof( _state.value .value .slowk),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .one_minus_slowk,sizeof( _state.value .value .one_minus_slowk),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .fastk,sizeof( _state.value .value .fastk),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .one_minus_fastk,sizeof( _state.value .value .one_minus_fastk),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ad,sizeof( _state.value .value .ad),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .fastEMA,sizeof( _state.value .value .fastEMA),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .slowEMA,sizeof( _state.value .value .slowEMA),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode adOsc( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      float inVolume[],
      int optInFastPeriod,
      int optInSlowPeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, outIdx, lookbackTotal;
      int slowestPeriod;
      double high, low, close, tmp;
      double slowEMA, slowk, one_minus_slowk;
      double fastEMA, fastk, one_minus_fastk;
      double ad;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 3;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 10;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      if( optInFastPeriod < optInSlowPeriod )
         slowestPeriod = optInSlowPeriod;
      else
         slowestPeriod = optInFastPeriod;
      lookbackTotal = emaLookback ( slowestPeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      today = startIdx-lookbackTotal;
      ad = 0.0;
      fastk = ((double)2.0 / ((double)(optInFastPeriod + 1))) ;
      one_minus_fastk = 1.0 - fastk;
      slowk = ((double)2.0 / ((double)(optInSlowPeriod + 1))) ;
      one_minus_slowk = 1.0 - slowk;
      { high = inHigh[today]; low = inLow[today]; tmp = high-low; close = inClose[today]; if( tmp > 0.0 ) ad += (((close-low)-(high-close))/tmp)*((double)inVolume[today]); today++; } ;
      fastEMA = ad;
      slowEMA = ad;
      while( today < startIdx )
      {
         { high = inHigh[today]; low = inLow[today]; tmp = high-low; close = inClose[today]; if( tmp > 0.0 ) ad += (((close-low)-(high-close))/tmp)*((double)inVolume[today]); today++; } ;
         fastEMA = (fastk*ad)+(one_minus_fastk*fastEMA);
         slowEMA = (slowk*ad)+(one_minus_slowk*slowEMA);
      }
      outIdx = 0;
      while( today <= endIdx )
      {
         { high = inHigh[today]; low = inLow[today]; tmp = high-low; close = inClose[today]; if( tmp > 0.0 ) ad += (((close-low)-(high-close))/tmp)*((double)inVolume[today]); today++; } ;
         fastEMA = (fastk*ad)+(one_minus_fastk*fastEMA);
         slowEMA = (slowk*ad)+(one_minus_slowk*slowEMA);
         outReal[outIdx++] = fastEMA - slowEMA;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int adxLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return (2 * optInTimePeriod) + (this.unstablePeriod[FuncUnstId.Adx.ordinal()]) - 1;
   }
   public RetCode adx( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, lookbackTotal, outIdx;
      double prevHigh, prevLow, prevClose;
      double prevMinusDM, prevPlusDM, prevTR;
      double tempReal, tempReal2, diffP, diffM;
      double minusDI, plusDI, sumDX, prevADX;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = (2*optInTimePeriod) + (this.unstablePeriod[FuncUnstId.Adx.ordinal()]) - 1;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      outBegIdx.value = today = startIdx;
      prevMinusDM = 0.0;
      prevPlusDM = 0.0;
      prevTR = 0.0;
      today = startIdx - lookbackTotal;
      prevHigh = inHigh[today];
      prevLow = inLow[today];
      prevClose = inClose[today];
      i = optInTimePeriod-1;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         else if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR += tempReal;
         prevClose = inClose[today];
      }
      sumDX = 0.0;
      i = optInTimePeriod;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         prevMinusDM -= prevMinusDM/optInTimePeriod;
         prevPlusDM -= prevPlusDM/optInTimePeriod;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         else if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
         if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
         {
            minusDI = (100.0*(prevMinusDM/prevTR)) ;
            plusDI = (100.0*(prevPlusDM/prevTR)) ;
            tempReal = minusDI+plusDI;
            if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
               sumDX += (100.0 * ( Math.abs (minusDI-plusDI)/tempReal)) ;
         }
      }
      prevADX = (sumDX / optInTimePeriod) ;
      i = (this.unstablePeriod[FuncUnstId.Adx.ordinal()]) ;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         prevMinusDM -= prevMinusDM/optInTimePeriod;
         prevPlusDM -= prevPlusDM/optInTimePeriod;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         else if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
         if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
         {
            minusDI = (100.0*(prevMinusDM/prevTR)) ;
            plusDI = (100.0*(prevPlusDM/prevTR)) ;
            tempReal = minusDI+plusDI;
            if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
            {
               tempReal = (100.0*( Math.abs (minusDI-plusDI)/tempReal)) ;
               prevADX = (((prevADX*(optInTimePeriod-1))+tempReal)/optInTimePeriod) ;
            }
         }
      }
      outReal[0] = prevADX;
      outIdx = 1;
      while( today < endIdx )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         prevMinusDM -= prevMinusDM/optInTimePeriod;
         prevPlusDM -= prevPlusDM/optInTimePeriod;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         else if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
         if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
         {
            minusDI = (100.0*(prevMinusDM/prevTR)) ;
            plusDI = (100.0*(prevPlusDM/prevTR)) ;
            tempReal = minusDI+plusDI;
            if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
            {
               tempReal = (100.0*( Math.abs (minusDI-plusDI)/tempReal)) ;
               prevADX = (((prevADX*(optInTimePeriod-1))+tempReal)/optInTimePeriod) ;
            }
         }
         outReal[outIdx++] = prevADX;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode adxStateInit( struct TA_adx_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct adx ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = adxLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode adxState( struct TA_adx_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      double tempReal, tempReal2, diffP, diffM;
      double minusDI, plusDI;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .prevMinusDM = 0.0;
         _state.value .prevPlusDM = 0.0;
         _state.value .prevTR = 0.0;
         _state.value .prevADX = 0.0;
         _state.value .sumDX = 0.0;
         _state.value .prevHigh = inHigh;
         _state.value .prevLow = inLow;
         _state.value .prevClose = inClose;
         return RetCode.NeedMoreData ;
      }
      diffP = inHigh- _state.value .prevHigh;
      _state.value .prevHigh = inHigh;
      diffM = _state.value .prevLow-inLow;
      _state.value .prevLow = inLow;
      if ((int) _state.value .mem_index > _state.value .optInTimePeriod )
      {
         _state.value .prevMinusDM -= _state.value .prevMinusDM/ _state.value .optInTimePeriod;
         _state.value .prevPlusDM -= _state.value .prevPlusDM/ _state.value .optInTimePeriod;
      }
      if( (diffM > 0) && (diffP < diffM) )
      {
         _state.value .prevMinusDM += diffM;
      }
      else if( (diffP > 0) && (diffP > diffM) )
      {
         _state.value .prevPlusDM += diffP;
      }
      { tempReal = _state.value .prevHigh- _state.value .prevLow; tempReal2 = Math.abs ( _state.value .prevHigh- _state.value .prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs ( _state.value .prevLow- _state.value .prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
      if ((int) _state.value .mem_index < _state.value .optInTimePeriod )
         _state.value .prevTR += tempReal;
      else
         _state.value .prevTR = _state.value .prevTR - ( _state.value .prevTR/ _state.value .optInTimePeriod) + tempReal;
      _state.value .prevClose = inClose;
      if ((int) _state.value .mem_index > _state.value .optInTimePeriod )
      {
         if( ! (((- (0.00000000000001) )< _state.value .prevTR)&&( _state.value .prevTR< (0.00000000000001) )) )
         {
            minusDI = (100.0*( _state.value .prevMinusDM/ _state.value .prevTR)) ;
            plusDI = (100.0*( _state.value .prevPlusDM/ _state.value .prevTR)) ;
            tempReal = minusDI+plusDI;
            if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
            {
               if ((int) _state.value .mem_index > 2* _state.value .optInTimePeriod )
               {
                  tempReal= (100.0 * ( Math.abs (minusDI-plusDI)/tempReal)) ;
                  _state.value .prevADX = ((( _state.value .prevADX*( _state.value .optInTimePeriod-1))+tempReal)/ _state.value .optInTimePeriod) ;
               } else {
                  _state.value .sumDX += (100.0 * ( Math.abs (minusDI-plusDI)/tempReal)) ;
                  _state.value .prevADX = ( _state.value .sumDX / _state.value .optInTimePeriod) ;
               }
            }
         }
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      outReal.value = _state.value .prevADX;
      return RetCode.Success ;
   }
   public RetCode adxStateFree( struct TA_adx_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode adxStateSave( struct TA_adx_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_ADX_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevHigh,sizeof( _state.value .prevHigh),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevLow,sizeof( _state.value .prevLow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevClose,sizeof( _state.value .prevClose),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevMinusDM,sizeof( _state.value .prevMinusDM),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevPlusDM,sizeof( _state.value .prevPlusDM),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevTR,sizeof( _state.value .prevTR),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevADX,sizeof( _state.value .prevADX),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .sumDX,sizeof( _state.value .sumDX),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode adxStateLoad( struct TA_adx_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct adx ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_ADX_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_ADX_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevHigh,sizeof( _state.value .value .prevHigh),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevLow,sizeof( _state.value .value .prevLow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevClose,sizeof( _state.value .value .prevClose),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevMinusDM,sizeof( _state.value .value .prevMinusDM),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevPlusDM,sizeof( _state.value .value .prevPlusDM),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevTR,sizeof( _state.value .value .prevTR),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevADX,sizeof( _state.value .value .prevADX),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .sumDX,sizeof( _state.value .value .sumDX),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode adx( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, lookbackTotal, outIdx;
      double prevHigh, prevLow, prevClose;
      double prevMinusDM, prevPlusDM, prevTR;
      double tempReal, tempReal2, diffP, diffM;
      double minusDI, plusDI, sumDX, prevADX;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = (2*optInTimePeriod) + (this.unstablePeriod[FuncUnstId.Adx.ordinal()]) - 1;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      outBegIdx.value = today = startIdx;
      prevMinusDM = 0.0;
      prevPlusDM = 0.0;
      prevTR = 0.0;
      today = startIdx - lookbackTotal;
      prevHigh = inHigh[today];
      prevLow = inLow[today];
      prevClose = inClose[today];
      i = optInTimePeriod-1;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         else if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR += tempReal;
         prevClose = inClose[today];
      }
      sumDX = 0.0;
      i = optInTimePeriod;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         prevMinusDM -= prevMinusDM/optInTimePeriod;
         prevPlusDM -= prevPlusDM/optInTimePeriod;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         else if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
         if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
         {
            minusDI = (100.0*(prevMinusDM/prevTR)) ;
            plusDI = (100.0*(prevPlusDM/prevTR)) ;
            tempReal = minusDI+plusDI;
            if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
               sumDX += (100.0 * ( Math.abs (minusDI-plusDI)/tempReal)) ;
         }
      }
      prevADX = (sumDX / optInTimePeriod) ;
      i = (this.unstablePeriod[FuncUnstId.Adx.ordinal()]) ;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         prevMinusDM -= prevMinusDM/optInTimePeriod;
         prevPlusDM -= prevPlusDM/optInTimePeriod;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         else if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
         if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
         {
            minusDI = (100.0*(prevMinusDM/prevTR)) ;
            plusDI = (100.0*(prevPlusDM/prevTR)) ;
            tempReal = minusDI+plusDI;
            if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
            {
               tempReal = (100.0*( Math.abs (minusDI-plusDI)/tempReal)) ;
               prevADX = (((prevADX*(optInTimePeriod-1))+tempReal)/optInTimePeriod) ;
            }
         }
      }
      outReal[0] = prevADX;
      outIdx = 1;
      while( today < endIdx )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         prevMinusDM -= prevMinusDM/optInTimePeriod;
         prevPlusDM -= prevPlusDM/optInTimePeriod;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         else if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
         if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
         {
            minusDI = (100.0*(prevMinusDM/prevTR)) ;
            plusDI = (100.0*(prevPlusDM/prevTR)) ;
            tempReal = minusDI+plusDI;
            if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
            {
               tempReal = (100.0*( Math.abs (minusDI-plusDI)/tempReal)) ;
               prevADX = (((prevADX*(optInTimePeriod-1))+tempReal)/optInTimePeriod) ;
            }
         }
         outReal[outIdx++] = prevADX;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int adxrLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      if( optInTimePeriod > 1 )
         return optInTimePeriod + adxLookback ( optInTimePeriod) - 1;
      else
         return 3;
   }
   public RetCode adxr( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double []adx ;
      int adxrLookback, i, j, outIdx, nbElement;
      RetCode retCode;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      adxrLookback = adxrLookback ( optInTimePeriod );
      if( startIdx < adxrLookback )
         startIdx = adxrLookback;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      adx = new double[endIdx-startIdx+optInTimePeriod] ;
      retCode = adx ( startIdx-(optInTimePeriod-1), endIdx,
         inHigh, inLow, inClose,
         optInTimePeriod, outBegIdx, outNBElement, adx );
      if( retCode != RetCode.Success )
      {
         return retCode;
      }
      i = optInTimePeriod-1;
      j = 0;
      outIdx = 0;
      nbElement = endIdx-startIdx+2;
      while( --nbElement != 0 )
         outReal[outIdx++] = ((adx[i++]+adx[j++])/2.0) ;
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode adxrStateInit( struct TA_adxr_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct adxr ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = adxrLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      if( optInTimePeriod > 1 )
         _state.value .value .mem_size = optInTimePeriod-1;
      else
         _state.value .value .mem_size = 3;
      _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_ADXR_Data));
      return adx ((struct adx **)& _state.value .value .ADXState, _state.value .value .optInTimePeriod);
   }
   public RetCode adxrState( struct TA_adxr_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      RetCode retCode;
      double tempReal;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      retCode = adx ((struct adx *) _state.value .ADXState, inHigh, inLow, inClose, &tempReal);
      if (retCode != RetCode.Success )
      {
         if (retCode == RetCode.NeedMoreData )
         {
            _state.value .mem_index--;
         }
         return retCode;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         outReal.value = (( ( _state.value .memory+_cur_idx).value .inClose +tempReal)/2.0) ;
         ( _state.value .memory+_cur_idx).value .inClose = tempReal ;
      } else {
         ( _state.value .memory+_cur_idx).value .inClose = tempReal ;
         return RetCode.NeedMoreData ;
      }
      return RetCode.Success ;
   }
   public RetCode adxrStateFree( struct TA_adxr_State** _state )
   {
      RetCode retCode;
      retCode = adx ((struct adx **)& _state.value .value .ADXState);
      if (retCode != RetCode.Success ) return retCode;
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode adxrStateSave( struct TA_adxr_State* _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_ADXR_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_ADX_StateSave ( (struct adx *) _state.value .ADXState, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode adxrStateLoad( struct TA_adxr_State** _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct adxr ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_ADXR_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_ADXR_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_ADX_StateLoad ( (struct adx **) & _state.value .value .ADXState, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode adxr( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double []adx ;
      int adxrLookback, i, j, outIdx, nbElement;
      RetCode retCode;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      adxrLookback = adxrLookback ( optInTimePeriod );
      if( startIdx < adxrLookback )
         startIdx = adxrLookback;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      adx = new double[endIdx-startIdx+optInTimePeriod] ;
      retCode = adx ( startIdx-(optInTimePeriod-1), endIdx,
         inHigh, inLow, inClose,
         optInTimePeriod, outBegIdx, outNBElement, adx );
      if( retCode != RetCode.Success )
      {
         return retCode;
      }
      i = optInTimePeriod-1;
      j = 0;
      outIdx = 0;
      nbElement = endIdx-startIdx+2;
      while( --nbElement != 0 )
         outReal[outIdx++] = ((adx[i++]+adx[j++])/2.0) ;
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int apoLookback( int optInFastPeriod,
      int optInSlowPeriod,
      MAType optInMAType )
   {
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return -1;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return -1;
      return movingAverageLookback ( (((optInSlowPeriod) > (optInFastPeriod)) ? (optInSlowPeriod) : (optInFastPeriod)) , optInMAType );
   }
   public RetCode apo( int startIdx,
      int endIdx,
      double inReal[],
      int optInFastPeriod,
      int optInSlowPeriod,
      MAType optInMAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double []tempBuffer ;
      RetCode retCode;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      tempBuffer = new double[(endIdx-startIdx+1)] ;
      retCode = TA_INT_PO ( startIdx, endIdx,
         inReal,
         optInFastPeriod,
         optInSlowPeriod,
         optInMAType,
         outBegIdx,
         outNBElement,
         outReal,
         tempBuffer,
         0 );
      return retCode;
   }
   RetCode TA_INT_PO( int startIdx,
      int endIdx,
      double inReal[],
      int optInFastPeriod,
      int optInSlowPeriod,
      MAType optInMethod_2,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[],
      double tempBuffer[],
      int doPercentageOutput )
   {
      RetCode retCode;
      double tempReal;
      int tempInteger;
      MInteger outBegIdx1 = new MInteger() ;
      MInteger outNbElement1 = new MInteger() ;
      MInteger outBegIdx2 = new MInteger() ;
      MInteger outNbElement2 = new MInteger() ;
      int i, j;
      if( optInSlowPeriod < optInFastPeriod )
      {
         tempInteger = optInSlowPeriod;
         optInSlowPeriod = optInFastPeriod;
         optInFastPeriod = tempInteger;
      }
      retCode = movingAverage ( startIdx, endIdx,
         inReal,
         optInFastPeriod,
         optInMethod_2,
         outBegIdx2 , outNbElement2 ,
         tempBuffer );
      if( retCode == RetCode.Success )
      {
         retCode = movingAverage ( startIdx, endIdx,
            inReal,
            optInSlowPeriod,
            optInMethod_2,
            outBegIdx1 , outNbElement1 ,
            outReal );
         if( retCode == RetCode.Success )
         {
            tempInteger = outBegIdx1.value - outBegIdx2.value ;
            if( doPercentageOutput != 0 )
            {
               for( i=0,j=tempInteger; i < outNbElement1.value ; i++, j++ )
               {
                  tempReal = outReal[i];
                  if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
                     outReal[i] = ((tempBuffer[j]-tempReal)/tempReal)*100.0;
                  else
                     outReal[i] = 0.0;
               }
            }
            else
            {
               for( i=0,j=tempInteger; i < outNbElement1.value ; i++, j++ )
                  outReal[i] = tempBuffer[j]-outReal[i];
            }
            outBegIdx.value = outBegIdx1.value ;
            outNBElement.value = outNbElement1.value ;
         }
      }
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
      }
      return retCode;
   }
   public RetCode apoStateInit( struct TA_apo_State** _state,
      int optInFastPeriod,
      int optInSlowPeriod,
      MAType optInMAType )
   {
      return TA_INT_PO_StateInit (_state, optInFastPeriod, optInSlowPeriod, optInMAType, 0);
   }
   public int TA_INT_PO_StateInit( struct TA_apo_State** _state,
      int optInFastPeriod,
      int optInSlowPeriod,
      MAType optInMAType,
      int doPercentageOutput)
   {
      int tempInteger;
      TA_RetCode retCode;
      if( optInSlowPeriod < optInFastPeriod )
      {
         tempInteger = optInSlowPeriod;
         optInSlowPeriod = optInFastPeriod;
         optInFastPeriod = tempInteger;
      }
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct apo ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInFastPeriod = optInFastPeriod;
      _state.value .value .optInSlowPeriod = optInSlowPeriod;
      _state.value .value .optInMAType = optInMAType;
      _state.value .value .mem_size = apoLookback (optInFastPeriod, optInSlowPeriod, optInMAType );
      _state.value .value .memory = NULL;
      _state.value .value .doPercentageOutput = doPercentageOutput;
      retCode = movingAverage ((struct movingAverage **)& _state.value .value .fastMAState, _state.value .value .optInFastPeriod, _state.value .value .optInMAType);
      if ( retCode != RetCode.Success )
         return retCode;
      return movingAverage ((struct movingAverage **)& _state.value .value .slowMAState, _state.value .value .optInSlowPeriod, _state.value .value .optInMAType);
   }
   public RetCode apoState( struct TA_apo_State* _state,
      double inReal,
      double *outReal )
   {
      double fastMA, slowMA;
      int res1, res2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      res1 = movingAverage ((struct movingAverage *) _state.value .fastMAState, inReal, &fastMA);
      res2 = movingAverage ((struct movingAverage *) _state.value .slowMAState, inReal, &slowMA);
      if (res1|res2)
         return (res1|res2);
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      if ( _state.value .doPercentageOutput != 0)
      {
         if( ! (((- (0.00000000000001) )<slowMA)&&(slowMA< (0.00000000000001) )) )
            outReal.value = ((fastMA-slowMA)/slowMA)*100.0;
         else
            outReal.value = 0.0;
      } else
         outReal.value = fastMA - slowMA;
      return RetCode.Success ;
   }
   public RetCode apoStateFree( struct TA_apo_State** _state )
   {
      int res = movingAverage ((struct movingAverage **)& _state.value .value .fastMAState);
      if (res != RetCode.Success ) return res;
      res = movingAverage ((struct movingAverage **)& _state.value .value .slowMAState);
      if (res != RetCode.Success ) return res;
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode apoStateSave( struct TA_apo_State* _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_APO_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInFastPeriod,sizeof( _state.value .optInFastPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInSlowPeriod,sizeof( _state.value .optInSlowPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInMAType,sizeof( _state.value .optInMAType),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .doPercentageOutput,sizeof( _state.value .doPercentageOutput),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_MA_StateSave ( (struct movingAverage *) _state.value .fastMAState, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_MA_StateSave ( (struct movingAverage *) _state.value .slowMAState, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode apoStateLoad( struct TA_apo_State** _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct apo ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_APO_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_APO_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInFastPeriod,sizeof( _state.value .value .optInFastPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInSlowPeriod,sizeof( _state.value .value .optInSlowPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInMAType,sizeof( _state.value .value .optInMAType),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .doPercentageOutput,sizeof( _state.value .value .doPercentageOutput),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_MA_StateLoad ( (struct movingAverage **) & _state.value .value .fastMAState, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_MA_StateLoad ( (struct movingAverage **) & _state.value .value .slowMAState, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode apo( int startIdx,
      int endIdx,
      float inReal[],
      int optInFastPeriod,
      int optInSlowPeriod,
      MAType optInMAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double []tempBuffer ;
      RetCode retCode;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      tempBuffer = new double[(endIdx-startIdx+1)] ;
      retCode = TA_INT_PO ( startIdx, endIdx,
         inReal,
         optInFastPeriod,
         optInSlowPeriod,
         optInMAType,
         outBegIdx,
         outNBElement,
         outReal,
         tempBuffer,
         0 );
      return retCode;
   }
   RetCode TA_INT_PO( int startIdx,
      int endIdx,
      float inReal[],
      int optInFastPeriod,
      int optInSlowPeriod,
      MAType optInMethod_2,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[],
      double tempBuffer[],
      int doPercentageOutput )
   {
      RetCode retCode;
      double tempReal;
      int tempInteger;
      MInteger outBegIdx1 = new MInteger() ;
      MInteger outNbElement1 = new MInteger() ;
      MInteger outBegIdx2 = new MInteger() ;
      MInteger outNbElement2 = new MInteger() ;
      int i, j;
      if( optInSlowPeriod < optInFastPeriod )
      {
         tempInteger = optInSlowPeriod;
         optInSlowPeriod = optInFastPeriod;
         optInFastPeriod = tempInteger;
      }
      retCode = movingAverage ( startIdx, endIdx,
         inReal,
         optInFastPeriod,
         optInMethod_2,
         outBegIdx2 , outNbElement2 ,
         tempBuffer );
      if( retCode == RetCode.Success )
      {
         retCode = movingAverage ( startIdx, endIdx,
            inReal,
            optInSlowPeriod,
            optInMethod_2,
            outBegIdx1 , outNbElement1 ,
            outReal );
         if( retCode == RetCode.Success )
         {
            tempInteger = outBegIdx1.value - outBegIdx2.value ;
            if( doPercentageOutput != 0 )
            {
               for( i=0,j=tempInteger; i < outNbElement1.value ; i++, j++ )
               {
                  tempReal = outReal[i];
                  if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
                     outReal[i] = ((tempBuffer[j]-tempReal)/tempReal)*100.0;
                  else
                     outReal[i] = 0.0;
               }
            }
            else
            {
               for( i=0,j=tempInteger; i < outNbElement1.value ; i++, j++ )
                  outReal[i] = tempBuffer[j]-outReal[i];
            }
            outBegIdx.value = outBegIdx1.value ;
            outNBElement.value = outNbElement1.value ;
         }
      }
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
      }
      return retCode;
   }
   /* Generated */
   public int aroonLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod;
   }
   public RetCode aroon( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outAroonDown[],
      double outAroonUp[] )
   {
      double lowest, highest, tmp, factor;
      int outIdx;
      int trailingIdx, lowestIdx, highestIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( startIdx < optInTimePeriod )
         startIdx = optInTimePeriod;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-optInTimePeriod;
      lowestIdx = -1;
      highestIdx = -1;
      lowest = 0.0;
      highest = 0.0;
      factor = (double)100.0/(double)optInTimePeriod;
      while( today <= endIdx )
      {
         tmp = inLow[today];
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inLow[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmp = inLow[i];
               if( tmp <= lowest )
               {
                  lowestIdx = i;
                  lowest = tmp;
               }
            }
         }
         else if( tmp <= lowest )
         {
            lowestIdx = today;
            lowest = tmp;
         }
         tmp = inHigh[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inHigh[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmp = inHigh[i];
               if( tmp >= highest )
               {
                  highestIdx = i;
                  highest = tmp;
               }
            }
         }
         else if( tmp >= highest )
         {
            highestIdx = today;
            highest = tmp;
         }
         outAroonUp[outIdx] = factor*(optInTimePeriod-(today-highestIdx));
         outAroonDown[outIdx] = factor*(optInTimePeriod-(today-lowestIdx));
         outIdx++;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode aroonStateInit( struct TA_aroon_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct aroon ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = aroonLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_AROON_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode aroonState( struct TA_aroon_State* _state,
      double inHigh,
      double inLow,
      double *outAroonDown,
      double *outAroonUp )
   {
      unsigned int i;
      int j,p;
      double temp;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .lowest = inLow;
         _state.value .highest = inHigh;
         _state.value .lowest_exp = _state.value .optInTimePeriod;
         _state.value .highest_exp = _state.value .optInTimePeriod;
         _state.value .factor = (double)100.0/(double) _state.value .optInTimePeriod;
      }
      if (inLow <= _state.value .lowest)
      {
         _state.value .lowest = inLow;
         _state.value .lowest_exp = _state.value .optInTimePeriod;
      } else
         if (-- _state.value .lowest_exp <= 0)
      {
         _state.value .lowest = inLow;
         _state.value .lowest_exp = _state.value .optInTimePeriod;
         j = _state.value .mem_index-1;
         p = _state.value .optInTimePeriod;
         for (i = 0; i < _state.value .mem_size ; i++)
         {
            temp = ( _state.value .memory+(--j) % _state.value .mem_size ).value .inLow ;
            p--;
            if (temp < _state.value .lowest)
            {
               _state.value .lowest = temp;
               _state.value .lowest_exp = p;
            }
         }
      }
      if (inHigh >= _state.value .highest)
      {
         _state.value .highest = inHigh;
         _state.value .highest_exp = _state.value .optInTimePeriod;
      } else
         if (-- _state.value .highest_exp <= 0)
      {
         _state.value .highest = inHigh;
         _state.value .highest_exp = _state.value .optInTimePeriod;
         j = _state.value .mem_index-1;
         p = _state.value .optInTimePeriod;
         for ( i = 0; i < _state.value .mem_size ; i++)
         {
            temp = ( _state.value .memory+(--j) % _state.value .mem_size ).value .inHigh ;
            p--;
            if (temp > _state.value .highest)
            {
               _state.value .highest = temp;
               _state.value .highest_exp = p;
            }
         }
      }
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      outAroonUp.value = _state.value .factor* _state.value .highest_exp;
      outAroonDown.value = _state.value .factor* _state.value .lowest_exp;
      return RetCode.Success ;
   }
   public RetCode aroonStateFree( struct TA_aroon_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode aroonStateSave( struct TA_aroon_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_AROON_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .lowest,sizeof( _state.value .lowest),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .highest,sizeof( _state.value .highest),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .lowest_exp,sizeof( _state.value .lowest_exp),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .highest_exp,sizeof( _state.value .highest_exp),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .factor,sizeof( _state.value .factor),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode aroonStateLoad( struct TA_aroon_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct aroon ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_AROON_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_AROON_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .lowest,sizeof( _state.value .value .lowest),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .highest,sizeof( _state.value .value .highest),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .lowest_exp,sizeof( _state.value .value .lowest_exp),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .highest_exp,sizeof( _state.value .value .highest_exp),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .factor,sizeof( _state.value .value .factor),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode aroon( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outAroonDown[],
      double outAroonUp[] )
   {
      double lowest, highest, tmp, factor;
      int outIdx;
      int trailingIdx, lowestIdx, highestIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( startIdx < optInTimePeriod )
         startIdx = optInTimePeriod;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-optInTimePeriod;
      lowestIdx = -1;
      highestIdx = -1;
      lowest = 0.0;
      highest = 0.0;
      factor = (double)100.0/(double)optInTimePeriod;
      while( today <= endIdx )
      {
         tmp = inLow[today];
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inLow[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmp = inLow[i];
               if( tmp <= lowest )
               {
                  lowestIdx = i;
                  lowest = tmp;
               }
            }
         }
         else if( tmp <= lowest )
         {
            lowestIdx = today;
            lowest = tmp;
         }
         tmp = inHigh[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inHigh[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmp = inHigh[i];
               if( tmp >= highest )
               {
                  highestIdx = i;
                  highest = tmp;
               }
            }
         }
         else if( tmp >= highest )
         {
            highestIdx = today;
            highest = tmp;
         }
         outAroonUp[outIdx] = factor*(optInTimePeriod-(today-highestIdx));
         outAroonDown[outIdx] = factor*(optInTimePeriod-(today-lowestIdx));
         outIdx++;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int aroonOscLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod;
   }
   public RetCode aroonOsc( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double lowest, highest, tmp, factor, aroon;
      int outIdx;
      int trailingIdx, lowestIdx, highestIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( startIdx < optInTimePeriod )
         startIdx = optInTimePeriod;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-optInTimePeriod;
      lowestIdx = -1;
      highestIdx = -1;
      lowest = 0.0;
      highest = 0.0;
      factor = (double)100.0/(double)optInTimePeriod;
      while( today <= endIdx )
      {
         tmp = inLow[today];
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inLow[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmp = inLow[i];
               if( tmp <= lowest )
               {
                  lowestIdx = i;
                  lowest = tmp;
               }
            }
         }
         else if( tmp <= lowest )
         {
            lowestIdx = today;
            lowest = tmp;
         }
         tmp = inHigh[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inHigh[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmp = inHigh[i];
               if( tmp >= highest )
               {
                  highestIdx = i;
                  highest = tmp;
               }
            }
         }
         else if( tmp >= highest )
         {
            highestIdx = today;
            highest = tmp;
         }
         aroon = factor*(highestIdx-lowestIdx);
         outReal[outIdx] = aroon;
         outIdx++;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode aroonOscStateInit( struct TA_aroonOsc_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct aroonOsc ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = aroonOscLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_AROONOSC_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode aroonOscState( struct TA_aroonOsc_State* _state,
      double inHigh,
      double inLow,
      double *outReal )
   {
      unsigned int i;
      int j,p;
      double temp;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .lowest = inLow;
         _state.value .highest = inHigh;
         _state.value .lowest_exp = _state.value .optInTimePeriod;
         _state.value .highest_exp = _state.value .optInTimePeriod;
         _state.value .factor = (double)100.0/(double) _state.value .optInTimePeriod;
      }
      if (inLow <= _state.value .lowest)
      {
         _state.value .lowest = inLow;
         _state.value .lowest_exp = _state.value .optInTimePeriod;
      } else
         if ( _state.value .lowest_exp-- <= 0)
      {
         _state.value .lowest = inLow;
         _state.value .lowest_exp = _state.value .optInTimePeriod;
         j = _state.value .mem_index-1;
         p = _state.value .optInTimePeriod;
         for (i = 0; i < _state.value .mem_size ; i++)
         {
            temp = ( _state.value .memory+(--j) % _state.value .mem_size ).value .inLow ;
            p--;
            if (temp < _state.value .lowest)
            {
               _state.value .lowest = temp;
               _state.value .lowest_exp = p;
            }
         }
      }
      if (inHigh >= _state.value .highest)
      {
         _state.value .highest = inHigh;
         _state.value .highest_exp = _state.value .optInTimePeriod;
      } else
         if ( _state.value .highest_exp-- <= 0)
      {
         _state.value .highest = inHigh;
         _state.value .highest_exp = _state.value .optInTimePeriod;
         j = _state.value .mem_index-1;
         p = _state.value .optInTimePeriod;
         for ( i = 0; i < _state.value .mem_size ; i++)
         {
            temp = ( _state.value .memory+(--j) % _state.value .mem_size ).value .inHigh ;
            p--;
            if (temp > _state.value .highest)
            {
               _state.value .highest = temp;
               _state.value .highest_exp = p;
            }
         }
      }
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      outReal.value = _state.value .factor*( _state.value .highest_exp - _state.value .lowest_exp);
      return RetCode.Success ;
   }
   public RetCode aroonOscStateFree( struct TA_aroonOsc_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode aroonOscStateSave( struct TA_aroonOsc_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_AROONOSC_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .lowest,sizeof( _state.value .lowest),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .highest,sizeof( _state.value .highest),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .lowest_exp,sizeof( _state.value .lowest_exp),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .highest_exp,sizeof( _state.value .highest_exp),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .factor,sizeof( _state.value .factor),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode aroonOscStateLoad( struct TA_aroonOsc_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct aroonOsc ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_AROONOSC_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_AROONOSC_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .lowest,sizeof( _state.value .value .lowest),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .highest,sizeof( _state.value .value .highest),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .lowest_exp,sizeof( _state.value .value .lowest_exp),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .highest_exp,sizeof( _state.value .value .highest_exp),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .factor,sizeof( _state.value .value .factor),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode aroonOsc( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double lowest, highest, tmp, factor, aroon;
      int outIdx;
      int trailingIdx, lowestIdx, highestIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( startIdx < optInTimePeriod )
         startIdx = optInTimePeriod;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-optInTimePeriod;
      lowestIdx = -1;
      highestIdx = -1;
      lowest = 0.0;
      highest = 0.0;
      factor = (double)100.0/(double)optInTimePeriod;
      while( today <= endIdx )
      {
         tmp = inLow[today];
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inLow[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmp = inLow[i];
               if( tmp <= lowest )
               {
                  lowestIdx = i;
                  lowest = tmp;
               }
            }
         }
         else if( tmp <= lowest )
         {
            lowestIdx = today;
            lowest = tmp;
         }
         tmp = inHigh[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inHigh[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmp = inHigh[i];
               if( tmp >= highest )
               {
                  highestIdx = i;
                  highest = tmp;
               }
            }
         }
         else if( tmp >= highest )
         {
            highestIdx = today;
            highest = tmp;
         }
         aroon = factor*(highestIdx-lowestIdx);
         outReal[outIdx] = aroon;
         outIdx++;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int asinLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode asin( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.asin (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode asinStateInit( struct TA_asin_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct asin ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = asinLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_ASIN_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode asinState( struct TA_asin_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.asin (inReal);
      return RetCode.Success ;
   }
   public RetCode asinStateFree( struct TA_asin_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode asinStateSave( struct TA_asin_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_ASIN_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode asinStateLoad( struct TA_asin_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct asin ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_ASIN_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_ASIN_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode asin( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.asin (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int atanLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode atan( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.atan (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode atanStateInit( struct TA_atan_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct atan ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = atanLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_ATAN_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode atanState( struct TA_atan_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.atan (inReal);
      return RetCode.Success ;
   }
   public RetCode atanStateFree( struct TA_atan_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode atanStateSave( struct TA_atan_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_ATAN_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode atanStateLoad( struct TA_atan_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct atan ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_ATAN_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_ATAN_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode atan( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.atan (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int atrLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod + (this.unstablePeriod[FuncUnstId.Atr.ordinal()]) ;
   }
   public RetCode atr( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      RetCode retCode;
      int outIdx, today, lookbackTotal;
      int nbATR;
      MInteger outBegIdx1 = new MInteger() ;
      MInteger outNbElement1 = new MInteger() ;
      double prevATR;
      double []tempBuffer ;
      double []prevATRTemp = new double[1] ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      lookbackTotal = atrLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
         return RetCode.Success ;
      if( optInTimePeriod <= 1 )
      {
         return trueRange ( startIdx, endIdx,
            inHigh, inLow, inClose,
            outBegIdx, outNBElement, outReal );
      }
      tempBuffer = new double[lookbackTotal+(endIdx-startIdx)+1] ;
      retCode = trueRange ( (startIdx-lookbackTotal+1), endIdx,
         inHigh, inLow, inClose,
         outBegIdx1 , outNbElement1 ,
         tempBuffer );
      if( retCode != RetCode.Success )
      {
         return retCode;
      }
      retCode = TA_INT_SMA ( optInTimePeriod-1,
         optInTimePeriod-1,
         tempBuffer, optInTimePeriod,
         outBegIdx1 , outNbElement1 ,
         prevATRTemp );
      if( retCode != RetCode.Success )
      {
         return retCode;
      }
      prevATR = prevATRTemp[0];
      today = optInTimePeriod;
      outIdx = (this.unstablePeriod[FuncUnstId.Atr.ordinal()]) ;
      while( outIdx != 0 )
      {
         prevATR *= optInTimePeriod - 1;
         prevATR += tempBuffer[today++];
         prevATR /= optInTimePeriod;
         outIdx--;
      }
      outIdx = 1;
      outReal[0] = prevATR;
      nbATR = (endIdx - startIdx)+1;
      while( --nbATR != 0 )
      {
         prevATR *= optInTimePeriod - 1;
         prevATR += tempBuffer[today++];
         prevATR /= optInTimePeriod;
         outReal[outIdx++] = prevATR;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return retCode;
   }
   public RetCode atrStateInit( struct TA_atr_State** _state,
      int optInTimePeriod )
   {
      TA_RetCode retCode;
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct atr ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = atrLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_ATR_Data));
      else
         _state.value .value .memory = NULL;
      if( optInTimePeriod <= 1 )
      {
         return trueRange ( (struct trueRange **) & _state.value .value .StateTRANGE );
      }
      retCode = trueRange ( (struct trueRange **) & _state.value .value .StateTRANGE );
      if (retCode != RetCode.Success ) return retCode;
      return sma ( (struct sma **) & _state.value .value .StateSMA, optInTimePeriod );
   }
   public RetCode atrState( struct TA_atr_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      if( _state.value .optInTimePeriod <= 1 )
      {
         return trueRange ( (struct trueRange *) _state.value .StateTRANGE, inHigh, inLow, inClose, outReal );
      }
      TA_RetCode retCode;
      double tempReal, tempATR;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .firstATR = 1;
      }
      retCode = trueRange ( _state.value .StateTRANGE,inHigh, inLow, inClose, &tempReal );
      if( retCode != RetCode.Success ) return retCode;
      if ( _state.value .firstATR == 1)
      {
         retCode = sma ( _state.value .StateSMA, tempReal, &tempATR );
         if( retCode != RetCode.Success ) return retCode;
         _state.value .firstATR = 0;
         _state.value .prevATR = tempATR;
      } else {
         _state.value .prevATR *= _state.value .optInTimePeriod - 1;
         _state.value .prevATR += tempReal;
         _state.value .prevATR /= _state.value .optInTimePeriod;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      outReal.value = _state.value .prevATR;
      return RetCode.Success ;
   }
   public RetCode atrStateFree( struct TA_atr_State** _state )
   {
      if( _state.value .value .optInTimePeriod <= 1 )
      {
         return trueRange ( (struct trueRange **) & _state.value .value .StateTRANGE);
      }
      TA_RetCode retCode;
      retCode = trueRange ( (struct trueRange **) & _state.value .value .StateTRANGE );
      if (retCode != RetCode.Success ) return retCode;
      else retCode = sma ( (struct sma **) & _state.value .value .StateSMA );
      if (retCode != RetCode.Success ) return retCode;
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode atrStateSave( struct TA_atr_State* _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_ATR_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevATR,sizeof( _state.value .prevATR),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .firstATR,sizeof( _state.value .firstATR),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_TRANGE_StateSave ( (struct trueRange *) _state.value .StateTRANGE, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_SMA_StateSave ( (struct sma *) _state.value .StateSMA, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode atrStateLoad( struct TA_atr_State** _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct atr ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_ATR_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_ATR_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevATR,sizeof( _state.value .value .prevATR),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .firstATR,sizeof( _state.value .value .firstATR),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_TRANGE_StateLoad ( (struct trueRange **) & _state.value .value .StateTRANGE, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_SMA_StateLoad ( (struct sma **) & _state.value .value .StateSMA, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode atr( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      RetCode retCode;
      int outIdx, today, lookbackTotal;
      int nbATR;
      MInteger outBegIdx1 = new MInteger() ;
      MInteger outNbElement1 = new MInteger() ;
      double prevATR;
      double []tempBuffer ;
      double []prevATRTemp = new double[1] ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      lookbackTotal = atrLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
         return RetCode.Success ;
      if( optInTimePeriod <= 1 )
      {
         return trueRange ( startIdx, endIdx,
            inHigh, inLow, inClose,
            outBegIdx, outNBElement, outReal );
      }
      tempBuffer = new double[lookbackTotal+(endIdx-startIdx)+1] ;
      retCode = trueRange ( (startIdx-lookbackTotal+1), endIdx,
         inHigh, inLow, inClose,
         outBegIdx1 , outNbElement1 ,
         tempBuffer );
      if( retCode != RetCode.Success )
      {
         return retCode;
      }
      retCode = TA_INT_SMA ( optInTimePeriod-1,
         optInTimePeriod-1,
         tempBuffer, optInTimePeriod,
         outBegIdx1 , outNbElement1 ,
         prevATRTemp );
      if( retCode != RetCode.Success )
      {
         return retCode;
      }
      prevATR = prevATRTemp[0];
      today = optInTimePeriod;
      outIdx = (this.unstablePeriod[FuncUnstId.Atr.ordinal()]) ;
      while( outIdx != 0 )
      {
         prevATR *= optInTimePeriod - 1;
         prevATR += tempBuffer[today++];
         prevATR /= optInTimePeriod;
         outIdx--;
      }
      outIdx = 1;
      outReal[0] = prevATR;
      nbATR = (endIdx - startIdx)+1;
      while( --nbATR != 0 )
      {
         prevATR *= optInTimePeriod - 1;
         prevATR += tempBuffer[today++];
         prevATR /= optInTimePeriod;
         outReal[outIdx++] = prevATR;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return retCode;
   }
   /* Generated */
   public int avgPriceLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode avgPrice( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      outIdx = 0;
      for( i=startIdx; i <= endIdx; i++ )
      {
         outReal[outIdx++] = ( inHigh [i] +
            inLow [i] +
            inClose[i] +
            inOpen [i]) / 4;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode avgPriceStateInit( struct TA_avgPrice_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct avgPrice ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = avgPriceLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_AVGPRICE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode avgPriceState( struct TA_avgPrice_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      outReal.value = ( inHigh + inLow + inClose + inOpen) / 4;
      return RetCode.Success ;
   }
   public RetCode avgPriceStateFree( struct TA_avgPrice_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode avgPriceStateSave( struct TA_avgPrice_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_AVGPRICE_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode avgPriceStateLoad( struct TA_avgPrice_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct avgPrice ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_AVGPRICE_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_AVGPRICE_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode avgPrice( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      outIdx = 0;
      for( i=startIdx; i <= endIdx; i++ )
      {
         outReal[outIdx++] = ( inHigh [i] +
            inLow [i] +
            inClose[i] +
            inOpen [i]) / 4;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int avgDevLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod-1;
   }
   public RetCode avgDev( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, outIdx, lookback;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookback = optInTimePeriod - 1;
      if (startIdx < lookback) {
         startIdx = lookback;
      }
      today = startIdx;
      if( today > endIdx ) {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = today;
      outIdx = 0;
      while (today <= endIdx) {
         double todaySum, todayDev;
         int i;
         todaySum = 0.0;
         for (i = 0; i < optInTimePeriod; i++) {
            todaySum += inReal[today-i];
         }
         todayDev = 0.0;
         for (i = 0; i < optInTimePeriod; i++) {
            todayDev += Math.abs (inReal[today-i] - todaySum/optInTimePeriod);
         }
         outReal[outIdx] = todayDev/optInTimePeriod;
         outIdx++;
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode avgDevStateInit( struct TA_avgDev_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct avgDev ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = avgDevLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_AVGDEV_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode avgDevState( struct TA_avgDev_State* _state,
      double inReal,
      double *outReal )
   {
      size_t i;
      double temp;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
         _state.value .sum = 0;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
      {
         _state.value .sum += inReal;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      }
      _state.value .sum -= ( _state.value .memory+_cur_idx).value .inReal ;
      _state.value .sum += inReal;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      temp = 0.0;
      for (i = 0; i < _state.value .mem_size ; ++i) {
         temp += Math.abs ( ( _state.value .memory+i).value .inReal - _state.value .sum / _state.value .optInTimePeriod);
      }
      outReal.value = temp / _state.value .optInTimePeriod;
      return RetCode.Success ;
   }
   public RetCode avgDevStateFree( struct TA_avgDev_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode avgDevStateSave( struct TA_avgDev_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_AVGDEV_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .sum,sizeof( _state.value .sum),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode avgDevStateLoad( struct TA_avgDev_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct avgDev ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_AVGDEV_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_AVGDEV_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .sum,sizeof( _state.value .value .sum),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode avgDev( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, outIdx, lookback;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookback = optInTimePeriod - 1;
      if (startIdx < lookback) {
         startIdx = lookback;
      }
      today = startIdx;
      if( today > endIdx ) {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = today;
      outIdx = 0;
      while (today <= endIdx) {
         double todaySum, todayDev;
         int i;
         todaySum = 0.0;
         for (i = 0; i < optInTimePeriod; i++) {
            todaySum += inReal[today-i];
         }
         todayDev = 0.0;
         for (i = 0; i < optInTimePeriod; i++) {
            todayDev += Math.abs (inReal[today-i] - todaySum/optInTimePeriod);
         }
         outReal[outIdx] = todayDev/optInTimePeriod;
         outIdx++;
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int bbandsLookback( int optInTimePeriod,
      double optInNbDevUp,
      double optInNbDevDn,
      MAType optInMAType )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      if( optInNbDevUp == (-4e+37) )
         optInNbDevUp = 2.000000e+0;
      else if( (optInNbDevUp < -3.000000e+37) || (optInNbDevUp > 3.000000e+37) )
         return -1;
      if( optInNbDevDn == (-4e+37) )
         optInNbDevDn = 2.000000e+0;
      else if( (optInNbDevDn < -3.000000e+37) || (optInNbDevDn > 3.000000e+37) )
         return -1;
      return movingAverageLookback ( optInTimePeriod, optInMAType );
   }
   public RetCode bbands( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      double optInNbDevUp,
      double optInNbDevDn,
      MAType optInMAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outRealUpperBand[],
      double outRealMiddleBand[],
      double outRealLowerBand[] )
   {
      RetCode retCode;
      int i;
      double tempReal, tempReal2;
      double []tempBuffer1 ;
      double []tempBuffer2 ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInNbDevUp == (-4e+37) )
         optInNbDevUp = 2.000000e+0;
      else if( (optInNbDevUp < -3.000000e+37) || (optInNbDevUp > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInNbDevDn == (-4e+37) )
         optInNbDevDn = 2.000000e+0;
      else if( (optInNbDevDn < -3.000000e+37) || (optInNbDevDn > 3.000000e+37) )
         return RetCode.BadParam ;
      if( inReal == outRealUpperBand )
      {
         tempBuffer1 = outRealMiddleBand;
         tempBuffer2 = outRealLowerBand;
      }
      else if( inReal == outRealLowerBand )
      {
         tempBuffer1 = outRealMiddleBand;
         tempBuffer2 = outRealUpperBand;
      }
      else if( inReal == outRealMiddleBand )
      {
         tempBuffer1 = outRealLowerBand;
         tempBuffer2 = outRealUpperBand;
      }
      else
      {
         tempBuffer1 = outRealMiddleBand;
         tempBuffer2 = outRealUpperBand;
      }
      if( (tempBuffer1 == inReal) || (tempBuffer2 == inReal) )
         return RetCode.BadParam ;
      retCode = movingAverage ( startIdx, endIdx, inReal,
         optInTimePeriod, optInMAType,
         outBegIdx, outNBElement, tempBuffer1 );
      if( (retCode != RetCode.Success ) || ((int) outNBElement.value == 0) )
      {
         outNBElement.value = 0 ;
         return retCode;
      }
      if( optInMAType == MAType.Sma )
      {
         TA_INT_stddev_using_precalc_ma ( inReal, tempBuffer1,
            (int) outBegIdx.value , (int) outNBElement.value ,
            optInTimePeriod, tempBuffer2 );
      }
      else
      {
         retCode = stdDev ( (int) outBegIdx.value , endIdx, inReal,
            optInTimePeriod, 1.0,
            outBegIdx, outNBElement, tempBuffer2 );
         if( retCode != RetCode.Success )
         {
            outNBElement.value = 0 ;
            return retCode;
         }
      }
      if( tempBuffer1 != outRealMiddleBand )
      {
         System.arraycopy(tempBuffer1,0,outRealMiddleBand,0,outNBElement.value ) ;
      }
      if( optInNbDevUp == optInNbDevDn )
      {
         if( optInNbDevUp == 1.0 )
         {
            for( i=0; i < (int) outNBElement.value ; i++ )
            {
               tempReal = tempBuffer2[i];
               tempReal2 = outRealMiddleBand[i];
               outRealUpperBand[i] = tempReal2 + tempReal;
               outRealLowerBand[i] = tempReal2 - tempReal;
            }
         }
         else
         {
            for( i=0; i < (int) outNBElement.value ; i++ )
            {
               tempReal = tempBuffer2[i] * optInNbDevUp;
               tempReal2 = outRealMiddleBand[i];
               outRealUpperBand[i] = tempReal2 + tempReal;
               outRealLowerBand[i] = tempReal2 - tempReal;
            }
         }
      }
      else if( optInNbDevUp == 1.0 )
      {
         for( i=0; i < (int) outNBElement.value ; i++ )
         {
            tempReal = tempBuffer2[i];
            tempReal2 = outRealMiddleBand[i];
            outRealUpperBand[i] = tempReal2 + tempReal;
            outRealLowerBand[i] = tempReal2 - (tempReal * optInNbDevDn);
         }
      }
      else if( optInNbDevDn == 1.0 )
      {
         for( i=0; i < (int) outNBElement.value ; i++ )
         {
            tempReal = tempBuffer2[i];
            tempReal2 = outRealMiddleBand[i];
            outRealLowerBand[i] = tempReal2 - tempReal;
            outRealUpperBand[i] = tempReal2 + (tempReal * optInNbDevUp);
         }
      }
      else
      {
         for( i=0; i < (int) outNBElement.value ; i++ )
         {
            tempReal = tempBuffer2[i];
            tempReal2 = outRealMiddleBand[i];
            outRealUpperBand[i] = tempReal2 + (tempReal * optInNbDevUp);
            outRealLowerBand[i] = tempReal2 - (tempReal * optInNbDevDn);
         }
      }
      return RetCode.Success ;
   }
   public RetCode bbandsStateInit( struct TA_bbands_State** _state,
      int optInTimePeriod,
      double optInNbDevUp,
      double optInNbDevDn,
      MAType optInMAType )
   {
      RetCode retCode;
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInNbDevUp == (-4e+37) )
         optInNbDevUp = 2.000000e+0;
      else if( (optInNbDevUp < -3.000000e+37) || (optInNbDevUp > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInNbDevDn == (-4e+37) )
         optInNbDevDn = 2.000000e+0;
      else if( (optInNbDevDn < -3.000000e+37) || (optInNbDevDn > 3.000000e+37) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct bbands ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .optInNbDevUp = optInNbDevUp;
      _state.value .value .optInNbDevDn = optInNbDevDn;
      _state.value .value .optInMAType = optInMAType;
      _state.value .value .mem_size = bbandsLookback (optInTimePeriod, optInNbDevUp, optInNbDevDn, optInMAType );
      _state.value .value .memory = NULL;
      retCode = movingAverage ( (struct movingAverage **) & _state.value .value .stateMA, optInTimePeriod, optInMAType );
      if (retCode != RetCode.Success ) return retCode;
      retCode = stdDev ( (struct stdDev **) & _state.value .value .stateSTDDEV, optInTimePeriod, 1.0 );
      if (retCode != RetCode.Success ) return retCode;
      return RetCode.Success ;
   }
   public RetCode bbandsState( struct TA_bbands_State* _state,
      double inReal,
      double *outRealUpperBand,
      double *outRealMiddleBand,
      double *outRealLowerBand )
   {
      RetCode retCode;
      double tempReal, tempReal2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      retCode = movingAverage ( (struct movingAverage *) _state.value .stateMA, inReal, &tempReal2 );
      if (retCode != RetCode.Success && retCode != RetCode.NeedMoreData ) return retCode;
      retCode = stdDev ( (struct stdDev *) _state.value .stateSTDDEV, inReal, &tempReal );
      if (retCode != RetCode.Success ) return retCode;
      outRealMiddleBand.value = tempReal2;
      if( _state.value .optInNbDevUp == _state.value .optInNbDevDn )
      {
         if( _state.value .optInNbDevUp == 1.0 )
         {
            outRealUpperBand.value = tempReal2 + tempReal;
            outRealLowerBand.value = tempReal2 - tempReal;
         } else {
            tempReal *= _state.value .optInNbDevUp;
            outRealUpperBand.value = tempReal2 + tempReal;
            outRealLowerBand.value = tempReal2 - tempReal;
         }
      }
      else if( _state.value .optInNbDevUp == 1.0 )
      {
         outRealUpperBand.value = tempReal2 + tempReal;
         outRealLowerBand.value = tempReal2 - (tempReal * _state.value .optInNbDevDn);
      }
      else if( _state.value .optInNbDevDn == 1.0 )
      {
         outRealLowerBand.value = tempReal2 - tempReal;
         outRealUpperBand.value = tempReal2 + (tempReal * _state.value .optInNbDevUp);
      }
      else
      {
         outRealUpperBand.value = tempReal2 + (tempReal * _state.value .optInNbDevUp);
         outRealLowerBand.value = tempReal2 - (tempReal * _state.value .optInNbDevDn);
      }
      return RetCode.Success ;
   }
   public RetCode bbandsStateFree( struct TA_bbands_State** _state )
   {
      TA_RetCode retCode;
      retCode = movingAverage ( (struct movingAverage **) & _state.value .value .stateMA );
      if (retCode != RetCode.Success ) return retCode;
      retCode = stdDev ( (struct stdDev **) & _state.value .value .stateSTDDEV );
      if (retCode != RetCode.Success ) return retCode;
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode bbandsStateSave( struct TA_bbands_State* _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_BBANDS_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInNbDevUp,sizeof( _state.value .optInNbDevUp),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInNbDevDn,sizeof( _state.value .optInNbDevDn),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInMAType,sizeof( _state.value .optInMAType),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_MA_StateSave ( (struct movingAverage *) _state.value .stateMA, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_STDDEV_StateSave ( (struct stdDev *) _state.value .stateSTDDEV, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode bbandsStateLoad( struct TA_bbands_State** _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct bbands ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_BBANDS_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_BBANDS_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInNbDevUp,sizeof( _state.value .value .optInNbDevUp),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInNbDevDn,sizeof( _state.value .value .optInNbDevDn),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInMAType,sizeof( _state.value .value .optInMAType),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_MA_StateLoad ( (struct movingAverage **) & _state.value .value .stateMA, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_STDDEV_StateLoad ( (struct stdDev **) & _state.value .value .stateSTDDEV, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode bbands( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      double optInNbDevUp,
      double optInNbDevDn,
      MAType optInMAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outRealUpperBand[],
      double outRealMiddleBand[],
      double outRealLowerBand[] )
   {
      RetCode retCode;
      int i;
      double tempReal, tempReal2;
      double []tempBuffer1 ;
      double []tempBuffer2 ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInNbDevUp == (-4e+37) )
         optInNbDevUp = 2.000000e+0;
      else if( (optInNbDevUp < -3.000000e+37) || (optInNbDevUp > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInNbDevDn == (-4e+37) )
         optInNbDevDn = 2.000000e+0;
      else if( (optInNbDevDn < -3.000000e+37) || (optInNbDevDn > 3.000000e+37) )
         return RetCode.BadParam ;
      tempBuffer1 = outRealMiddleBand;
      tempBuffer2 = outRealLowerBand;
      retCode = movingAverage ( startIdx, endIdx, inReal,
         optInTimePeriod, optInMAType,
         outBegIdx, outNBElement, tempBuffer1 );
      if( (retCode != RetCode.Success ) || ((int) outNBElement.value == 0) )
      {
         outNBElement.value = 0 ;
         return retCode;
      }
      if( optInMAType == MAType.Sma )
      {
         TA_INT_stddev_using_precalc_ma ( inReal, tempBuffer1,
            (int) outBegIdx.value , (int) outNBElement.value ,
            optInTimePeriod, tempBuffer2 );
      }
      else
      {
         retCode = stdDev ( (int) outBegIdx.value , endIdx, inReal,
            optInTimePeriod, 1.0,
            outBegIdx, outNBElement, tempBuffer2 );
         if( retCode != RetCode.Success )
         {
            outNBElement.value = 0 ;
            return retCode;
         }
      }
      if( optInNbDevUp == optInNbDevDn )
      {
         if( optInNbDevUp == 1.0 )
         {
            for( i=0; i < (int) outNBElement.value ; i++ )
            {
               tempReal = tempBuffer2[i];
               tempReal2 = outRealMiddleBand[i];
               outRealUpperBand[i] = tempReal2 + tempReal;
               outRealLowerBand[i] = tempReal2 - tempReal;
            }
         }
         else
         {
            for( i=0; i < (int) outNBElement.value ; i++ )
            {
               tempReal = tempBuffer2[i] * optInNbDevUp;
               tempReal2 = outRealMiddleBand[i];
               outRealUpperBand[i] = tempReal2 + tempReal;
               outRealLowerBand[i] = tempReal2 - tempReal;
            }
         }
      }
      else if( optInNbDevUp == 1.0 )
      {
         for( i=0; i < (int) outNBElement.value ; i++ )
         {
            tempReal = tempBuffer2[i];
            tempReal2 = outRealMiddleBand[i];
            outRealUpperBand[i] = tempReal2 + tempReal;
            outRealLowerBand[i] = tempReal2 - (tempReal * optInNbDevDn);
         }
      }
      else if( optInNbDevDn == 1.0 )
      {
         for( i=0; i < (int) outNBElement.value ; i++ )
         {
            tempReal = tempBuffer2[i];
            tempReal2 = outRealMiddleBand[i];
            outRealLowerBand[i] = tempReal2 - tempReal;
            outRealUpperBand[i] = tempReal2 + (tempReal * optInNbDevUp);
         }
      }
      else
      {
         for( i=0; i < (int) outNBElement.value ; i++ )
         {
            tempReal = tempBuffer2[i];
            tempReal2 = outRealMiddleBand[i];
            outRealUpperBand[i] = tempReal2 + (tempReal * optInNbDevUp);
            outRealLowerBand[i] = tempReal2 - (tempReal * optInNbDevDn);
         }
      }
      return RetCode.Success ;
   }
   /* Generated */
   public int betaLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod;
   }
   public RetCode beta( int startIdx,
      int endIdx,
      double inReal0[],
      double inReal1[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double S_xx = 0.0f;
      double S_xy = 0.0f;
      double S_x = 0.0f;
      double S_y = 0.0f;
      double last_price_x = 0.0f;
      double last_price_y = 0.0f;
      double trailing_last_price_x = 0.0f;
      double trailing_last_price_y = 0.0f;
      double tmp_real = 0.0f;
      double x;
      double y;
      double n = 0.0f;
      int i, outIdx;
      int trailingIdx, nbInitialElementNeeded;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = optInTimePeriod;
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      trailingIdx = startIdx-nbInitialElementNeeded;
      last_price_x = trailing_last_price_x = inReal0[trailingIdx];
      last_price_y = trailing_last_price_y = inReal1[trailingIdx];
      i = ++trailingIdx;
      while( i < startIdx )
      {
         tmp_real = inReal0[i];
         if( ! (((- (0.00000000000001) )<last_price_x)&&(last_price_x< (0.00000000000001) )) )
            x = (tmp_real-last_price_x)/last_price_x;
         else
            x = 0.0;
         last_price_x = tmp_real;
         tmp_real = inReal1[i++];
         if( ! (((- (0.00000000000001) )<last_price_y)&&(last_price_y< (0.00000000000001) )) )
            y = (tmp_real-last_price_y)/last_price_y;
         else
            y = 0.0;
         last_price_y = tmp_real;
         S_xx += x*x;
         S_xy += x*y;
         S_x += x;
         S_y += y;
      }
      outIdx = 0;
      n = (double)optInTimePeriod;
      do
      {
         tmp_real = inReal0[i];
         if( ! (((- (0.00000000000001) )<last_price_x)&&(last_price_x< (0.00000000000001) )) )
            x = (tmp_real-last_price_x)/last_price_x;
         else
            x = 0.0;
         last_price_x = tmp_real;
         tmp_real = inReal1[i++];
         if( ! (((- (0.00000000000001) )<last_price_y)&&(last_price_y< (0.00000000000001) )) )
            y = (tmp_real-last_price_y)/last_price_y;
         else
            y = 0.0;
         last_price_y = tmp_real;
         S_xx += x*x;
         S_xy += x*y;
         S_x += x;
         S_y += y;
         tmp_real = inReal0[trailingIdx];
         if( ! (((- (0.00000000000001) )<trailing_last_price_x)&&(trailing_last_price_x< (0.00000000000001) )) )
            x = (tmp_real-trailing_last_price_x)/trailing_last_price_x;
         else
            x = 0.0;
         trailing_last_price_x = tmp_real;
         tmp_real = inReal1[trailingIdx++];
         if( ! (((- (0.00000000000001) )<trailing_last_price_y)&&(trailing_last_price_y< (0.00000000000001) )) )
            y = (tmp_real-trailing_last_price_y)/trailing_last_price_y;
         else
            y = 0.0;
         trailing_last_price_y = tmp_real;
         tmp_real = (n * S_xx) - (S_x * S_x);
         if( ! (((- (0.00000000000001) )<tmp_real)&&(tmp_real< (0.00000000000001) )) )
            outReal[outIdx++] = ((n * S_xy) - (S_x * S_y)) / tmp_real;
         else
            outReal[outIdx++] = 0.0;
         S_xx -= x*x;
         S_xy -= x*y;
         S_x -= x;
         S_y -= y;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode betaStateInit( struct TA_beta_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct beta ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = betaLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      _state.value .value .initialized = 0;
      _state.value .value .mem_size --;
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_BETA_Data));
      return RetCode.Success ;
   }
   public RetCode betaState( struct TA_beta_State* _state,
      double inReal0,
      double inReal1,
      double *outReal )
   {
      double x,y,temp;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if (! _state.value .initialized)
      {
         _state.value .S_xx = 0;
         _state.value .S_xy = 0;
         _state.value .S_x = 0;
         _state.value .last_price_x = inReal0;
         _state.value .last_price_y = inReal1;
         _state.value .prev_price_x = inReal0;
         _state.value .prev_price_y = inReal1;
         _state.value .initialized = 1;
         _state.value .mem_index--;
         return RetCode.NeedMoreData ;
      }
      if( ! (((- (0.00000000000001) )< _state.value .prev_price_x)&&( _state.value .prev_price_x< (0.00000000000001) )) )
         x = (inReal0- _state.value .prev_price_x)/ _state.value .prev_price_x;
      else
         x = 0.0;
      _state.value .prev_price_x = inReal0;
      if( ! (((- (0.00000000000001) )< _state.value .prev_price_y)&&( _state.value .prev_price_y< (0.00000000000001) )) )
         y = (inReal1- _state.value .prev_price_y)/ _state.value .prev_price_y;
      else
         y = 0.0;
      _state.value .prev_price_y = inReal1;
      _state.value .S_xx += x*x;
      _state.value .S_xy += x*y;
      _state.value .S_x += x;
      _state.value .S_y += y;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
      {
         ( _state.value .memory+_cur_idx).value .inReal0 = inReal0 ;
         ( _state.value .memory+_cur_idx).value .inReal1 = inReal1 ;
         return RetCode.NeedMoreData ;
      }
      temp = ( _state.value .memory+_cur_idx).value .inReal0 ;
      if( ! (((- (0.00000000000001) )< _state.value .last_price_x)&&( _state.value .last_price_x< (0.00000000000001) )) )
         x = (temp- _state.value .last_price_x)/ _state.value .last_price_x;
      else
         x = 0.0;
      _state.value .last_price_x = temp;
      temp = ( _state.value .memory+_cur_idx).value .inReal1 ;
      if( ! (((- (0.00000000000001) )< _state.value .last_price_y)&&( _state.value .last_price_y< (0.00000000000001) )) )
         y = (temp- _state.value .last_price_y)/ _state.value .last_price_y;
      else
         y = 0.0;
      _state.value .last_price_y = temp;
      temp = ((double) _state.value .optInTimePeriod * _state.value .S_xx) - ( _state.value .S_x * _state.value .S_x);
      if( ! (((- (0.00000000000001) )<temp)&&(temp< (0.00000000000001) )) )
         outReal.value = (((double) _state.value .optInTimePeriod * _state.value .S_xy) - ( _state.value .S_x * _state.value .S_y)) / temp;
      else
         outReal.value = 0.0;
      _state.value .S_xx -= x*x;
      _state.value .S_xy -= x*y;
      _state.value .S_x -= x;
      _state.value .S_y -= y;
      ( _state.value .memory+_cur_idx).value .inReal0 = inReal0 ;
      ( _state.value .memory+_cur_idx).value .inReal1 = inReal1 ;
      return RetCode.Success ;
   }
   public RetCode betaStateFree( struct TA_beta_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode betaStateSave( struct TA_beta_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_BETA_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .S_xx,sizeof( _state.value .S_xx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .S_xy,sizeof( _state.value .S_xy),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .S_x,sizeof( _state.value .S_x),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .S_y,sizeof( _state.value .S_y),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prev_price_x,sizeof( _state.value .prev_price_x),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prev_price_y,sizeof( _state.value .prev_price_y),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .last_price_x,sizeof( _state.value .last_price_x),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .last_price_y,sizeof( _state.value .last_price_y),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .initialized,sizeof( _state.value .initialized),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode betaStateLoad( struct TA_beta_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct beta ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_BETA_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_BETA_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .S_xx,sizeof( _state.value .value .S_xx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .S_xy,sizeof( _state.value .value .S_xy),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .S_x,sizeof( _state.value .value .S_x),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .S_y,sizeof( _state.value .value .S_y),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prev_price_x,sizeof( _state.value .value .prev_price_x),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prev_price_y,sizeof( _state.value .value .prev_price_y),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .last_price_x,sizeof( _state.value .value .last_price_x),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .last_price_y,sizeof( _state.value .value .last_price_y),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .initialized,sizeof( _state.value .value .initialized),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode beta( int startIdx,
      int endIdx,
      float inReal0[],
      float inReal1[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double S_xx = 0.0f;
      double S_xy = 0.0f;
      double S_x = 0.0f;
      double S_y = 0.0f;
      double last_price_x = 0.0f;
      double last_price_y = 0.0f;
      double trailing_last_price_x = 0.0f;
      double trailing_last_price_y = 0.0f;
      double tmp_real = 0.0f;
      double x;
      double y;
      double n = 0.0f;
      int i, outIdx;
      int trailingIdx, nbInitialElementNeeded;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = optInTimePeriod;
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      trailingIdx = startIdx-nbInitialElementNeeded;
      last_price_x = trailing_last_price_x = inReal0[trailingIdx];
      last_price_y = trailing_last_price_y = inReal1[trailingIdx];
      i = ++trailingIdx;
      while( i < startIdx )
      {
         tmp_real = inReal0[i];
         if( ! (((- (0.00000000000001) )<last_price_x)&&(last_price_x< (0.00000000000001) )) )
            x = (tmp_real-last_price_x)/last_price_x;
         else
            x = 0.0;
         last_price_x = tmp_real;
         tmp_real = inReal1[i++];
         if( ! (((- (0.00000000000001) )<last_price_y)&&(last_price_y< (0.00000000000001) )) )
            y = (tmp_real-last_price_y)/last_price_y;
         else
            y = 0.0;
         last_price_y = tmp_real;
         S_xx += x*x;
         S_xy += x*y;
         S_x += x;
         S_y += y;
      }
      outIdx = 0;
      n = (double)optInTimePeriod;
      do
      {
         tmp_real = inReal0[i];
         if( ! (((- (0.00000000000001) )<last_price_x)&&(last_price_x< (0.00000000000001) )) )
            x = (tmp_real-last_price_x)/last_price_x;
         else
            x = 0.0;
         last_price_x = tmp_real;
         tmp_real = inReal1[i++];
         if( ! (((- (0.00000000000001) )<last_price_y)&&(last_price_y< (0.00000000000001) )) )
            y = (tmp_real-last_price_y)/last_price_y;
         else
            y = 0.0;
         last_price_y = tmp_real;
         S_xx += x*x;
         S_xy += x*y;
         S_x += x;
         S_y += y;
         tmp_real = inReal0[trailingIdx];
         if( ! (((- (0.00000000000001) )<trailing_last_price_x)&&(trailing_last_price_x< (0.00000000000001) )) )
            x = (tmp_real-trailing_last_price_x)/trailing_last_price_x;
         else
            x = 0.0;
         trailing_last_price_x = tmp_real;
         tmp_real = inReal1[trailingIdx++];
         if( ! (((- (0.00000000000001) )<trailing_last_price_y)&&(trailing_last_price_y< (0.00000000000001) )) )
            y = (tmp_real-trailing_last_price_y)/trailing_last_price_y;
         else
            y = 0.0;
         trailing_last_price_y = tmp_real;
         tmp_real = (n * S_xx) - (S_x * S_x);
         if( ! (((- (0.00000000000001) )<tmp_real)&&(tmp_real< (0.00000000000001) )) )
            outReal[outIdx++] = ((n * S_xy) - (S_x * S_y)) / tmp_real;
         else
            outReal[outIdx++] = 0.0;
         S_xx -= x*x;
         S_xy -= x*y;
         S_x -= x;
         S_y -= y;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int bopLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode bop( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      outIdx = 0;
      for( i=startIdx; i <= endIdx; i++ )
      {
         tempReal = inHigh[i]-inLow[i];
         if( (tempReal< (0.00000000000001) ) )
            outReal[outIdx++] = 0.0;
         else
            outReal[outIdx++] = (inClose[i] - inOpen[i])/tempReal;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode bopStateInit( struct TA_bop_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct bop ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = bopLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_BOP_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode bopState( struct TA_bop_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      double tempReal;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      tempReal = inHigh-inLow;
      if( (tempReal< (0.00000000000001) ) )
         outReal.value = 0.0;
      else
         outReal.value = (inClose - inOpen)/tempReal;
      return RetCode.Success ;
   }
   public RetCode bopStateFree( struct TA_bop_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode bopStateSave( struct TA_bop_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_BOP_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode bopStateLoad( struct TA_bop_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct bop ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_BOP_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_BOP_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode bop( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      outIdx = 0;
      for( i=startIdx; i <= endIdx; i++ )
      {
         tempReal = inHigh[i]-inLow[i];
         if( (tempReal< (0.00000000000001) ) )
            outReal[outIdx++] = 0.0;
         else
            outReal[outIdx++] = (inClose[i] - inOpen[i])/tempReal;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cciLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return (optInTimePeriod-1);
   }
   public RetCode cci( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double tempReal, tempReal2, theAverage, lastValue;
      int i, j, outIdx, lookbackTotal;
      int circBuffer_Idx = 0; double []circBuffer; int maxIdx_circBuffer = (30-1) ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = (optInTimePeriod-1);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      { if( optInTimePeriod <= 0 ) return RetCode.AllocErr ; circBuffer = new double[optInTimePeriod]; maxIdx_circBuffer = (optInTimePeriod-1); } ;
      i=startIdx-lookbackTotal;
      if( optInTimePeriod > 1 )
      {
         while( i < startIdx )
         {
            circBuffer[circBuffer_Idx] = (inHigh[i]+inLow[i]+inClose[i])/3;
            i++;
            { circBuffer_Idx ++; if( circBuffer_Idx > maxIdx_circBuffer ) circBuffer_Idx = 0; } ;
         }
      }
      outIdx = 0;
      do
      {
         lastValue = (inHigh[i]+inLow[i]+inClose[i])/3;
         circBuffer[circBuffer_Idx] = lastValue;
         theAverage = 0;
         for( j=0; j < optInTimePeriod; j++ )
            theAverage += circBuffer[j];
         theAverage /= optInTimePeriod;
         tempReal2 = 0;
         for( j=0; j < optInTimePeriod; j++ )
            tempReal2 += Math.abs (circBuffer[j]-theAverage);
         tempReal = lastValue-theAverage;
         if( (tempReal != 0.0) && (tempReal2 != 0.0) )
         {
            outReal[outIdx++] = tempReal/(0.015*(tempReal2/optInTimePeriod));
         }
         else
            outReal[outIdx++] = 0.0;
         { circBuffer_Idx ++; if( circBuffer_Idx > maxIdx_circBuffer ) circBuffer_Idx = 0; } ;
         i++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   struct TA_CCI_STATE_CIRCBUF { int idx; double* circbuf; int size; };
   public RetCode cciStateInit( struct TA_cci_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cci ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = cciLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      { _state.value .value .circBuf = calloc(1, sizeof(struct TA_CCI_STATE_CIRCBUF )); if ( _state.value .value .circBuf == NULL) return RetCode.AllocErr ; struct TA_CCI_STATE_CIRCBUF * buf = (struct TA_CCI_STATE_CIRCBUF *) _state.value .value .circBuf; buf->idx = 0; buf->size = optInTimePeriod-1; buf->circbuf = calloc(optInTimePeriod-1, sizeof(double)); if (!buf->circbuf) return RetCode.AllocErr ;} ;
      _state.value .value .theAverage = 0.;
      return RetCode.Success ;
   }
   public RetCode cciState( struct TA_cci_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      int i;
      double lastValue, sum, avg;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      lastValue = (inHigh+inLow+inClose) / 3.0;
      _state.value .theAverage += lastValue;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
      {
         (*( ((struct TA_CCI_STATE_CIRCBUF *) _state.value .circBuf)->circbuf + ((struct TA_CCI_STATE_CIRCBUF *) _state.value .circBuf)->idx )) = lastValue;
         { struct TA_CCI_STATE_CIRCBUF * buf = (struct TA_CCI_STATE_CIRCBUF *) _state.value .circBuf; if(buf->idx < buf->size-1) buf->idx++; else buf->idx = 0;} ;
         return RetCode.NeedMoreData ;
      }
      sum = 0;
      avg = _state.value .theAverage / _state.value .optInTimePeriod;
      _state.value .theAverage -= (*( ((struct TA_CCI_STATE_CIRCBUF *) _state.value .circBuf)->circbuf + ((struct TA_CCI_STATE_CIRCBUF *) _state.value .circBuf)->idx )) ;
      for( i=0; i < ((struct TA_CCI_STATE_CIRCBUF *) _state.value .circBuf)->size ; i++ )
         sum += Math.abs ( (*( ((struct TA_CCI_STATE_CIRCBUF *) _state.value .circBuf)->circbuf +i)) - avg);
      sum += Math.abs (lastValue - avg);
      (*( ((struct TA_CCI_STATE_CIRCBUF *) _state.value .circBuf)->circbuf + ((struct TA_CCI_STATE_CIRCBUF *) _state.value .circBuf)->idx )) = lastValue;
      lastValue -= avg;
      if( ( Math.abs (lastValue) > 1e-13) && ( Math.abs (sum) > 1e-13) )
      {
         outReal.value = lastValue/(0.015*(sum/ _state.value .optInTimePeriod));
      }
      else
         outReal.value = 0.0;
      { struct TA_CCI_STATE_CIRCBUF * buf = (struct TA_CCI_STATE_CIRCBUF *) _state.value .circBuf; if(buf->idx < buf->size-1) buf->idx++; else buf->idx = 0;} ;
      return RetCode.Success ;
   }
   public RetCode cciStateFree( struct TA_cci_State** _state )
   {
      { struct TA_CCI_STATE_CIRCBUF * buf = (struct TA_CCI_STATE_CIRCBUF *) _state.value .value .circBuf; if (buf != NULL) { if (buf->circbuf != NULL) free(buf->circbuf); free (buf); _state.value .value .circBuf = NULL; } } ;
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cciStateSave( struct TA_cci_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CCI_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .theAverage,sizeof( _state.value .theAverage),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      { int io_circbuf_res; struct TA_CCI_STATE_CIRCBUF * str_circbuf = _state.value .circBuf; io_circbuf_res = fwrite(&str_circbuf->idx,sizeof(str_circbuf->idx),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; io_circbuf_res = fwrite(&str_circbuf->size,sizeof(str_circbuf->size),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; if (str_circbuf->size > 0) { io_circbuf_res = fwrite(str_circbuf->circbuf,sizeof(str_circbuf->circbuf),str_circbuf->size,_file); if (io_circbuf_res < str_circbuf->size) return RetCode.IOFailed ; } }
      return 0;
   }
   public RetCode cciStateLoad( struct TA_cci_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cci ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CCI_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CCI_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .theAverage,sizeof( _state.value .value .theAverage),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      { int io_circbuf_res; int circbuf_idx; int circbuf_size; if ( _state.value .value .circBuf != NULL) return RetCode.BadParam ; io_circbuf_res = fread(&circbuf_idx,sizeof(circbuf_idx),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; io_circbuf_res = fread(&circbuf_size,sizeof(circbuf_size),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; { _state.value .value .circBuf = calloc(1, sizeof(struct TA_CCI_STATE_CIRCBUF )); if ( _state.value .value .circBuf == NULL) return RetCode.AllocErr ; struct TA_CCI_STATE_CIRCBUF * buf = (struct TA_CCI_STATE_CIRCBUF *) _state.value .value .circBuf; buf->idx = 0; buf->size = circbuf_size; buf->circbuf = calloc(circbuf_size, sizeof(double)); if (!buf->circbuf) return RetCode.AllocErr ;} struct TA_CCI_STATE_CIRCBUF * str_circbuf = _state.value .value .circBuf; str_circbuf->idx = circbuf_idx; if (str_circbuf->size > 0) { io_circbuf_res = fread(str_circbuf->circbuf,sizeof(str_circbuf->circbuf),str_circbuf->size,_file); if (io_circbuf_res < str_circbuf->size) return RetCode.IOFailed ; } }
      return 0;
   }
   public RetCode cci( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double tempReal, tempReal2, theAverage, lastValue;
      int i, j, outIdx, lookbackTotal;
      int circBuffer_Idx = 0; double []circBuffer; int maxIdx_circBuffer = (30-1) ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = (optInTimePeriod-1);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      { if( optInTimePeriod <= 0 ) return RetCode.AllocErr ; circBuffer = new double[optInTimePeriod]; maxIdx_circBuffer = (optInTimePeriod-1); } ;
      i=startIdx-lookbackTotal;
      if( optInTimePeriod > 1 )
      {
         while( i < startIdx )
         {
            circBuffer[circBuffer_Idx] = (inHigh[i]+inLow[i]+inClose[i])/3;
            i++;
            { circBuffer_Idx ++; if( circBuffer_Idx > maxIdx_circBuffer ) circBuffer_Idx = 0; } ;
         }
      }
      outIdx = 0;
      do
      {
         lastValue = (inHigh[i]+inLow[i]+inClose[i])/3;
         circBuffer[circBuffer_Idx] = lastValue;
         theAverage = 0;
         for( j=0; j < optInTimePeriod; j++ )
            theAverage += circBuffer[j];
         theAverage /= optInTimePeriod;
         tempReal2 = 0;
         for( j=0; j < optInTimePeriod; j++ )
            tempReal2 += Math.abs (circBuffer[j]-theAverage);
         tempReal = lastValue-theAverage;
         if( (tempReal != 0.0) && (tempReal2 != 0.0) )
         {
            outReal[outIdx++] = tempReal/(0.015*(tempReal2/optInTimePeriod));
         }
         else
            outReal[outIdx++] = 0.0;
         { circBuffer_Idx ++; if( circBuffer_Idx > maxIdx_circBuffer ) circBuffer_Idx = 0; } ;
         i++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdl2CrowsLookback( )
   {
      return (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) + 2;
   }
   public RetCode cdl2Crows( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyLongPeriodTotal;
      int i, outIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdl2CrowsLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inOpen[i] < inOpen[i-1] && inOpen[i] > inClose[i-1] &&
            inClose[i] > inOpen[i-2] && inClose[i] < inClose[i-2]
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdl2CrowsStateInit( struct TA_cdl2Crows_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdl2Crows ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdl2CrowsLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDL2CROWS_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdl2CrowsState( struct TA_cdl2Crows_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      unsigned int i1,i2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyLongPeriodTotal = 0.;
      }
      if ( _state.value .mem_index > _state.value .mem_size -2)
      {
         i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
         i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
         if( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) == 1 &&
            ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == -1 &&
            ( ((( ( _state.value .memory+i1).value .inOpen ) < ( ( _state.value .memory+i1).value .inClose )) ? ( ( _state.value .memory+i1).value .inOpen ) : ( ( _state.value .memory+i1).value .inClose )) > ((( ( _state.value .memory+i2).value .inOpen ) > ( ( _state.value .memory+i2).value .inClose )) ? ( ( _state.value .memory+i2).value .inOpen ) : ( ( _state.value .memory+i2).value .inClose )) ) &&
            ( inClose >= inOpen ? 1 : -1 ) == -1 &&
            inOpen < ( _state.value .memory+i1).value .inOpen && inOpen > ( _state.value .memory+i1).value .inClose &&
            inClose > ( _state.value .memory+i2).value .inOpen && inClose < ( _state.value .memory+i2).value .inClose
            )
            outInteger.value = -100;
         else
            outInteger.value = 0;
         _state.value .BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) - ( - _state.value .mem_size !=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .mem_size )% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .mem_size )% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .mem_size )% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .mem_size )% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .mem_size )% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .mem_size )% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .mem_size )% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .mem_size )% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .mem_size )% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .mem_size )% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .mem_size )% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .mem_size )% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .mem_size )% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .mem_size )% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      } else _state.value .BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdl2CrowsStateFree( struct TA_cdl2Crows_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdl2CrowsStateSave( struct TA_cdl2Crows_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDL2CROWS_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyLongPeriodTotal,sizeof( _state.value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdl2CrowsStateLoad( struct TA_cdl2Crows_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdl2Crows ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDL2CROWS_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDL2CROWS_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyLongPeriodTotal,sizeof( _state.value .value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdl2Crows( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyLongPeriodTotal;
      int i, outIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdl2CrowsLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inOpen[i] < inOpen[i-1] && inOpen[i] > inClose[i-1] &&
            inClose[i] > inOpen[i-2] && inClose[i] < inClose[i-2]
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdl3BlackCrowsLookback( )
   {
      return (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) + 3;
   }
   public RetCode cdl3BlackCrows( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []ShadowVeryShortPeriodTotal = new double[3] ;
      int i, outIdx, totIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdl3BlackCrowsLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal[2] = 0;
      ShadowVeryShortPeriodTotal[1] = 0;
      ShadowVeryShortPeriodTotal[0] = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) == 1 &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[2] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i-1] < inOpen[i-2] && inOpen[i-1] > inClose[i-2] &&
            inOpen[i] < inOpen[i-1] && inOpen[i] > inClose[i-1] &&
            inHigh[i-3] > inClose[i-2] &&
            inClose[i-2] > inClose[i-1] &&
            inClose[i-1] > inClose[i]
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 2; totIdx >= 0; --totIdx)
            ShadowVeryShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-totIdx] - inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inClose[ShadowVeryShortTrailingIdx-totIdx] : inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inOpen[ShadowVeryShortTrailingIdx-totIdx] : inClose[ShadowVeryShortTrailingIdx-totIdx] ) - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         i++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdl3BlackCrowsStateInit( struct TA_cdl3BlackCrows_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdl3BlackCrows ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdl3BlackCrowsLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDL3BLACKCROWS_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdl3BlackCrowsState( struct TA_cdl3BlackCrows_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      unsigned int i1,i2,i3;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .ShadowVeryShortPeriodTotal0 = 0.;
         _state.value .ShadowVeryShortPeriodTotal1 = 0.;
         _state.value .ShadowVeryShortPeriodTotal2 = 0.;
         _state.value .periodShadowVeryShort = - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         i3 = (( _state.value .mem_index-1+-3)% _state.value .mem_size ) ;
         if( ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? 1 : -1 ) == 1 &&
            ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) == -1 &&
            ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal2 / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == -1 &&
            ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal1 / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose >= inOpen ? 1 : -1 ) == -1 &&
            ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal0 / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( _state.value .memory+i1).value .inOpen < ( _state.value .memory+i2).value .inOpen && ( _state.value .memory+i1).value .inOpen > ( _state.value .memory+i2).value .inClose &&
            inOpen < ( _state.value .memory+i1).value .inOpen && inOpen > ( _state.value .memory+i1).value .inClose &&
            ( _state.value .memory+i3).value .inHigh > ( _state.value .memory+i2).value .inClose &&
            ( _state.value .memory+i2).value .inClose > ( _state.value .memory+i1).value .inClose &&
            ( _state.value .memory+i1).value .inClose > inClose
            )
            outInteger.value = -100;
         else
            outInteger.value = 0;
         _state.value .ShadowVeryShortPeriodTotal2 -= ( _state.value .periodShadowVeryShort-2!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowVeryShortPeriodTotal1 -= ( _state.value .periodShadowVeryShort-1!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowVeryShortPeriodTotal0 -= ( _state.value .periodShadowVeryShort!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+_state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      if ( _state.value .mem_index-1 >= 2)
      {
         _state.value .ShadowVeryShortPeriodTotal2 += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
         _state.value .ShadowVeryShortPeriodTotal1 += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
         _state.value .ShadowVeryShortPeriodTotal0 += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdl3BlackCrowsStateFree( struct TA_cdl3BlackCrows_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdl3BlackCrowsStateSave( struct TA_cdl3BlackCrows_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDL3BLACKCROWS_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal0,sizeof( _state.value .ShadowVeryShortPeriodTotal0),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal1,sizeof( _state.value .ShadowVeryShortPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal2,sizeof( _state.value .ShadowVeryShortPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowVeryShort,sizeof( _state.value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdl3BlackCrowsStateLoad( struct TA_cdl3BlackCrows_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdl3BlackCrows ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDL3BLACKCROWS_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDL3BLACKCROWS_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal0,sizeof( _state.value .value .ShadowVeryShortPeriodTotal0),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal1,sizeof( _state.value .value .ShadowVeryShortPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal2,sizeof( _state.value .value .ShadowVeryShortPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowVeryShort,sizeof( _state.value .value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdl3BlackCrows( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []ShadowVeryShortPeriodTotal = new double[3] ;
      int i, outIdx, totIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdl3BlackCrowsLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal[2] = 0;
      ShadowVeryShortPeriodTotal[1] = 0;
      ShadowVeryShortPeriodTotal[0] = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) == 1 &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[2] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i-1] < inOpen[i-2] && inOpen[i-1] > inClose[i-2] &&
            inOpen[i] < inOpen[i-1] && inOpen[i] > inClose[i-1] &&
            inHigh[i-3] > inClose[i-2] &&
            inClose[i-2] > inClose[i-1] &&
            inClose[i-1] > inClose[i]
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 2; totIdx >= 0; --totIdx)
            ShadowVeryShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-totIdx] - inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inClose[ShadowVeryShortTrailingIdx-totIdx] : inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inOpen[ShadowVeryShortTrailingIdx-totIdx] : inClose[ShadowVeryShortTrailingIdx-totIdx] ) - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         i++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdl3InsideLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) + 2;
   }
   public RetCode cdl3Inside( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyShortPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdl3InsideLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx-1 ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (((inClose[i-1]) > (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) < (((inClose[i-2]) > (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) &&
            (((inClose[i-1]) < (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) > (((inClose[i-2]) < (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) &&
            ( ( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 && ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 && inClose[i] < inOpen[i-2] )
            ||
            ( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 && ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 && inClose[i] > inOpen[i-2] )
            )
            )
            outInteger[outIdx++] = - ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdl3InsideStateInit( struct TA_cdl3Inside_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdl3Inside ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdl3InsideLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDL3INSIDE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdl3InsideState( struct TA_cdl3Inside_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      unsigned int i1,i2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyLongPeriodTotal = 0.;
         _state.value .BodyShortPeriodTotal = 0.;
         _state.value .periodBodyLong = 2 + (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
         _state.value .periodBodyShort = 1 + (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? _state.value .BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ((( ( _state.value .memory+i1).value .inClose ) > ( ( _state.value .memory+i1).value .inOpen )) ? ( ( _state.value .memory+i1).value .inClose ) : ( ( _state.value .memory+i1).value .inOpen )) < ((( ( _state.value .memory+i2).value .inClose ) > ( ( _state.value .memory+i2).value .inOpen )) ? ( ( _state.value .memory+i2).value .inClose ) : ( ( _state.value .memory+i2).value .inOpen )) &&
            ((( ( _state.value .memory+i1).value .inClose ) < ( ( _state.value .memory+i1).value .inOpen )) ? ( ( _state.value .memory+i1).value .inClose ) : ( ( _state.value .memory+i1).value .inOpen )) > ((( ( _state.value .memory+i2).value .inClose ) < ( ( _state.value .memory+i2).value .inOpen )) ? ( ( _state.value .memory+i2).value .inClose ) : ( ( _state.value .memory+i2).value .inOpen )) &&
            ( ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) == 1 && ( inClose >= inOpen ? 1 : -1 ) == -1 && inClose < ( _state.value .memory+i2).value .inOpen )
            ||
            ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) == -1 && ( inClose >= inOpen ? 1 : -1 ) == 1 && inClose > ( _state.value .memory+i2).value .inOpen )
            )
            )
            outInteger.value = - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) * 100;
         else
            outInteger.value = 0;
      }
      if ( _state.value .mem_index-1 >= 2)
      {
         _state.value .BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
      }
      if ( _state.value .mem_index-1 >= 1)
      {
         _state.value .BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .BodyLongPeriodTotal -= ( - _state.value .periodBodyLong!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyShortPeriodTotal -= ( - _state.value .periodBodyShort!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdl3InsideStateFree( struct TA_cdl3Inside_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdl3InsideStateSave( struct TA_cdl3Inside_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDL3INSIDE_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyLongPeriodTotal,sizeof( _state.value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyShortPeriodTotal,sizeof( _state.value .BodyShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyLong,sizeof( _state.value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyShort,sizeof( _state.value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdl3InsideStateLoad( struct TA_cdl3Inside_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdl3Inside ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDL3INSIDE_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDL3INSIDE_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyLongPeriodTotal,sizeof( _state.value .value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyShortPeriodTotal,sizeof( _state.value .value .BodyShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyLong,sizeof( _state.value .value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyShort,sizeof( _state.value .value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdl3Inside( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyShortPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdl3InsideLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx-1 ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (((inClose[i-1]) > (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) < (((inClose[i-2]) > (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) &&
            (((inClose[i-1]) < (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) > (((inClose[i-2]) < (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) &&
            ( ( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 && ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 && inClose[i] < inOpen[i-2] )
            ||
            ( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 && ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 && inClose[i] > inOpen[i-2] )
            )
            )
            outInteger[outIdx++] = - ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdl3LineStrikeLookback( )
   {
      return (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) + 3;
   }
   public RetCode cdl3LineStrike( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []NearPeriodTotal = new double[4] ;
      int i, outIdx, totIdx, NearTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdl3LineStrikeLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      NearPeriodTotal[3] = 0;
      NearPeriodTotal[2] = 0;
      NearTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      i = NearTrailingIdx;
      while( i < startIdx ) {
         NearPeriodTotal[3] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ;
         NearPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) == ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == - ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) &&
            inOpen[i-2] >= (((inOpen[i-3]) < (inClose[i-3])) ? (inOpen[i-3]) : (inClose[i-3])) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[3] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i-2] <= (((inOpen[i-3]) > (inClose[i-3])) ? (inOpen[i-3]) : (inClose[i-3])) + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[3] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i-1] >= (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[2] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i-1] <= (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[2] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            (
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            inClose[i-1] > inClose[i-2] && inClose[i-2] > inClose[i-3] &&
            inOpen[i] > inClose[i-1] &&
            inClose[i] < inOpen[i-3]
            ) ||
            (
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            inClose[i-1] < inClose[i-2] && inClose[i-2] < inClose[i-3] &&
            inOpen[i] < inClose[i-1] &&
            inClose[i] > inOpen[i-3]
            )
            )
            )
            outInteger[outIdx++] = ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 3; totIdx >= 2; --totIdx)
            NearPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-totIdx] - inOpen[NearTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-totIdx] - inLow[NearTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-totIdx] - ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inClose[NearTrailingIdx-totIdx] : inOpen[NearTrailingIdx-totIdx] ) ) + ( ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inOpen[NearTrailingIdx-totIdx] : inClose[NearTrailingIdx-totIdx] ) - inLow[NearTrailingIdx-totIdx] ) : 0 ) ) ) ;
         i++;
         NearTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdl3LineStrikeStateInit( struct TA_cdl3LineStrike_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdl3LineStrike ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdl3LineStrikeLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDL3LINESTRIKE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdl3LineStrikeState( struct TA_cdl3LineStrike_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      unsigned int i1,i2,i3;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .NearPeriodTotal3 = 0.;
         _state.value .NearPeriodTotal2 = 0.;
         _state.value .periodNear = (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      }
      i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
      i3 = (( _state.value .mem_index-1+-3)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
         if( ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? 1 : -1 ) == ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) &&
            ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) == ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) &&
            ( inClose >= inOpen ? 1 : -1 ) == - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) &&
            ( _state.value .memory+i2).value .inOpen >= ((( ( _state.value .memory+i3).value .inOpen ) < ( ( _state.value .memory+i3).value .inClose )) ? ( ( _state.value .memory+i3).value .inOpen ) : ( ( _state.value .memory+i3).value .inClose )) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? _state.value .NearPeriodTotal3 / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i3).value .inClose - ( _state.value .memory+i3).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i3).value .inHigh - ( _state.value .memory+i3).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i3).value .inHigh - ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? ( _state.value .memory+i3).value .inClose : ( _state.value .memory+i3).value .inOpen ) ) + ( ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? ( _state.value .memory+i3).value .inOpen : ( _state.value .memory+i3).value .inClose ) - ( _state.value .memory+i3).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( _state.value .memory+i2).value .inOpen <= ((( ( _state.value .memory+i3).value .inOpen ) > ( ( _state.value .memory+i3).value .inClose )) ? ( ( _state.value .memory+i3).value .inOpen ) : ( ( _state.value .memory+i3).value .inClose )) + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? _state.value .NearPeriodTotal3 / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i3).value .inClose - ( _state.value .memory+i3).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i3).value .inHigh - ( _state.value .memory+i3).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i3).value .inHigh - ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? ( _state.value .memory+i3).value .inClose : ( _state.value .memory+i3).value .inOpen ) ) + ( ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? ( _state.value .memory+i3).value .inOpen : ( _state.value .memory+i3).value .inClose ) - ( _state.value .memory+i3).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( _state.value .memory+i1).value .inOpen >= ((( ( _state.value .memory+i2).value .inOpen ) < ( ( _state.value .memory+i2).value .inClose )) ? ( ( _state.value .memory+i2).value .inOpen ) : ( ( _state.value .memory+i2).value .inClose )) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? _state.value .NearPeriodTotal2 / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( _state.value .memory+i1).value .inOpen <= ((( ( _state.value .memory+i2).value .inOpen ) > ( ( _state.value .memory+i2).value .inClose )) ? ( ( _state.value .memory+i2).value .inOpen ) : ( ( _state.value .memory+i2).value .inClose )) + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? _state.value .NearPeriodTotal2 / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            (
            ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == 1 &&
            ( _state.value .memory+i1).value .inClose > ( _state.value .memory+i2).value .inClose && ( _state.value .memory+i2).value .inClose > ( _state.value .memory+i3).value .inClose &&
            inOpen > ( _state.value .memory+i1).value .inClose &&
            inClose < ( _state.value .memory+i3).value .inOpen
            ) ||
            (
            ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == -1 &&
            ( _state.value .memory+i1).value .inClose < ( _state.value .memory+i2).value .inClose && ( _state.value .memory+i2).value .inClose < ( _state.value .memory+i3).value .inClose &&
            inOpen < ( _state.value .memory+i1).value .inClose &&
            inClose > ( _state.value .memory+i3).value .inOpen
            )
            )
            )
            outInteger.value = ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) * 100;
         else
            outInteger.value = 0;
      }
      if ( _state.value .mem_index-1 >= 3)
      {
         _state.value .NearPeriodTotal3 += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i3).value .inClose - ( _state.value .memory+i3).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i3).value .inHigh - ( _state.value .memory+i3).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i3).value .inHigh - ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? ( _state.value .memory+i3).value .inClose : ( _state.value .memory+i3).value .inOpen ) ) + ( ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? ( _state.value .memory+i3).value .inOpen : ( _state.value .memory+i3).value .inClose ) - ( _state.value .memory+i3).value .inLow ) : 0 ) ) ) ;
         _state.value .NearPeriodTotal2 += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .NearPeriodTotal3 -= ( - _state.value .periodNear-3!=0?( ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-3)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-3)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-3)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-3)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-3)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-3)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-3)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-3)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-3)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-3)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-3)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-3)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-3)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-3)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .NearPeriodTotal2 -= ( - _state.value .periodNear-2!=0?( ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdl3LineStrikeStateFree( struct TA_cdl3LineStrike_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdl3LineStrikeStateSave( struct TA_cdl3LineStrike_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDL3LINESTRIKE_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .NearPeriodTotal3,sizeof( _state.value .NearPeriodTotal3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .NearPeriodTotal2,sizeof( _state.value .NearPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodNear,sizeof( _state.value .periodNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdl3LineStrikeStateLoad( struct TA_cdl3LineStrike_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdl3LineStrike ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDL3LINESTRIKE_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDL3LINESTRIKE_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .NearPeriodTotal3,sizeof( _state.value .value .NearPeriodTotal3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .NearPeriodTotal2,sizeof( _state.value .value .NearPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodNear,sizeof( _state.value .value .periodNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdl3LineStrike( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []NearPeriodTotal = new double[4] ;
      int i, outIdx, totIdx, NearTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdl3LineStrikeLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      NearPeriodTotal[3] = 0;
      NearPeriodTotal[2] = 0;
      NearTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      i = NearTrailingIdx;
      while( i < startIdx ) {
         NearPeriodTotal[3] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ;
         NearPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) == ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == - ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) &&
            inOpen[i-2] >= (((inOpen[i-3]) < (inClose[i-3])) ? (inOpen[i-3]) : (inClose[i-3])) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[3] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i-2] <= (((inOpen[i-3]) > (inClose[i-3])) ? (inOpen[i-3]) : (inClose[i-3])) + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[3] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i-1] >= (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[2] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i-1] <= (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[2] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            (
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            inClose[i-1] > inClose[i-2] && inClose[i-2] > inClose[i-3] &&
            inOpen[i] > inClose[i-1] &&
            inClose[i] < inOpen[i-3]
            ) ||
            (
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            inClose[i-1] < inClose[i-2] && inClose[i-2] < inClose[i-3] &&
            inOpen[i] < inClose[i-1] &&
            inClose[i] > inOpen[i-3]
            )
            )
            )
            outInteger[outIdx++] = ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 3; totIdx >= 2; --totIdx)
            NearPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-totIdx] - inOpen[NearTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-totIdx] - inLow[NearTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-totIdx] - ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inClose[NearTrailingIdx-totIdx] : inOpen[NearTrailingIdx-totIdx] ) ) + ( ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inOpen[NearTrailingIdx-totIdx] : inClose[NearTrailingIdx-totIdx] ) - inLow[NearTrailingIdx-totIdx] ) : 0 ) ) ) ;
         i++;
         NearTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdl3OutsideLookback( )
   {
      return 3;
   }
   public RetCode cdl3Outside( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      int i, outIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdl3OutsideLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 && ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            inClose[i-1] > inOpen[i-2] && inOpen[i-1] < inClose[i-2] &&
            inClose[i] > inClose[i-1]
            )
            ||
            ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 && ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            inOpen[i-1] > inClose[i-2] && inClose[i-1] < inOpen[i-2] &&
            inClose[i] < inClose[i-1]
            )
            )
         {
            outInteger[outIdx++] = ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 100;
         }
         else
            outInteger[outIdx++] = 0;
         i++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdl3OutsideStateInit( struct TA_cdl3Outside_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdl3Outside ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdl3OutsideLookback ();
      _state.value .value .memory = NULL;
      _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDL3OUTSIDE_Data));
      return RetCode.Success ;
   }
   public RetCode cdl3OutsideState( struct TA_cdl3Outside_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1, i2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
      if( ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == 1 && ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) == -1 &&
         ( _state.value .memory+i1).value .inClose > ( _state.value .memory+i2).value .inOpen && ( _state.value .memory+i1).value .inOpen < ( _state.value .memory+i2).value .inClose &&
         inClose > ( _state.value .memory+i1).value .inClose
         )
         ||
         ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == -1 && ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) == 1 &&
         ( _state.value .memory+i1).value .inOpen > ( _state.value .memory+i2).value .inClose && ( _state.value .memory+i1).value .inClose < ( _state.value .memory+i2).value .inOpen &&
         inClose < ( _state.value .memory+i1).value .inClose
         )
         )
         outInteger.value = ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) * 100;
      else
         outInteger.value = 0;
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      return RetCode.Success ;
   }
   public RetCode cdl3OutsideStateFree( struct TA_cdl3Outside_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdl3OutsideStateSave( struct TA_cdl3Outside_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDL3OUTSIDE_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode cdl3OutsideStateLoad( struct TA_cdl3Outside_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdl3Outside ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDL3OUTSIDE_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDL3OUTSIDE_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode cdl3Outside( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      int i, outIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdl3OutsideLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 && ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            inClose[i-1] > inOpen[i-2] && inOpen[i-1] < inClose[i-2] &&
            inClose[i] > inClose[i-1]
            )
            ||
            ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 && ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            inOpen[i-1] > inClose[i-2] && inClose[i-1] < inOpen[i-2] &&
            inClose[i] < inClose[i-1]
            )
            )
         {
            outInteger[outIdx++] = ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 100;
         }
         else
            outInteger[outIdx++] = 0;
         i++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdl3StarsInSouthLookback( )
   {
      return ((( ((( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) > ( ((( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) )) ? ( ((( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) : ( ((( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) )) +
         2;
   }
   public RetCode cdl3StarsInSouth( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyLongPeriodTotal, BodyShortPeriodTotal, ShadowLongPeriodTotal;
      double []ShadowVeryShortPeriodTotal = new double[2] ;
      int i, outIdx, totIdx, BodyLongTrailingIdx, BodyShortTrailingIdx, ShadowLongTrailingIdx, ShadowVeryShortTrailingIdx,
         lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdl3StarsInSouthLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal[1] = 0;
      ShadowVeryShortPeriodTotal[0] = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      BodyShortPeriodTotal = 0;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) < ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) &&
            inOpen[i-1] > inClose[i-2] && inOpen[i-1] <= inHigh[i-2] &&
            inLow[i-1] < inClose[i-2] &&
            inLow[i-1] >= inLow[i-2] &&
            ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inLow[i] > inLow[i-1] && inHigh[i] < inHigh[i-1]
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-2] - inOpen[BodyLongTrailingIdx-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-2] - inLow[BodyLongTrailingIdx-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-2] - ( inClose[BodyLongTrailingIdx-2] >= inOpen[BodyLongTrailingIdx-2] ? inClose[BodyLongTrailingIdx-2] : inOpen[BodyLongTrailingIdx-2] ) ) + ( ( inClose[BodyLongTrailingIdx-2] >= inOpen[BodyLongTrailingIdx-2] ? inOpen[BodyLongTrailingIdx-2] : inClose[BodyLongTrailingIdx-2] ) - inLow[BodyLongTrailingIdx-2] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx-2] - inOpen[ShadowLongTrailingIdx-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx-2] - inLow[ShadowLongTrailingIdx-2] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx-2] - ( inClose[ShadowLongTrailingIdx-2] >= inOpen[ShadowLongTrailingIdx-2] ? inClose[ShadowLongTrailingIdx-2] : inOpen[ShadowLongTrailingIdx-2] ) ) + ( ( inClose[ShadowLongTrailingIdx-2] >= inOpen[ShadowLongTrailingIdx-2] ? inOpen[ShadowLongTrailingIdx-2] : inClose[ShadowLongTrailingIdx-2] ) - inLow[ShadowLongTrailingIdx-2] ) : 0 ) ) ) ;
         for (totIdx = 1; totIdx >= 0; --totIdx)
            ShadowVeryShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-totIdx] - inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inClose[ShadowVeryShortTrailingIdx-totIdx] : inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inOpen[ShadowVeryShortTrailingIdx-totIdx] : inClose[ShadowVeryShortTrailingIdx-totIdx] ) - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         ShadowLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdl3StarsInSouthStateInit( struct TA_cdl3StarsInSouth_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdl3StarsInSouth ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdl3StarsInSouthLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDL3STARSINSOUTH_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdl3StarsInSouthState( struct TA_cdl3StarsInSouth_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      unsigned int i1,i2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyLongPeriodTotal = 0.;
         _state.value .ShadowLongPeriodTotal = 0.;
         _state.value .ShadowVeryShortPeriodTotal1 = 0.;
         _state.value .ShadowVeryShortPeriodTotal0 = 0.;
         _state.value .BodyShortPeriodTotal = 0.;
         _state.value .periodBodyLong = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
         _state.value .periodShadowLong = (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
         _state.value .periodShadowVeryShort = (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
         _state.value .periodBodyShort = (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
         _state.value .gapBodyLong = _state.value .mem_size - _state.value .periodBodyLong;
         _state.value .gapShadowLong = _state.value .mem_size - _state.value .periodShadowLong;
         _state.value .gapShadowVeryShort = _state.value .mem_size - _state.value .periodShadowVeryShort;
         _state.value .gapBodyShort = _state.value .mem_size - _state.value .periodBodyShort;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) == -1 &&
            ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == -1 &&
            ( inClose >= inOpen ? 1 : -1 ) == -1 &&
            ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? _state.value .ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) < ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) &&
            ( _state.value .memory+i1).value .inOpen > ( _state.value .memory+i2).value .inClose && ( _state.value .memory+i1).value .inOpen <= ( _state.value .memory+i2).value .inHigh &&
            ( _state.value .memory+i1).value .inLow < ( _state.value .memory+i2).value .inClose &&
            ( _state.value .memory+i1).value .inLow >= ( _state.value .memory+i2).value .inLow &&
            ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal1 / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose - inOpen ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? _state.value .BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal0 / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal0 / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inLow > ( _state.value .memory+i1).value .inLow && inHigh < ( _state.value .memory+i1).value .inHigh
            )
            outInteger.value = 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyLong)
      {
         _state.value .BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadowLong)
      {
         _state.value .ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadowVeryShort)
      {
         _state.value .ShadowVeryShortPeriodTotal1 += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
         _state.value .ShadowVeryShortPeriodTotal0 += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyShort)
      {
         _state.value .BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .BodyLongPeriodTotal -= ( - _state.value .periodBodyLong-2!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowLongPeriodTotal -= ( - _state.value .periodShadowLong-2!=0?( ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong-2)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong-2)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong-2)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong-2)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong-2)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong-2)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong-2)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong-2)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong-2)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong-2)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowVeryShortPeriodTotal1 -= ( - _state.value .periodShadowVeryShort-1!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowVeryShortPeriodTotal0 -= ( - _state.value .periodShadowVeryShort!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyShortPeriodTotal -= ( - _state.value .periodBodyShort!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdl3StarsInSouthStateFree( struct TA_cdl3StarsInSouth_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdl3StarsInSouthStateSave( struct TA_cdl3StarsInSouth_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDL3STARSINSOUTH_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyLongPeriodTotal,sizeof( _state.value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowLongPeriodTotal,sizeof( _state.value .ShadowLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal1,sizeof( _state.value .ShadowVeryShortPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal0,sizeof( _state.value .ShadowVeryShortPeriodTotal0),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyShortPeriodTotal,sizeof( _state.value .BodyShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyLong,sizeof( _state.value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowLong,sizeof( _state.value .periodShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowVeryShort,sizeof( _state.value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyShort,sizeof( _state.value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyLong,sizeof( _state.value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadowLong,sizeof( _state.value .gapShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadowVeryShort,sizeof( _state.value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyShort,sizeof( _state.value .gapBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdl3StarsInSouthStateLoad( struct TA_cdl3StarsInSouth_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdl3StarsInSouth ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDL3STARSINSOUTH_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDL3STARSINSOUTH_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyLongPeriodTotal,sizeof( _state.value .value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowLongPeriodTotal,sizeof( _state.value .value .ShadowLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal1,sizeof( _state.value .value .ShadowVeryShortPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal0,sizeof( _state.value .value .ShadowVeryShortPeriodTotal0),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyShortPeriodTotal,sizeof( _state.value .value .BodyShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyLong,sizeof( _state.value .value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowLong,sizeof( _state.value .value .periodShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowVeryShort,sizeof( _state.value .value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyShort,sizeof( _state.value .value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyLong,sizeof( _state.value .value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadowLong,sizeof( _state.value .value .gapShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadowVeryShort,sizeof( _state.value .value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyShort,sizeof( _state.value .value .gapBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdl3StarsInSouth( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyLongPeriodTotal, BodyShortPeriodTotal, ShadowLongPeriodTotal;
      double []ShadowVeryShortPeriodTotal = new double[2] ;
      int i, outIdx, totIdx, BodyLongTrailingIdx, BodyShortTrailingIdx, ShadowLongTrailingIdx, ShadowVeryShortTrailingIdx,
         lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdl3StarsInSouthLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal[1] = 0;
      ShadowVeryShortPeriodTotal[0] = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      BodyShortPeriodTotal = 0;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) < ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) &&
            inOpen[i-1] > inClose[i-2] && inOpen[i-1] <= inHigh[i-2] &&
            inLow[i-1] < inClose[i-2] &&
            inLow[i-1] >= inLow[i-2] &&
            ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inLow[i] > inLow[i-1] && inHigh[i] < inHigh[i-1]
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-2] - inOpen[BodyLongTrailingIdx-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-2] - inLow[BodyLongTrailingIdx-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-2] - ( inClose[BodyLongTrailingIdx-2] >= inOpen[BodyLongTrailingIdx-2] ? inClose[BodyLongTrailingIdx-2] : inOpen[BodyLongTrailingIdx-2] ) ) + ( ( inClose[BodyLongTrailingIdx-2] >= inOpen[BodyLongTrailingIdx-2] ? inOpen[BodyLongTrailingIdx-2] : inClose[BodyLongTrailingIdx-2] ) - inLow[BodyLongTrailingIdx-2] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx-2] - inOpen[ShadowLongTrailingIdx-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx-2] - inLow[ShadowLongTrailingIdx-2] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx-2] - ( inClose[ShadowLongTrailingIdx-2] >= inOpen[ShadowLongTrailingIdx-2] ? inClose[ShadowLongTrailingIdx-2] : inOpen[ShadowLongTrailingIdx-2] ) ) + ( ( inClose[ShadowLongTrailingIdx-2] >= inOpen[ShadowLongTrailingIdx-2] ? inOpen[ShadowLongTrailingIdx-2] : inClose[ShadowLongTrailingIdx-2] ) - inLow[ShadowLongTrailingIdx-2] ) : 0 ) ) ) ;
         for (totIdx = 1; totIdx >= 0; --totIdx)
            ShadowVeryShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-totIdx] - inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inClose[ShadowVeryShortTrailingIdx-totIdx] : inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inOpen[ShadowVeryShortTrailingIdx-totIdx] : inClose[ShadowVeryShortTrailingIdx-totIdx] ) - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         ShadowLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdl3WhiteSoldiersLookback( )
   {
      return ((( ((( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) ) > ( ((( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) )) ? ( ((( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) ) : ( ((( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) )) +
         2;
   }
   public RetCode cdl3WhiteSoldiers( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []ShadowVeryShortPeriodTotal = new double[3] ;
      double []NearPeriodTotal = new double[3] ;
      double []FarPeriodTotal = new double[3] ;
      double BodyShortPeriodTotal;
      int i, outIdx, totIdx, ShadowVeryShortTrailingIdx, NearTrailingIdx, FarTrailingIdx, BodyShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdl3WhiteSoldiersLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal[2] = 0;
      ShadowVeryShortPeriodTotal[1] = 0;
      ShadowVeryShortPeriodTotal[0] = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      NearPeriodTotal[2] = 0;
      NearPeriodTotal[1] = 0;
      NearPeriodTotal[0] = 0;
      NearTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      FarPeriodTotal[2] = 0;
      FarPeriodTotal[1] = 0;
      FarPeriodTotal[0] = 0;
      FarTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ;
      BodyShortPeriodTotal = 0;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = NearTrailingIdx;
      while( i < startIdx ) {
         NearPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         NearPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = FarTrailingIdx;
      while( i < startIdx ) {
         FarPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         FarPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[2] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] > inClose[i-1] && inClose[i-1] > inClose[i-2] &&
            inOpen[i-1] > inOpen[i-2] &&
            inOpen[i-1] <= inClose[i-2] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[2] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] > inOpen[i-1] &&
            inOpen[i] <= inClose[i-1] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[1] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) - ( (this.candleSettings[CandleSettingType.Far.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) != 0.0? FarPeriodTotal[2] / (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) - ( (this.candleSettings[CandleSettingType.Far.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) != 0.0? FarPeriodTotal[1] / (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 2; totIdx >= 0; --totIdx)
            ShadowVeryShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-totIdx] - inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inClose[ShadowVeryShortTrailingIdx-totIdx] : inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inOpen[ShadowVeryShortTrailingIdx-totIdx] : inClose[ShadowVeryShortTrailingIdx-totIdx] ) - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         for (totIdx = 2; totIdx >= 1; --totIdx) {
            FarPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[FarTrailingIdx-totIdx] - inOpen[FarTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[FarTrailingIdx-totIdx] - inLow[FarTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[FarTrailingIdx-totIdx] - ( inClose[FarTrailingIdx-totIdx] >= inOpen[FarTrailingIdx-totIdx] ? inClose[FarTrailingIdx-totIdx] : inOpen[FarTrailingIdx-totIdx] ) ) + ( ( inClose[FarTrailingIdx-totIdx] >= inOpen[FarTrailingIdx-totIdx] ? inOpen[FarTrailingIdx-totIdx] : inClose[FarTrailingIdx-totIdx] ) - inLow[FarTrailingIdx-totIdx] ) : 0 ) ) ) ;
            NearPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-totIdx] - inOpen[NearTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-totIdx] - inLow[NearTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-totIdx] - ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inClose[NearTrailingIdx-totIdx] : inOpen[NearTrailingIdx-totIdx] ) ) + ( ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inOpen[NearTrailingIdx-totIdx] : inClose[NearTrailingIdx-totIdx] ) - inLow[NearTrailingIdx-totIdx] ) : 0 ) ) ) ;
         }
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         ShadowVeryShortTrailingIdx++;
         NearTrailingIdx++;
         FarTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdl3WhiteSoldiersStateInit( struct TA_cdl3WhiteSoldiers_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdl3WhiteSoldiers ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdl3WhiteSoldiersLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDL3WHITESOLDIERS_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdl3WhiteSoldiersState( struct TA_cdl3WhiteSoldiers_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      unsigned int i1,i2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .ShadowVeryShortPeriodTotal0 = 0.;
         _state.value .ShadowVeryShortPeriodTotal1 = 0.;
         _state.value .ShadowVeryShortPeriodTotal2 = 0.;
         _state.value .NearPeriodTotal1 = 0.;
         _state.value .NearPeriodTotal2 = 0.;
         _state.value .FarPeriodTotal1 = 0.;
         _state.value .FarPeriodTotal2 = 0.;
         _state.value .BodyShortPeriodTotal = 0.;
         _state.value .periodFar = (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ;
         _state.value .periodNear = (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
         _state.value .periodShadowVeryShort = (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
         _state.value .periodBodyShort = (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
         _state.value .gapFar = _state.value .mem_size - _state.value .periodFar;
         _state.value .gapNear = _state.value .mem_size - _state.value .periodNear;
         _state.value .gapShadowVeryShort = _state.value .mem_size - _state.value .periodShadowVeryShort;
         _state.value .gapBodyShort = _state.value .mem_size - _state.value .periodBodyShort;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) == 1 &&
            ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal2 / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == 1 &&
            ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal1 / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose >= inOpen ? 1 : -1 ) == 1 &&
            ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal0 / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose > ( _state.value .memory+i1).value .inClose && ( _state.value .memory+i1).value .inClose > ( _state.value .memory+i2).value .inClose &&
            ( _state.value .memory+i1).value .inOpen > ( _state.value .memory+i2).value .inOpen &&
            ( _state.value .memory+i1).value .inOpen <= ( _state.value .memory+i2).value .inClose + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? _state.value .NearPeriodTotal2 / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen > ( _state.value .memory+i1).value .inOpen &&
            inOpen <= ( _state.value .memory+i1).value .inClose + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? _state.value .NearPeriodTotal1 / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) > ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) - ( (this.candleSettings[CandleSettingType.Far.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) != 0.0? _state.value .FarPeriodTotal2 / (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose - inOpen ) ) > ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) - ( (this.candleSettings[CandleSettingType.Far.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) != 0.0? _state.value .FarPeriodTotal1 / (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose - inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? _state.value .BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger.value = 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadowVeryShort)
      {
         _state.value .ShadowVeryShortPeriodTotal2 += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
         _state.value .ShadowVeryShortPeriodTotal1 += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
         _state.value .ShadowVeryShortPeriodTotal0 += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapFar)
      {
         _state.value .FarPeriodTotal2 += ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
         _state.value .FarPeriodTotal1 += ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapNear)
      {
         _state.value .NearPeriodTotal2 += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
         _state.value .NearPeriodTotal1 += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyShort)
      {
         _state.value .BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .ShadowVeryShortPeriodTotal2 -= ( - _state.value .periodShadowVeryShort-2!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowVeryShortPeriodTotal1 -= ( - _state.value .periodShadowVeryShort-1!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowVeryShortPeriodTotal0 -= ( - _state.value .periodShadowVeryShort!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .FarPeriodTotal2 -= ( - _state.value .periodFar-2!=0?( ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-2)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-2)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-2)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-2)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-2)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-2)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-2)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-2)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-2)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-2)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .FarPeriodTotal1 -= ( - _state.value .periodFar-1!=0?( ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .NearPeriodTotal2 -= ( - _state.value .periodNear-2!=0?( ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .NearPeriodTotal1 -= ( - _state.value .periodNear-1!=0?( ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyShortPeriodTotal -= ( - _state.value .periodBodyShort!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdl3WhiteSoldiersStateFree( struct TA_cdl3WhiteSoldiers_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdl3WhiteSoldiersStateSave( struct TA_cdl3WhiteSoldiers_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDL3WHITESOLDIERS_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal0,sizeof( _state.value .ShadowVeryShortPeriodTotal0),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal1,sizeof( _state.value .ShadowVeryShortPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal2,sizeof( _state.value .ShadowVeryShortPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .NearPeriodTotal1,sizeof( _state.value .NearPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .NearPeriodTotal2,sizeof( _state.value .NearPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .FarPeriodTotal1,sizeof( _state.value .FarPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .FarPeriodTotal2,sizeof( _state.value .FarPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyShortPeriodTotal,sizeof( _state.value .BodyShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadowVeryShort,sizeof( _state.value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowVeryShort,sizeof( _state.value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapNear,sizeof( _state.value .gapNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodNear,sizeof( _state.value .periodNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapFar,sizeof( _state.value .gapFar),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodFar,sizeof( _state.value .periodFar),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyShort,sizeof( _state.value .gapBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyShort,sizeof( _state.value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdl3WhiteSoldiersStateLoad( struct TA_cdl3WhiteSoldiers_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdl3WhiteSoldiers ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDL3WHITESOLDIERS_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDL3WHITESOLDIERS_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal0,sizeof( _state.value .value .ShadowVeryShortPeriodTotal0),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal1,sizeof( _state.value .value .ShadowVeryShortPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal2,sizeof( _state.value .value .ShadowVeryShortPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .NearPeriodTotal1,sizeof( _state.value .value .NearPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .NearPeriodTotal2,sizeof( _state.value .value .NearPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .FarPeriodTotal1,sizeof( _state.value .value .FarPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .FarPeriodTotal2,sizeof( _state.value .value .FarPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyShortPeriodTotal,sizeof( _state.value .value .BodyShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadowVeryShort,sizeof( _state.value .value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowVeryShort,sizeof( _state.value .value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapNear,sizeof( _state.value .value .gapNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodNear,sizeof( _state.value .value .periodNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapFar,sizeof( _state.value .value .gapFar),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodFar,sizeof( _state.value .value .periodFar),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyShort,sizeof( _state.value .value .gapBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyShort,sizeof( _state.value .value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdl3WhiteSoldiers( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []ShadowVeryShortPeriodTotal = new double[3] ;
      double []NearPeriodTotal = new double[3] ;
      double []FarPeriodTotal = new double[3] ;
      double BodyShortPeriodTotal;
      int i, outIdx, totIdx, ShadowVeryShortTrailingIdx, NearTrailingIdx, FarTrailingIdx, BodyShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdl3WhiteSoldiersLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal[2] = 0;
      ShadowVeryShortPeriodTotal[1] = 0;
      ShadowVeryShortPeriodTotal[0] = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      NearPeriodTotal[2] = 0;
      NearPeriodTotal[1] = 0;
      NearPeriodTotal[0] = 0;
      NearTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      FarPeriodTotal[2] = 0;
      FarPeriodTotal[1] = 0;
      FarPeriodTotal[0] = 0;
      FarTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ;
      BodyShortPeriodTotal = 0;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = NearTrailingIdx;
      while( i < startIdx ) {
         NearPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         NearPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = FarTrailingIdx;
      while( i < startIdx ) {
         FarPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         FarPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[2] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] > inClose[i-1] && inClose[i-1] > inClose[i-2] &&
            inOpen[i-1] > inOpen[i-2] &&
            inOpen[i-1] <= inClose[i-2] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[2] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] > inOpen[i-1] &&
            inOpen[i] <= inClose[i-1] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[1] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) - ( (this.candleSettings[CandleSettingType.Far.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) != 0.0? FarPeriodTotal[2] / (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) - ( (this.candleSettings[CandleSettingType.Far.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) != 0.0? FarPeriodTotal[1] / (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 2; totIdx >= 0; --totIdx)
            ShadowVeryShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-totIdx] - inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inClose[ShadowVeryShortTrailingIdx-totIdx] : inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inOpen[ShadowVeryShortTrailingIdx-totIdx] : inClose[ShadowVeryShortTrailingIdx-totIdx] ) - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         for (totIdx = 2; totIdx >= 1; --totIdx) {
            FarPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[FarTrailingIdx-totIdx] - inOpen[FarTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[FarTrailingIdx-totIdx] - inLow[FarTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[FarTrailingIdx-totIdx] - ( inClose[FarTrailingIdx-totIdx] >= inOpen[FarTrailingIdx-totIdx] ? inClose[FarTrailingIdx-totIdx] : inOpen[FarTrailingIdx-totIdx] ) ) + ( ( inClose[FarTrailingIdx-totIdx] >= inOpen[FarTrailingIdx-totIdx] ? inOpen[FarTrailingIdx-totIdx] : inClose[FarTrailingIdx-totIdx] ) - inLow[FarTrailingIdx-totIdx] ) : 0 ) ) ) ;
            NearPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-totIdx] - inOpen[NearTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-totIdx] - inLow[NearTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-totIdx] - ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inClose[NearTrailingIdx-totIdx] : inOpen[NearTrailingIdx-totIdx] ) ) + ( ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inOpen[NearTrailingIdx-totIdx] : inClose[NearTrailingIdx-totIdx] ) - inLow[NearTrailingIdx-totIdx] ) : 0 ) ) ) ;
         }
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         ShadowVeryShortTrailingIdx++;
         NearTrailingIdx++;
         FarTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlAbandonedBabyLookback( double optInPenetration )
   {
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return -1;
      return ((( ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) ? ( ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) +
         2;
   }
   public RetCode cdlAbandonedBaby( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      double optInPenetration,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, BodyLongPeriodTotal, BodyShortPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, BodyLongTrailingIdx, BodyShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      lookbackTotal = cdlAbandonedBabyLookback (optInPenetration);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyDojiPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyDojiTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyDojiTrailingIdx;
      while( i < startIdx-1 ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inClose[i] < inClose[i-2] - ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) * optInPenetration &&
            ( inLow[i-1] > inHigh[i-2] ) &&
            ( inHigh[i] < inLow[i-1] )
            )
            ||
            (
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inClose[i] > inClose[i-2] + ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) * optInPenetration &&
            ( inHigh[i-1] < inLow[i-2] ) &&
            ( inLow[i] > inHigh[i-1] )
            )
            )
            )
         {
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         }
         else
         {
            outInteger[outIdx++] = 0;
         }
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyDojiTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlAbandonedBabyStateInit( struct TA_cdlAbandonedBaby_State** _state,
      double optInPenetration )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlAbandonedBaby ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInPenetration = optInPenetration;
      _state.value .value .mem_size = cdlAbandonedBabyLookback (optInPenetration );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLABANDONEDBABY_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlAbandonedBabyState( struct TA_cdlAbandonedBaby_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      unsigned int i1,i2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyLongPeriodTotal = 0.;
         _state.value .BodyDojiPeriodTotal = 0.;
         _state.value .BodyShortPeriodTotal = 0.;
         _state.value .periodBodyLong = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) + 2;
         _state.value .periodBodyDoji = (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) - 1;
         _state.value .periodBodyShort = (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
         _state.value .gapBodyLong = _state.value .mem_size - _state.value .periodBodyLong;
         _state.value .gapBodyDoji = _state.value .mem_size - _state.value .periodBodyDoji;
         _state.value .gapBodyShort = _state.value .mem_size - _state.value .periodBodyShort;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? _state.value .BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose - inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? _state.value .BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) == 1 &&
            ( inClose >= inOpen ? 1 : -1 ) == -1 &&
            inClose < ( _state.value .memory+i2).value .inClose - ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) * _state.value .optInPenetration &&
            ( ( _state.value .memory+i1).value .inLow > ( _state.value .memory+i2).value .inHigh ) &&
            ( inHigh < ( _state.value .memory+i1).value .inLow )
            )
            ||
            (
            ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) == -1 &&
            ( inClose >= inOpen ? 1 : -1 ) == 1 &&
            inClose > ( _state.value .memory+i2).value .inClose + ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) * _state.value .optInPenetration &&
            ( ( _state.value .memory+i1).value .inHigh < ( _state.value .memory+i2).value .inLow ) &&
            ( inLow > ( _state.value .memory+i1).value .inHigh )
            )
            )
            )
         {
            outInteger.value = ( inClose >= inOpen ? 1 : -1 ) * 100;
         }
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyLong)
      {
         _state.value .BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyDoji)
      {
         _state.value .BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyShort)
      {
         _state.value .BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .BodyLongPeriodTotal -= ( - _state.value .periodBodyLong!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyDojiPeriodTotal -= ( - _state.value .periodBodyDoji!=0?( ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyShortPeriodTotal -= ( - _state.value .periodBodyShort!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlAbandonedBabyStateFree( struct TA_cdlAbandonedBaby_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlAbandonedBabyStateSave( struct TA_cdlAbandonedBaby_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLABANDONEDBABY_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInPenetration,sizeof( _state.value .optInPenetration),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyLongPeriodTotal,sizeof( _state.value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyDojiPeriodTotal,sizeof( _state.value .BodyDojiPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyShortPeriodTotal,sizeof( _state.value .BodyShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyLong,sizeof( _state.value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyLong,sizeof( _state.value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyDoji,sizeof( _state.value .gapBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyDoji,sizeof( _state.value .periodBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyShort,sizeof( _state.value .gapBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyShort,sizeof( _state.value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlAbandonedBabyStateLoad( struct TA_cdlAbandonedBaby_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlAbandonedBaby ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLABANDONEDBABY_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLABANDONEDBABY_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInPenetration,sizeof( _state.value .value .optInPenetration),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyLongPeriodTotal,sizeof( _state.value .value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyDojiPeriodTotal,sizeof( _state.value .value .BodyDojiPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyShortPeriodTotal,sizeof( _state.value .value .BodyShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyLong,sizeof( _state.value .value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyLong,sizeof( _state.value .value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyDoji,sizeof( _state.value .value .gapBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyDoji,sizeof( _state.value .value .periodBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyShort,sizeof( _state.value .value .gapBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyShort,sizeof( _state.value .value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlAbandonedBaby( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      double optInPenetration,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, BodyLongPeriodTotal, BodyShortPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, BodyLongTrailingIdx, BodyShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      lookbackTotal = cdlAbandonedBabyLookback (optInPenetration);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyDojiPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyDojiTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyDojiTrailingIdx;
      while( i < startIdx-1 ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inClose[i] < inClose[i-2] - ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) * optInPenetration &&
            ( inLow[i-1] > inHigh[i-2] ) &&
            ( inHigh[i] < inLow[i-1] )
            )
            ||
            (
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inClose[i] > inClose[i-2] + ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) * optInPenetration &&
            ( inHigh[i-1] < inLow[i-2] ) &&
            ( inLow[i] > inHigh[i-1] )
            )
            )
            )
         {
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         }
         else
         {
            outInteger[outIdx++] = 0;
         }
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyDojiTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlAdvanceBlockLookback( )
   {
      return ((( ((( ((( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) )) ) > ( ((( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) )) ? ( ((( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) )) ) : ( ((( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) )) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( ((( ((( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) )) ) > ( ((( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) )) ? ( ((( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) )) ) : ( ((( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) )) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) +
         2;
   }
   public RetCode cdlAdvanceBlock( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []ShadowShortPeriodTotal = new double[3] ;
      double []ShadowLongPeriodTotal = new double[2] ;
      double []NearPeriodTotal = new double[3] ;
      double []FarPeriodTotal = new double[3] ;
      double BodyLongPeriodTotal;
      int i, outIdx, totIdx, BodyLongTrailingIdx, ShadowShortTrailingIdx, ShadowLongTrailingIdx, NearTrailingIdx,
         FarTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlAdvanceBlockLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowShortPeriodTotal[2] = 0;
      ShadowShortPeriodTotal[1] = 0;
      ShadowShortPeriodTotal[0] = 0;
      ShadowShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal[1] = 0;
      ShadowLongPeriodTotal[0] = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      NearPeriodTotal[2] = 0;
      NearPeriodTotal[1] = 0;
      NearPeriodTotal[0] = 0;
      NearTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      FarPeriodTotal[2] = 0;
      FarPeriodTotal[1] = 0;
      FarPeriodTotal[0] = 0;
      FarTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = ShadowShortTrailingIdx;
      while( i < startIdx ) {
         ShadowShortPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         ShadowShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowShortPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = NearTrailingIdx;
      while( i < startIdx ) {
         NearPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         NearPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = FarTrailingIdx;
      while( i < startIdx ) {
         FarPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         FarPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inClose[i] > inClose[i-1] && inClose[i-1] > inClose[i-2] &&
            inOpen[i-1] > inOpen[i-2] &&
            inOpen[i-1] <= inClose[i-2] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[2] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] > inOpen[i-1] &&
            inOpen[i] <= inClose[i-1] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[1] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) < ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? ShadowShortPeriodTotal[2] / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            (
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) < ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) - ( (this.candleSettings[CandleSettingType.Far.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) != 0.0? FarPeriodTotal[2] / (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[1] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ) ||
            (
            ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) - ( (this.candleSettings[CandleSettingType.Far.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) != 0.0? FarPeriodTotal[1] / (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ) ||
            (
            ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) < ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) &&
            (
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? ShadowShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) ||
            ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? ShadowShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ) ||
            (
            ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 2; totIdx >= 0; --totIdx)
            ShadowShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowShortTrailingIdx-totIdx] - inOpen[ShadowShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowShortTrailingIdx-totIdx] - inLow[ShadowShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowShortTrailingIdx-totIdx] - ( inClose[ShadowShortTrailingIdx-totIdx] >= inOpen[ShadowShortTrailingIdx-totIdx] ? inClose[ShadowShortTrailingIdx-totIdx] : inOpen[ShadowShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowShortTrailingIdx-totIdx] >= inOpen[ShadowShortTrailingIdx-totIdx] ? inOpen[ShadowShortTrailingIdx-totIdx] : inClose[ShadowShortTrailingIdx-totIdx] ) - inLow[ShadowShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         for (totIdx = 1; totIdx >= 0; --totIdx)
            ShadowLongPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx-totIdx] - inOpen[ShadowLongTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx-totIdx] - inLow[ShadowLongTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx-totIdx] - ( inClose[ShadowLongTrailingIdx-totIdx] >= inOpen[ShadowLongTrailingIdx-totIdx] ? inClose[ShadowLongTrailingIdx-totIdx] : inOpen[ShadowLongTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowLongTrailingIdx-totIdx] >= inOpen[ShadowLongTrailingIdx-totIdx] ? inOpen[ShadowLongTrailingIdx-totIdx] : inClose[ShadowLongTrailingIdx-totIdx] ) - inLow[ShadowLongTrailingIdx-totIdx] ) : 0 ) ) ) ;
         for (totIdx = 2; totIdx >= 1; --totIdx) {
            FarPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[FarTrailingIdx-totIdx] - inOpen[FarTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[FarTrailingIdx-totIdx] - inLow[FarTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[FarTrailingIdx-totIdx] - ( inClose[FarTrailingIdx-totIdx] >= inOpen[FarTrailingIdx-totIdx] ? inClose[FarTrailingIdx-totIdx] : inOpen[FarTrailingIdx-totIdx] ) ) + ( ( inClose[FarTrailingIdx-totIdx] >= inOpen[FarTrailingIdx-totIdx] ? inOpen[FarTrailingIdx-totIdx] : inClose[FarTrailingIdx-totIdx] ) - inLow[FarTrailingIdx-totIdx] ) : 0 ) ) ) ;
            NearPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-totIdx] - inOpen[NearTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-totIdx] - inLow[NearTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-totIdx] - ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inClose[NearTrailingIdx-totIdx] : inOpen[NearTrailingIdx-totIdx] ) ) + ( ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inOpen[NearTrailingIdx-totIdx] : inClose[NearTrailingIdx-totIdx] ) - inLow[NearTrailingIdx-totIdx] ) : 0 ) ) ) ;
         }
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-2] - inOpen[BodyLongTrailingIdx-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-2] - inLow[BodyLongTrailingIdx-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-2] - ( inClose[BodyLongTrailingIdx-2] >= inOpen[BodyLongTrailingIdx-2] ? inClose[BodyLongTrailingIdx-2] : inOpen[BodyLongTrailingIdx-2] ) ) + ( ( inClose[BodyLongTrailingIdx-2] >= inOpen[BodyLongTrailingIdx-2] ? inOpen[BodyLongTrailingIdx-2] : inClose[BodyLongTrailingIdx-2] ) - inLow[BodyLongTrailingIdx-2] ) : 0 ) ) ) ;
         i++;
         ShadowShortTrailingIdx++;
         ShadowLongTrailingIdx++;
         NearTrailingIdx++;
         FarTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlAdvanceBlockStateInit( struct TA_cdlAdvanceBlock_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlAdvanceBlock ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlAdvanceBlockLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLADVANCEBLOCK_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlAdvanceBlockState( struct TA_cdlAdvanceBlock_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1,i2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .ShadowShortPeriodTotal0 = 0.;
         _state.value .ShadowShortPeriodTotal1 = 0.;
         _state.value .ShadowShortPeriodTotal2 = 0.;
         _state.value .ShadowLongPeriodTotal0 = 0.;
         _state.value .ShadowLongPeriodTotal1 = 0.;
         _state.value .NearPeriodTotal1 = 0.;
         _state.value .NearPeriodTotal2 = 0.;
         _state.value .FarPeriodTotal1 = 0.;
         _state.value .FarPeriodTotal2 = 0.;
         _state.value .BodyLongPeriodTotal = 0.;
         _state.value .periodFar = (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ;
         _state.value .periodNear = (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
         _state.value .periodShadowShort = (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) ;
         _state.value .periodShadowLong = (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
         _state.value .periodBodyLong = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
         _state.value .gapFar = _state.value .mem_size - _state.value .periodFar;
         _state.value .gapNear = _state.value .mem_size - _state.value .periodNear;
         _state.value .gapShadowShort = _state.value .mem_size - _state.value .periodShadowShort;
         _state.value .gapShadowLong = _state.value .mem_size - _state.value .periodShadowLong;
         _state.value .gapBodyLong = _state.value .mem_size - _state.value .periodBodyLong;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) == 1 &&
            ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == 1 &&
            ( inClose >= inOpen ? 1 : -1 ) == 1 &&
            inClose > ( _state.value .memory+i1).value .inClose && ( _state.value .memory+i1).value .inClose > ( _state.value .memory+i2).value .inClose &&
            ( _state.value .memory+i1).value .inOpen > ( _state.value .memory+i2).value .inOpen &&
            ( _state.value .memory+i1).value .inOpen <= ( _state.value .memory+i2).value .inClose + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? _state.value .NearPeriodTotal2 / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen > ( _state.value .memory+i1).value .inOpen &&
            inOpen <= ( _state.value .memory+i1).value .inClose + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? _state.value .NearPeriodTotal1 / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) < ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowShortPeriodTotal2 / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            (
            ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) < ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) - ( (this.candleSettings[CandleSettingType.Far.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) != 0.0? _state.value .FarPeriodTotal2 / (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose - inOpen ) ) < ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? _state.value .NearPeriodTotal1 / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ) ||
            (
            ( Math.abs ( inClose - inOpen ) ) < ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) - ( (this.candleSettings[CandleSettingType.Far.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) != 0.0? _state.value .FarPeriodTotal1 / (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ) ||
            (
            ( Math.abs ( inClose - inOpen ) ) < ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) &&
            ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) < ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) &&
            (
            ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) > ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowShortPeriodTotal0 / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) ||
            ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowShortPeriodTotal1 / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ) ||
            (
            ( Math.abs ( inClose - inOpen ) ) < ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) &&
            ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? _state.value .ShadowLongPeriodTotal0 / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            )
            outInteger.value = -100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadowShort)
      {
         _state.value .ShadowShortPeriodTotal2 += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
         _state.value .ShadowShortPeriodTotal1 += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
         _state.value .ShadowShortPeriodTotal0 += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadowLong)
      {
         _state.value .ShadowLongPeriodTotal1 += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
         _state.value .ShadowLongPeriodTotal0 += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapFar)
      {
         _state.value .FarPeriodTotal2 += ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
         _state.value .FarPeriodTotal1 += ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapNear)
      {
         _state.value .NearPeriodTotal2 += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
         _state.value .NearPeriodTotal1 += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyLong)
      {
         _state.value .BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .ShadowShortPeriodTotal2 -= ( - _state.value .periodShadowShort-2!=0?( ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort-2)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort-2)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort-2)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort-2)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort-2)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort-2)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort-2)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort-2)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort-2)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort-2)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowShortPeriodTotal1 -= ( - _state.value .periodShadowShort-1!=0?( ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort-1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort-1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort-1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort-1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort-1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort-1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort-1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort-1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort-1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort-1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowShortPeriodTotal0 -= ( - _state.value .periodShadowShort!=0?( ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowLongPeriodTotal1 -= ( - _state.value .periodShadowLong-1!=0?( ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong-1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong-1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong-1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong-1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong-1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong-1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong-1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong-1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong-1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong-1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowLongPeriodTotal0 -= ( - _state.value .periodShadowLong!=0?( ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .FarPeriodTotal2 -= ( - _state.value .periodFar-2!=0?( ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-2)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-2)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-2)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-2)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-2)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-2)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-2)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-2)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-2)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-2)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .FarPeriodTotal1 -= ( - _state.value .periodFar-1!=0?( ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodFar-1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .NearPeriodTotal2 -= ( - _state.value .periodNear-2!=0?( ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .NearPeriodTotal1 -= ( - _state.value .periodNear-1!=0?( ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyLongPeriodTotal -= ( - _state.value .periodBodyLong-2!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlAdvanceBlockStateFree( struct TA_cdlAdvanceBlock_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlAdvanceBlockStateSave( struct TA_cdlAdvanceBlock_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLADVANCEBLOCK_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .ShadowShortPeriodTotal0,sizeof( _state.value .ShadowShortPeriodTotal0),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowShortPeriodTotal1,sizeof( _state.value .ShadowShortPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowShortPeriodTotal2,sizeof( _state.value .ShadowShortPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowLongPeriodTotal0,sizeof( _state.value .ShadowLongPeriodTotal0),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowLongPeriodTotal1,sizeof( _state.value .ShadowLongPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .NearPeriodTotal1,sizeof( _state.value .NearPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .NearPeriodTotal2,sizeof( _state.value .NearPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .FarPeriodTotal1,sizeof( _state.value .FarPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .FarPeriodTotal2,sizeof( _state.value .FarPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyLongPeriodTotal,sizeof( _state.value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadowShort,sizeof( _state.value .gapShadowShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowShort,sizeof( _state.value .periodShadowShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadowLong,sizeof( _state.value .gapShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowLong,sizeof( _state.value .periodShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapNear,sizeof( _state.value .gapNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodNear,sizeof( _state.value .periodNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapFar,sizeof( _state.value .gapFar),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodFar,sizeof( _state.value .periodFar),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyLong,sizeof( _state.value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyLong,sizeof( _state.value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlAdvanceBlockStateLoad( struct TA_cdlAdvanceBlock_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlAdvanceBlock ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLADVANCEBLOCK_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLADVANCEBLOCK_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .ShadowShortPeriodTotal0,sizeof( _state.value .value .ShadowShortPeriodTotal0),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowShortPeriodTotal1,sizeof( _state.value .value .ShadowShortPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowShortPeriodTotal2,sizeof( _state.value .value .ShadowShortPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowLongPeriodTotal0,sizeof( _state.value .value .ShadowLongPeriodTotal0),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowLongPeriodTotal1,sizeof( _state.value .value .ShadowLongPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .NearPeriodTotal1,sizeof( _state.value .value .NearPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .NearPeriodTotal2,sizeof( _state.value .value .NearPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .FarPeriodTotal1,sizeof( _state.value .value .FarPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .FarPeriodTotal2,sizeof( _state.value .value .FarPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyLongPeriodTotal,sizeof( _state.value .value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadowShort,sizeof( _state.value .value .gapShadowShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowShort,sizeof( _state.value .value .periodShadowShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadowLong,sizeof( _state.value .value .gapShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowLong,sizeof( _state.value .value .periodShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapNear,sizeof( _state.value .value .gapNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodNear,sizeof( _state.value .value .periodNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapFar,sizeof( _state.value .value .gapFar),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodFar,sizeof( _state.value .value .periodFar),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyLong,sizeof( _state.value .value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyLong,sizeof( _state.value .value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlAdvanceBlock( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []ShadowShortPeriodTotal = new double[3] ;
      double []ShadowLongPeriodTotal = new double[2] ;
      double []NearPeriodTotal = new double[3] ;
      double []FarPeriodTotal = new double[3] ;
      double BodyLongPeriodTotal;
      int i, outIdx, totIdx, BodyLongTrailingIdx, ShadowShortTrailingIdx, ShadowLongTrailingIdx, NearTrailingIdx,
         FarTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlAdvanceBlockLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowShortPeriodTotal[2] = 0;
      ShadowShortPeriodTotal[1] = 0;
      ShadowShortPeriodTotal[0] = 0;
      ShadowShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal[1] = 0;
      ShadowLongPeriodTotal[0] = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      NearPeriodTotal[2] = 0;
      NearPeriodTotal[1] = 0;
      NearPeriodTotal[0] = 0;
      NearTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      FarPeriodTotal[2] = 0;
      FarPeriodTotal[1] = 0;
      FarPeriodTotal[0] = 0;
      FarTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = ShadowShortTrailingIdx;
      while( i < startIdx ) {
         ShadowShortPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         ShadowShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowShortPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = NearTrailingIdx;
      while( i < startIdx ) {
         NearPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         NearPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = FarTrailingIdx;
      while( i < startIdx ) {
         FarPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         FarPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inClose[i] > inClose[i-1] && inClose[i-1] > inClose[i-2] &&
            inOpen[i-1] > inOpen[i-2] &&
            inOpen[i-1] <= inClose[i-2] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[2] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] > inOpen[i-1] &&
            inOpen[i] <= inClose[i-1] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[1] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) < ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? ShadowShortPeriodTotal[2] / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            (
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) < ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) - ( (this.candleSettings[CandleSettingType.Far.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) != 0.0? FarPeriodTotal[2] / (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[1] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ) ||
            (
            ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) - ( (this.candleSettings[CandleSettingType.Far.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) != 0.0? FarPeriodTotal[1] / (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ) ||
            (
            ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) < ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) &&
            (
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? ShadowShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) ||
            ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? ShadowShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ) ||
            (
            ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 2; totIdx >= 0; --totIdx)
            ShadowShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowShortTrailingIdx-totIdx] - inOpen[ShadowShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowShortTrailingIdx-totIdx] - inLow[ShadowShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowShortTrailingIdx-totIdx] - ( inClose[ShadowShortTrailingIdx-totIdx] >= inOpen[ShadowShortTrailingIdx-totIdx] ? inClose[ShadowShortTrailingIdx-totIdx] : inOpen[ShadowShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowShortTrailingIdx-totIdx] >= inOpen[ShadowShortTrailingIdx-totIdx] ? inOpen[ShadowShortTrailingIdx-totIdx] : inClose[ShadowShortTrailingIdx-totIdx] ) - inLow[ShadowShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         for (totIdx = 1; totIdx >= 0; --totIdx)
            ShadowLongPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx-totIdx] - inOpen[ShadowLongTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx-totIdx] - inLow[ShadowLongTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx-totIdx] - ( inClose[ShadowLongTrailingIdx-totIdx] >= inOpen[ShadowLongTrailingIdx-totIdx] ? inClose[ShadowLongTrailingIdx-totIdx] : inOpen[ShadowLongTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowLongTrailingIdx-totIdx] >= inOpen[ShadowLongTrailingIdx-totIdx] ? inOpen[ShadowLongTrailingIdx-totIdx] : inClose[ShadowLongTrailingIdx-totIdx] ) - inLow[ShadowLongTrailingIdx-totIdx] ) : 0 ) ) ) ;
         for (totIdx = 2; totIdx >= 1; --totIdx) {
            FarPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[FarTrailingIdx-totIdx] - inOpen[FarTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[FarTrailingIdx-totIdx] - inLow[FarTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[FarTrailingIdx-totIdx] - ( inClose[FarTrailingIdx-totIdx] >= inOpen[FarTrailingIdx-totIdx] ? inClose[FarTrailingIdx-totIdx] : inOpen[FarTrailingIdx-totIdx] ) ) + ( ( inClose[FarTrailingIdx-totIdx] >= inOpen[FarTrailingIdx-totIdx] ? inOpen[FarTrailingIdx-totIdx] : inClose[FarTrailingIdx-totIdx] ) - inLow[FarTrailingIdx-totIdx] ) : 0 ) ) ) ;
            NearPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-totIdx] - inOpen[NearTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-totIdx] - inLow[NearTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-totIdx] - ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inClose[NearTrailingIdx-totIdx] : inOpen[NearTrailingIdx-totIdx] ) ) + ( ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inOpen[NearTrailingIdx-totIdx] : inClose[NearTrailingIdx-totIdx] ) - inLow[NearTrailingIdx-totIdx] ) : 0 ) ) ) ;
         }
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-2] - inOpen[BodyLongTrailingIdx-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-2] - inLow[BodyLongTrailingIdx-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-2] - ( inClose[BodyLongTrailingIdx-2] >= inOpen[BodyLongTrailingIdx-2] ? inClose[BodyLongTrailingIdx-2] : inOpen[BodyLongTrailingIdx-2] ) ) + ( ( inClose[BodyLongTrailingIdx-2] >= inOpen[BodyLongTrailingIdx-2] ? inOpen[BodyLongTrailingIdx-2] : inClose[BodyLongTrailingIdx-2] ) - inLow[BodyLongTrailingIdx-2] ) : 0 ) ) ) ;
         i++;
         ShadowShortTrailingIdx++;
         ShadowLongTrailingIdx++;
         NearTrailingIdx++;
         FarTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlBeltHoldLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ;
   }
   public RetCode cdlBeltHold( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyLongPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, BodyLongTrailingIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlBeltHoldLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            (
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ) ||
            (
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ) )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlBeltHoldStateInit( struct TA_cdlBeltHold_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlBeltHold ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlBeltHoldLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLBELTHOLD_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlBeltHoldState( struct TA_cdlBeltHold_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .ShadowVeryShortPeriodTotal = 0.;
         _state.value .BodyLongPeriodTotal = 0.;
         _state.value .periodShadowVeryShort = (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
         _state.value .periodBodyLong = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
         _state.value .gapShadowVeryShort = _state.value .mem_size - _state.value .periodShadowVeryShort;
         _state.value .gapBodyLong = _state.value .mem_size - _state.value .periodBodyLong;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( Math.abs ( inClose - inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            (
            ( inClose >= inOpen ? 1 : -1 ) == 1 &&
            ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ) ||
            (
            ( inClose >= inOpen ? 1 : -1 ) == -1 &&
            ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ) )
            outInteger.value = ( inClose >= inOpen ? 1 : -1 ) * 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadowVeryShort)
      {
         _state.value .ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyLong)
      {
         _state.value .BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .ShadowVeryShortPeriodTotal -= ( - _state.value .periodShadowVeryShort!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyLongPeriodTotal -= ( - _state.value .periodBodyLong!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      if ( _state.value .mem_size > 0)
      {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlBeltHoldStateFree( struct TA_cdlBeltHold_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlBeltHoldStateSave( struct TA_cdlBeltHold_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLBELTHOLD_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal,sizeof( _state.value .ShadowVeryShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyLongPeriodTotal,sizeof( _state.value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadowVeryShort,sizeof( _state.value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowVeryShort,sizeof( _state.value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyLong,sizeof( _state.value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyLong,sizeof( _state.value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlBeltHoldStateLoad( struct TA_cdlBeltHold_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlBeltHold ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLBELTHOLD_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLBELTHOLD_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal,sizeof( _state.value .value .ShadowVeryShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyLongPeriodTotal,sizeof( _state.value .value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadowVeryShort,sizeof( _state.value .value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowVeryShort,sizeof( _state.value .value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyLong,sizeof( _state.value .value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyLong,sizeof( _state.value .value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlBeltHold( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyLongPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, BodyLongTrailingIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlBeltHoldLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            (
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ) ||
            (
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ) )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlBreakawayLookback( )
   {
      return (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) + 4;
   }
   public RetCode cdlBreakaway( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyLongPeriodTotal;
      int i, outIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlBreakawayLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) == ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) &&
            ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) == ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == - ( inClose[i] >= inOpen[i] ? 1 : -1 ) &&
            (
            ( ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) == -1 &&
            ( (((inOpen[i-3]) > (inClose[i-3])) ? (inOpen[i-3]) : (inClose[i-3])) < (((inOpen[i-4]) < (inClose[i-4])) ? (inOpen[i-4]) : (inClose[i-4])) ) &&
            inHigh[i-2] < inHigh[i-3] && inLow[i-2] < inLow[i-3] &&
            inHigh[i-1] < inHigh[i-2] && inLow[i-1] < inLow[i-2] &&
            inClose[i] > inOpen[i-3] && inClose[i] < inClose[i-4]
            )
            ||
            ( ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) == 1 &&
            ( (((inOpen[i-3]) < (inClose[i-3])) ? (inOpen[i-3]) : (inClose[i-3])) > (((inOpen[i-4]) > (inClose[i-4])) ? (inOpen[i-4]) : (inClose[i-4])) ) &&
            inHigh[i-2] > inHigh[i-3] && inLow[i-2] > inLow[i-3] &&
            inHigh[i-1] > inHigh[i-2] && inLow[i-1] > inLow[i-2] &&
            inClose[i] < inOpen[i-3] && inClose[i] > inClose[i-4]
            )
            )
            )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-4] - inOpen[BodyLongTrailingIdx-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-4] - inLow[BodyLongTrailingIdx-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-4] - ( inClose[BodyLongTrailingIdx-4] >= inOpen[BodyLongTrailingIdx-4] ? inClose[BodyLongTrailingIdx-4] : inOpen[BodyLongTrailingIdx-4] ) ) + ( ( inClose[BodyLongTrailingIdx-4] >= inOpen[BodyLongTrailingIdx-4] ? inOpen[BodyLongTrailingIdx-4] : inClose[BodyLongTrailingIdx-4] ) - inLow[BodyLongTrailingIdx-4] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlBreakawayStateInit( struct TA_cdlBreakaway_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlBreakaway ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlBreakawayLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLBREAKAWAY_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlBreakawayState( struct TA_cdlBreakaway_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      unsigned int i1,i2,i3,i4;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyLongPeriodTotal = 0.;
      }
      i4 = (( _state.value .mem_index-1+-4)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
         i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
         i3 = (( _state.value .mem_index-1+-3)% _state.value .mem_size ) ;
         if( ( Math.abs ( ( _state.value .memory+i4).value .inClose - ( _state.value .memory+i4).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i4).value .inClose - ( _state.value .memory+i4).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i4).value .inHigh - ( _state.value .memory+i4).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i4).value .inHigh - ( ( _state.value .memory+i4).value .inClose >= ( _state.value .memory+i4).value .inOpen ? ( _state.value .memory+i4).value .inClose : ( _state.value .memory+i4).value .inOpen ) ) + ( ( ( _state.value .memory+i4).value .inClose >= ( _state.value .memory+i4).value .inOpen ? ( _state.value .memory+i4).value .inOpen : ( _state.value .memory+i4).value .inClose ) - ( _state.value .memory+i4).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( _state.value .memory+i4).value .inClose >= ( _state.value .memory+i4).value .inOpen ? 1 : -1 ) == ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? 1 : -1 ) &&
            ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? 1 : -1 ) == ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) &&
            ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == - ( inClose >= inOpen ? 1 : -1 ) &&
            (
            ( ( ( _state.value .memory+i4).value .inClose >= ( _state.value .memory+i4).value .inOpen ? 1 : -1 ) == -1 &&
            ( ((( ( _state.value .memory+i3).value .inOpen ) > ( ( _state.value .memory+i3).value .inClose )) ? ( ( _state.value .memory+i3).value .inOpen ) : ( ( _state.value .memory+i3).value .inClose )) < ((( ( _state.value .memory+i4).value .inOpen ) < ( ( _state.value .memory+i4).value .inClose )) ? ( ( _state.value .memory+i4).value .inOpen ) : ( ( _state.value .memory+i4).value .inClose )) ) &&
            ( _state.value .memory+i2).value .inHigh < ( _state.value .memory+i3).value .inHigh && ( _state.value .memory+i2).value .inLow < ( _state.value .memory+i3).value .inLow &&
            ( _state.value .memory+i1).value .inHigh < ( _state.value .memory+i2).value .inHigh && ( _state.value .memory+i1).value .inLow < ( _state.value .memory+i2).value .inLow &&
            inClose > ( _state.value .memory+i3).value .inOpen && inClose < ( _state.value .memory+i4).value .inClose
            )
            ||
            ( ( ( _state.value .memory+i4).value .inClose >= ( _state.value .memory+i4).value .inOpen ? 1 : -1 ) == 1 &&
            ( ((( ( _state.value .memory+i3).value .inOpen ) < ( ( _state.value .memory+i3).value .inClose )) ? ( ( _state.value .memory+i3).value .inOpen ) : ( ( _state.value .memory+i3).value .inClose )) > ((( ( _state.value .memory+i4).value .inOpen ) > ( ( _state.value .memory+i4).value .inClose )) ? ( ( _state.value .memory+i4).value .inOpen ) : ( ( _state.value .memory+i4).value .inClose )) ) &&
            ( _state.value .memory+i2).value .inHigh > ( _state.value .memory+i3).value .inHigh && ( _state.value .memory+i2).value .inLow > ( _state.value .memory+i3).value .inLow &&
            ( _state.value .memory+i1).value .inHigh > ( _state.value .memory+i2).value .inHigh && ( _state.value .memory+i1).value .inLow > ( _state.value .memory+i2).value .inLow &&
            inClose < ( _state.value .memory+i3).value .inOpen && inClose > ( _state.value .memory+i4).value .inClose
            )
            )
            )
            outInteger.value = ( inClose >= inOpen ? 1 : -1 ) * 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= 4)
      {
         _state.value .BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i4).value .inClose - ( _state.value .memory+i4).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i4).value .inHigh - ( _state.value .memory+i4).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i4).value .inHigh - ( ( _state.value .memory+i4).value .inClose >= ( _state.value .memory+i4).value .inOpen ? ( _state.value .memory+i4).value .inClose : ( _state.value .memory+i4).value .inOpen ) ) + ( ( ( _state.value .memory+i4).value .inClose >= ( _state.value .memory+i4).value .inOpen ? ( _state.value .memory+i4).value .inOpen : ( _state.value .memory+i4).value .inClose ) - ( _state.value .memory+i4).value .inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .BodyLongPeriodTotal -= ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlBreakawayStateFree( struct TA_cdlBreakaway_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlBreakawayStateSave( struct TA_cdlBreakaway_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLBREAKAWAY_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyLongPeriodTotal,sizeof( _state.value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlBreakawayStateLoad( struct TA_cdlBreakaway_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlBreakaway ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLBREAKAWAY_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLBREAKAWAY_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyLongPeriodTotal,sizeof( _state.value .value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlBreakaway( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyLongPeriodTotal;
      int i, outIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlBreakawayLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) == ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) &&
            ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) == ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == - ( inClose[i] >= inOpen[i] ? 1 : -1 ) &&
            (
            ( ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) == -1 &&
            ( (((inOpen[i-3]) > (inClose[i-3])) ? (inOpen[i-3]) : (inClose[i-3])) < (((inOpen[i-4]) < (inClose[i-4])) ? (inOpen[i-4]) : (inClose[i-4])) ) &&
            inHigh[i-2] < inHigh[i-3] && inLow[i-2] < inLow[i-3] &&
            inHigh[i-1] < inHigh[i-2] && inLow[i-1] < inLow[i-2] &&
            inClose[i] > inOpen[i-3] && inClose[i] < inClose[i-4]
            )
            ||
            ( ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) == 1 &&
            ( (((inOpen[i-3]) < (inClose[i-3])) ? (inOpen[i-3]) : (inClose[i-3])) > (((inOpen[i-4]) > (inClose[i-4])) ? (inOpen[i-4]) : (inClose[i-4])) ) &&
            inHigh[i-2] > inHigh[i-3] && inLow[i-2] > inLow[i-3] &&
            inHigh[i-1] > inHigh[i-2] && inLow[i-1] > inLow[i-2] &&
            inClose[i] < inOpen[i-3] && inClose[i] > inClose[i-4]
            )
            )
            )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-4] - inOpen[BodyLongTrailingIdx-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-4] - inLow[BodyLongTrailingIdx-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-4] - ( inClose[BodyLongTrailingIdx-4] >= inOpen[BodyLongTrailingIdx-4] ? inClose[BodyLongTrailingIdx-4] : inOpen[BodyLongTrailingIdx-4] ) ) + ( ( inClose[BodyLongTrailingIdx-4] >= inOpen[BodyLongTrailingIdx-4] ? inOpen[BodyLongTrailingIdx-4] : inClose[BodyLongTrailingIdx-4] ) - inLow[BodyLongTrailingIdx-4] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlClosingMarubozuLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ;
   }
   public RetCode cdlClosingMarubozu( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyLongPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, BodyLongTrailingIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlClosingMarubozuLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            (
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ) ||
            (
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ) )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlClosingMarubozuStateInit( struct TA_cdlClosingMarubozu_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlClosingMarubozu ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlClosingMarubozuLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLCLOSINGMARUBOZU_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlClosingMarubozuState( struct TA_cdlClosingMarubozu_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .ShadowVeryShortPeriodTotal = 0.;
         _state.value .BodyLongPeriodTotal = 0.;
         _state.value .periodShadowVeryShort = (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
         _state.value .periodBodyLong = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
         _state.value .gapShadowVeryShort = _state.value .mem_size - _state.value .periodShadowVeryShort;
         _state.value .gapBodyLong = _state.value .mem_size - _state.value .periodBodyLong;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( Math.abs ( inClose - inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            (
            ( inClose >= inOpen ? 1 : -1 ) == 1 &&
            ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ) ||
            (
            ( inClose >= inOpen ? 1 : -1 ) == -1 &&
            ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ) )
            outInteger.value = ( inClose >= inOpen ? 1 : -1 ) * 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadowVeryShort)
      {
         _state.value .ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyLong)
      {
         _state.value .BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .ShadowVeryShortPeriodTotal -= ( - _state.value .periodShadowVeryShort!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyLongPeriodTotal -= ( - _state.value .periodBodyLong!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      if ( _state.value .mem_size > 0)
      {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlClosingMarubozuStateFree( struct TA_cdlClosingMarubozu_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlClosingMarubozuStateSave( struct TA_cdlClosingMarubozu_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLCLOSINGMARUBOZU_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal,sizeof( _state.value .ShadowVeryShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyLongPeriodTotal,sizeof( _state.value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadowVeryShort,sizeof( _state.value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowVeryShort,sizeof( _state.value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyLong,sizeof( _state.value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyLong,sizeof( _state.value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlClosingMarubozuStateLoad( struct TA_cdlClosingMarubozu_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlClosingMarubozu ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLCLOSINGMARUBOZU_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLCLOSINGMARUBOZU_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal,sizeof( _state.value .value .ShadowVeryShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyLongPeriodTotal,sizeof( _state.value .value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadowVeryShort,sizeof( _state.value .value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowVeryShort,sizeof( _state.value .value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyLong,sizeof( _state.value .value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyLong,sizeof( _state.value .value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlClosingMarubozu( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyLongPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, BodyLongTrailingIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlClosingMarubozuLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            (
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ) ||
            (
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ) )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlConcealBabysWallLookback( )
   {
      return (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) + 3;
   }
   public RetCode cdlConcealBabysWall( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []ShadowVeryShortPeriodTotal = new double[4] ;
      int i, outIdx, totIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlConcealBabysWallLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal[3] = 0;
      ShadowVeryShortPeriodTotal[2] = 0;
      ShadowVeryShortPeriodTotal[1] = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal[3] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) == -1 &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[3] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[3] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[2] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[2] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inHigh[i-1] > inClose[i-2] &&
            inHigh[i] > inHigh[i-1] && inLow[i] < inLow[i-1]
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 3; totIdx >= 1; --totIdx)
            ShadowVeryShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-totIdx] - inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inClose[ShadowVeryShortTrailingIdx-totIdx] : inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inOpen[ShadowVeryShortTrailingIdx-totIdx] : inClose[ShadowVeryShortTrailingIdx-totIdx] ) - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         i++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlConcealBabysWallStateInit( struct TA_cdlConcealBabysWall_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlConcealBabysWall ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlConcealBabysWallLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLCONCEALBABYSWALL_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlConcealBabysWallState( struct TA_cdlConcealBabysWall_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      unsigned int i1,i2,i3;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .ShadowVeryShortPeriodTotal1 = 0.;
         _state.value .ShadowVeryShortPeriodTotal2 = 0.;
         _state.value .ShadowVeryShortPeriodTotal3 = 0.;
         _state.value .periodShadowVeryShort = (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
      i3 = (( _state.value .mem_index-1+-3)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? 1 : -1 ) == -1 &&
            ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) == -1 &&
            ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == -1 &&
            ( inClose >= inOpen ? 1 : -1 ) == -1 &&
            ( ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? ( _state.value .memory+i3).value .inOpen : ( _state.value .memory+i3).value .inClose ) - ( _state.value .memory+i3).value .inLow ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal3 / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i3).value .inClose - ( _state.value .memory+i3).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i3).value .inHigh - ( _state.value .memory+i3).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i3).value .inHigh - ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? ( _state.value .memory+i3).value .inClose : ( _state.value .memory+i3).value .inOpen ) ) + ( ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? ( _state.value .memory+i3).value .inOpen : ( _state.value .memory+i3).value .inClose ) - ( _state.value .memory+i3).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( _state.value .memory+i3).value .inHigh - ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? ( _state.value .memory+i3).value .inClose : ( _state.value .memory+i3).value .inOpen ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal3 / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i3).value .inClose - ( _state.value .memory+i3).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i3).value .inHigh - ( _state.value .memory+i3).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i3).value .inHigh - ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? ( _state.value .memory+i3).value .inClose : ( _state.value .memory+i3).value .inOpen ) ) + ( ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? ( _state.value .memory+i3).value .inOpen : ( _state.value .memory+i3).value .inClose ) - ( _state.value .memory+i3).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal2 / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal2 / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ((( ( _state.value .memory+i1).value .inOpen ) > ( ( _state.value .memory+i1).value .inClose )) ? ( ( _state.value .memory+i1).value .inOpen ) : ( ( _state.value .memory+i1).value .inClose )) < ((( ( _state.value .memory+i2).value .inOpen ) < ( ( _state.value .memory+i2).value .inClose )) ? ( ( _state.value .memory+i2).value .inOpen ) : ( ( _state.value .memory+i2).value .inClose )) ) &&
            ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal1 / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( _state.value .memory+i1).value .inHigh > ( _state.value .memory+i2).value .inClose &&
            inHigh > ( _state.value .memory+i1).value .inHigh && inLow < ( _state.value .memory+i1).value .inLow
            )
            outInteger.value = 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= 3)
      {
         _state.value .ShadowVeryShortPeriodTotal3 += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i3).value .inClose - ( _state.value .memory+i3).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i3).value .inHigh - ( _state.value .memory+i3).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i3).value .inHigh - ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? ( _state.value .memory+i3).value .inClose : ( _state.value .memory+i3).value .inOpen ) ) + ( ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? ( _state.value .memory+i3).value .inOpen : ( _state.value .memory+i3).value .inClose ) - ( _state.value .memory+i3).value .inLow ) : 0 ) ) ) ;
         _state.value .ShadowVeryShortPeriodTotal2 += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
         _state.value .ShadowVeryShortPeriodTotal1 += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .ShadowVeryShortPeriodTotal3 -= ( - _state.value .periodShadowVeryShort-3!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-3)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-3)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-3)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-3)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-3)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-3)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-3)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-3)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-3)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-3)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-3)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-3)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-3)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-3)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowVeryShortPeriodTotal2 -= ( - _state.value .periodShadowVeryShort-2!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowVeryShortPeriodTotal1 -= ( - _state.value .periodShadowVeryShort-1!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlConcealBabysWallStateFree( struct TA_cdlConcealBabysWall_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlConcealBabysWallStateSave( struct TA_cdlConcealBabysWall_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLCONCEALBABYSWALL_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal1,sizeof( _state.value .ShadowVeryShortPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal2,sizeof( _state.value .ShadowVeryShortPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal3,sizeof( _state.value .ShadowVeryShortPeriodTotal3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowVeryShort,sizeof( _state.value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlConcealBabysWallStateLoad( struct TA_cdlConcealBabysWall_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlConcealBabysWall ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLCONCEALBABYSWALL_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLCONCEALBABYSWALL_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal1,sizeof( _state.value .value .ShadowVeryShortPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal2,sizeof( _state.value .value .ShadowVeryShortPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal3,sizeof( _state.value .value .ShadowVeryShortPeriodTotal3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowVeryShort,sizeof( _state.value .value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlConcealBabysWall( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []ShadowVeryShortPeriodTotal = new double[4] ;
      int i, outIdx, totIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlConcealBabysWallLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal[3] = 0;
      ShadowVeryShortPeriodTotal[2] = 0;
      ShadowVeryShortPeriodTotal[1] = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal[3] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) == -1 &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[3] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[3] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[2] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[2] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inHigh[i-1] > inClose[i-2] &&
            inHigh[i] > inHigh[i-1] && inLow[i] < inLow[i-1]
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 3; totIdx >= 1; --totIdx)
            ShadowVeryShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-totIdx] - inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inClose[ShadowVeryShortTrailingIdx-totIdx] : inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inOpen[ShadowVeryShortTrailingIdx-totIdx] : inClose[ShadowVeryShortTrailingIdx-totIdx] ) - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         i++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlCounterAttackLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) +
         1;
   }
   public RetCode cdlCounterAttack( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double EqualPeriodTotal;
      double []BodyLongPeriodTotal = new double[2] ;
      int i, outIdx, totIdx, EqualTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlCounterAttackLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      EqualPeriodTotal = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal[1] = 0;
      BodyLongPeriodTotal[0] = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         BodyLongPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == - ( inClose[i] >= inOpen[i] ? 1 : -1 ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[1] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[0] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] <= inClose[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] >= inClose[i-1] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-1] - inOpen[EqualTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-1] - inLow[EqualTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-1] - ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inClose[EqualTrailingIdx-1] : inOpen[EqualTrailingIdx-1] ) ) + ( ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inOpen[EqualTrailingIdx-1] : inClose[EqualTrailingIdx-1] ) - inLow[EqualTrailingIdx-1] ) : 0 ) ) ) ;
         for (totIdx = 1; totIdx >= 0; --totIdx)
            BodyLongPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-totIdx] - inOpen[BodyLongTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-totIdx] - inLow[BodyLongTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-totIdx] - ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inClose[BodyLongTrailingIdx-totIdx] : inOpen[BodyLongTrailingIdx-totIdx] ) ) + ( ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inOpen[BodyLongTrailingIdx-totIdx] : inClose[BodyLongTrailingIdx-totIdx] ) - inLow[BodyLongTrailingIdx-totIdx] ) : 0 ) ) ) ;
         i++;
         EqualTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlCounterAttackStateInit( struct TA_cdlCounterAttack_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlCounterAttack ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlCounterAttackLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLCOUNTERATTACK_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlCounterAttackState( struct TA_cdlCounterAttack_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      unsigned int i1;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyLongPeriodTotal1 = 0.;
         _state.value .BodyLongPeriodTotal0 = 0.;
         _state.value .EqualPeriodTotal = 0.;
         _state.value .periodEqual = (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
         _state.value .periodBodyLong = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
         _state.value .gapEqual = _state.value .mem_size - _state.value .periodEqual;
         _state.value .gapBodyLong = _state.value .mem_size - _state.value .periodBodyLong;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == - ( inClose >= inOpen ? 1 : -1 ) &&
            ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal1 / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose - inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal0 / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose <= ( _state.value .memory+i1).value .inClose + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? _state.value .EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose >= ( _state.value .memory+i1).value .inClose - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? _state.value .EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger.value = ( inClose >= inOpen ? 1 : -1 ) * 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapEqual)
      {
         _state.value .EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyLong)
      {
         _state.value .BodyLongPeriodTotal1 += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
         _state.value .BodyLongPeriodTotal0 += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .EqualPeriodTotal -= ( - _state.value .periodEqual-1!=0?( ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyLongPeriodTotal1 -= ( - _state.value .periodBodyLong-1!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyLongPeriodTotal0 -= ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlCounterAttackStateFree( struct TA_cdlCounterAttack_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlCounterAttackStateSave( struct TA_cdlCounterAttack_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLCOUNTERATTACK_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyLongPeriodTotal0,sizeof( _state.value .BodyLongPeriodTotal0),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyLongPeriodTotal1,sizeof( _state.value .BodyLongPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .EqualPeriodTotal,sizeof( _state.value .EqualPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyLong,sizeof( _state.value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyLong,sizeof( _state.value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodEqual,sizeof( _state.value .periodEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapEqual,sizeof( _state.value .gapEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlCounterAttackStateLoad( struct TA_cdlCounterAttack_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlCounterAttack ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLCOUNTERATTACK_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLCOUNTERATTACK_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyLongPeriodTotal0,sizeof( _state.value .value .BodyLongPeriodTotal0),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyLongPeriodTotal1,sizeof( _state.value .value .BodyLongPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .EqualPeriodTotal,sizeof( _state.value .value .EqualPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyLong,sizeof( _state.value .value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyLong,sizeof( _state.value .value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodEqual,sizeof( _state.value .value .periodEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapEqual,sizeof( _state.value .value .gapEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlCounterAttack( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double EqualPeriodTotal;
      double []BodyLongPeriodTotal = new double[2] ;
      int i, outIdx, totIdx, EqualTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlCounterAttackLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      EqualPeriodTotal = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal[1] = 0;
      BodyLongPeriodTotal[0] = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         BodyLongPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == - ( inClose[i] >= inOpen[i] ? 1 : -1 ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[1] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[0] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] <= inClose[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] >= inClose[i-1] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-1] - inOpen[EqualTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-1] - inLow[EqualTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-1] - ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inClose[EqualTrailingIdx-1] : inOpen[EqualTrailingIdx-1] ) ) + ( ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inOpen[EqualTrailingIdx-1] : inClose[EqualTrailingIdx-1] ) - inLow[EqualTrailingIdx-1] ) : 0 ) ) ) ;
         for (totIdx = 1; totIdx >= 0; --totIdx)
            BodyLongPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-totIdx] - inOpen[BodyLongTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-totIdx] - inLow[BodyLongTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-totIdx] - ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inClose[BodyLongTrailingIdx-totIdx] : inOpen[BodyLongTrailingIdx-totIdx] ) ) + ( ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inOpen[BodyLongTrailingIdx-totIdx] : inClose[BodyLongTrailingIdx-totIdx] ) - inLow[BodyLongTrailingIdx-totIdx] ) : 0 ) ) ) ;
         i++;
         EqualTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlDarkCloudCoverLookback( double optInPenetration )
   {
      if( optInPenetration == (-4e+37) )
         optInPenetration = 5.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return -1;
      return (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) + 1;
   }
   public RetCode cdlDarkCloudCover( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      double optInPenetration,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyLongPeriodTotal;
      int i, outIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 5.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      lookbackTotal = cdlDarkCloudCoverLookback (optInPenetration);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inOpen[i] > inHigh[i-1] &&
            inClose[i] > inOpen[i-1] &&
            inClose[i] < inClose[i-1] - ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) * optInPenetration
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-1] - inOpen[BodyLongTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-1] - inLow[BodyLongTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-1] - ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inClose[BodyLongTrailingIdx-1] : inOpen[BodyLongTrailingIdx-1] ) ) + ( ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inOpen[BodyLongTrailingIdx-1] : inClose[BodyLongTrailingIdx-1] ) - inLow[BodyLongTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlDarkCloudCoverStateInit( struct TA_cdlDarkCloudCover_State** _state,
      double optInPenetration )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 5.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlDarkCloudCover ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInPenetration = optInPenetration;
      _state.value .value .mem_size = cdlDarkCloudCoverLookback (optInPenetration );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLDARKCLOUDCOVER_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlDarkCloudCoverState( struct TA_cdlDarkCloudCover_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyLongPeriodTotal = 0.;
         _state.value .periodBodyLong = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == 1 &&
            ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose >= inOpen ? 1 : -1 ) == -1 &&
            inOpen > ( _state.value .memory+i1).value .inHigh &&
            inClose > ( _state.value .memory+i1).value .inOpen &&
            inClose < ( _state.value .memory+i1).value .inClose - ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) * _state.value .optInPenetration
            )
            outInteger.value = -100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= 1)
      {
         _state.value .BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .BodyLongPeriodTotal -= ( - _state.value .periodBodyLong-1!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlDarkCloudCoverStateFree( struct TA_cdlDarkCloudCover_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlDarkCloudCoverStateSave( struct TA_cdlDarkCloudCover_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLDARKCLOUDCOVER_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInPenetration,sizeof( _state.value .optInPenetration),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyLongPeriodTotal,sizeof( _state.value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyLong,sizeof( _state.value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlDarkCloudCoverStateLoad( struct TA_cdlDarkCloudCover_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlDarkCloudCover ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLDARKCLOUDCOVER_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLDARKCLOUDCOVER_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInPenetration,sizeof( _state.value .value .optInPenetration),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyLongPeriodTotal,sizeof( _state.value .value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyLong,sizeof( _state.value .value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlDarkCloudCover( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      double optInPenetration,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyLongPeriodTotal;
      int i, outIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 5.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      lookbackTotal = cdlDarkCloudCoverLookback (optInPenetration);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inOpen[i] > inHigh[i-1] &&
            inClose[i] > inOpen[i-1] &&
            inClose[i] < inClose[i-1] - ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) * optInPenetration
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-1] - inOpen[BodyLongTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-1] - inLow[BodyLongTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-1] - ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inClose[BodyLongTrailingIdx-1] : inOpen[BodyLongTrailingIdx-1] ) ) + ( ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inOpen[BodyLongTrailingIdx-1] : inClose[BodyLongTrailingIdx-1] ) - inLow[BodyLongTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlDojiLookback( )
   {
      return (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
   }
   public RetCode cdlDoji( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlDojiLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyDojiPeriodTotal = 0;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyDojiTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlDojiStateInit( struct TA_cdlDoji_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlDoji ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlDojiLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLDOJI_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlDojiState( struct TA_cdlDoji_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyDojiPeriodTotal = 0.;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( Math.abs ( inClose - inOpen ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? _state.value .BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            outInteger.value = 100;
         else
            outInteger.value = 0;
      }
      _state.value .BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .BodyDojiPeriodTotal -= ( - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) !=0?( ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      if ( _state.value .mem_size > 0)
      {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlDojiStateFree( struct TA_cdlDoji_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlDojiStateSave( struct TA_cdlDoji_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLDOJI_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyDojiPeriodTotal,sizeof( _state.value .BodyDojiPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlDojiStateLoad( struct TA_cdlDoji_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlDoji ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLDOJI_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLDOJI_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyDojiPeriodTotal,sizeof( _state.value .value .BodyDojiPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlDoji( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlDojiLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyDojiPeriodTotal = 0;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyDojiTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlDojiStarLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) + 1;
   }
   public RetCode cdlDojiStar( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlDojiStarLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyDojiPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-1 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 && ( (((inOpen[i]) < (inClose[i])) ? (inOpen[i]) : (inClose[i])) > (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) ) )
            ||
            ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 && ( (((inOpen[i]) > (inClose[i])) ? (inOpen[i]) : (inClose[i])) < (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) ) )
            ) )
            outInteger[outIdx++] = - ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyDojiTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlDojiStarStateInit( struct TA_cdlDojiStar_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlDojiStar ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlDojiStarLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLDOJISTAR_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlDojiStarState( struct TA_cdlDojiStar_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyLongPeriodTotal = 0.;
         _state.value .DojiPeriodTotal = 0.;
         _state.value .periodDoji = (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
         _state.value .periodBodyLong = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) +1;
         _state.value .gapDoji = _state.value .mem_size - _state.value .periodDoji;
         _state.value .gapBodyLong = _state.value .mem_size - _state.value .periodBodyLong+1;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      if( ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
         ( Math.abs ( inClose - inOpen ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? _state.value .DojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
         ( ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == 1 && ( (((inOpen) < (inClose)) ? (inOpen) : (inClose)) > ((( ( _state.value .memory+i1).value .inOpen ) > ( ( _state.value .memory+i1).value .inClose )) ? ( ( _state.value .memory+i1).value .inOpen ) : ( ( _state.value .memory+i1).value .inClose )) ) )
         ||
         ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == -1 && ( (((inOpen) > (inClose)) ? (inOpen) : (inClose)) < ((( ( _state.value .memory+i1).value .inOpen ) < ( ( _state.value .memory+i1).value .inClose )) ? ( ( _state.value .memory+i1).value .inOpen ) : ( ( _state.value .memory+i1).value .inClose )) ) )
         ) )
         outInteger.value = - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) * 100;
      else
         outInteger.value = 0;
      if ((int) _state.value .mem_index-1 >= _state.value .gapDoji)
      {
         _state.value .DojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyLong)
      {
         _state.value .BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .DojiPeriodTotal -= ( - _state.value .periodDoji!=0?( ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodDoji)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodDoji)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodDoji)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodDoji)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodDoji)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodDoji)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodDoji)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodDoji)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodDoji)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodDoji)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodDoji)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodDoji)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodDoji)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodDoji)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyLongPeriodTotal -= ( - _state.value .periodBodyLong!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlDojiStarStateFree( struct TA_cdlDojiStar_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlDojiStarStateSave( struct TA_cdlDojiStar_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLDOJISTAR_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .DojiPeriodTotal,sizeof( _state.value .DojiPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyLongPeriodTotal,sizeof( _state.value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyLong,sizeof( _state.value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyLong,sizeof( _state.value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodDoji,sizeof( _state.value .periodDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapDoji,sizeof( _state.value .gapDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlDojiStarStateLoad( struct TA_cdlDojiStar_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlDojiStar ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLDOJISTAR_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLDOJISTAR_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .DojiPeriodTotal,sizeof( _state.value .value .DojiPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyLongPeriodTotal,sizeof( _state.value .value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyLong,sizeof( _state.value .value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyLong,sizeof( _state.value .value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodDoji,sizeof( _state.value .value .periodDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapDoji,sizeof( _state.value .value .gapDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlDojiStar( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlDojiStarLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyDojiPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-1 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 && ( (((inOpen[i]) < (inClose[i])) ? (inOpen[i]) : (inClose[i])) > (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) ) )
            ||
            ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 && ( (((inOpen[i]) > (inClose[i])) ? (inOpen[i]) : (inClose[i])) < (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) ) )
            ) )
            outInteger[outIdx++] = - ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyDojiTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlDragonflyDojiLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ;
   }
   public RetCode cdlDragonflyDoji( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlDragonflyDojiLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyDojiPeriodTotal = 0;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyDojiTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlDragonflyDojiStateInit( struct TA_cdlDragonflyDoji_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlDragonflyDoji ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlDragonflyDojiLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLDRAGONFLYDOJI_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlDragonflyDojiState( struct TA_cdlDragonflyDoji_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .ShadowVeryShortPeriodTotal = 0.;
         _state.value .BodyDojiPeriodTotal = 0.;
         _state.value .periodBodyDoji = (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
         _state.value .periodShadowVeryShort = (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
         _state.value .gapBodyDoji = _state.value .mem_size - _state.value .periodBodyDoji;
         _state.value .gapShadowVeryShort = _state.value .mem_size - _state.value .periodShadowVeryShort;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( Math.abs ( inClose - inOpen ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? _state.value .BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger.value = 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyDoji)
      {
         _state.value .BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadowVeryShort)
      {
         _state.value .ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .BodyDojiPeriodTotal -= ( - _state.value .periodBodyDoji!=0?( ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowVeryShortPeriodTotal -= ( - _state.value .periodShadowVeryShort!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      if ( _state.value .mem_size > 0)
      {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlDragonflyDojiStateFree( struct TA_cdlDragonflyDoji_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlDragonflyDojiStateSave( struct TA_cdlDragonflyDoji_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLDRAGONFLYDOJI_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyDojiPeriodTotal,sizeof( _state.value .BodyDojiPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal,sizeof( _state.value .ShadowVeryShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowVeryShort,sizeof( _state.value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadowVeryShort,sizeof( _state.value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyDoji,sizeof( _state.value .periodBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyDoji,sizeof( _state.value .gapBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlDragonflyDojiStateLoad( struct TA_cdlDragonflyDoji_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlDragonflyDoji ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLDRAGONFLYDOJI_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLDRAGONFLYDOJI_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyDojiPeriodTotal,sizeof( _state.value .value .BodyDojiPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal,sizeof( _state.value .value .ShadowVeryShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowVeryShort,sizeof( _state.value .value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadowVeryShort,sizeof( _state.value .value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyDoji,sizeof( _state.value .value .periodBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyDoji,sizeof( _state.value .value .gapBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlDragonflyDoji( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlDragonflyDojiLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyDojiPeriodTotal = 0;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyDojiTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlEngulfingLookback( )
   {
      return 2;
   }
   public RetCode cdlEngulfing( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      int i, outIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlEngulfingLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 && ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( ( inClose[i] >= inOpen[i-1] && inOpen[i] < inClose[i-1] ) ||
            ( inClose[i] > inOpen[i-1] && inOpen[i] <= inClose[i-1] )
            )
            )
            ||
            ( ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 && ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( ( inOpen[i] >= inClose[i-1] && inClose[i] < inOpen[i-1] ) ||
            ( inOpen[i] > inClose[i-1] && inClose[i] <= inOpen[i-1] )
            )
            )
            )
            if( inOpen[i] != inClose[i-1] && inClose[i] != inOpen[i-1] )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 80;
         else
            outInteger[outIdx++] = 0;
         i++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlEngulfingStateInit( struct TA_cdlEngulfing_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlEngulfing ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlEngulfingLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLENGULFING_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlEngulfingState( struct TA_cdlEngulfing_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      if( ( ( inClose >= inOpen ? 1 : -1 ) == 1 && ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == -1 &&
         ( ( inClose >= ( _state.value .memory+i1).value .inOpen && inOpen < ( _state.value .memory+i1).value .inClose ) ||
         ( inClose > ( _state.value .memory+i1).value .inOpen && inOpen <= ( _state.value .memory+i1).value .inClose )
         )
         )
         ||
         ( ( inClose >= inOpen ? 1 : -1 ) == -1 && ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == 1 &&
         ( ( inOpen >= ( _state.value .memory+i1).value .inClose && inClose < ( _state.value .memory+i1).value .inOpen ) ||
         ( inOpen > ( _state.value .memory+i1).value .inClose && inClose <= ( _state.value .memory+i1).value .inOpen )
         )
         )
         )
         if( inOpen != ( _state.value .memory+i1).value .inClose && inClose != ( _state.value .memory+i1).value .inOpen )
         outInteger.value = ( inClose >= inOpen ? 1 : -1 ) * 100;
      else
         outInteger.value = ( inClose >= inOpen ? 1 : -1 ) * 80;
      else
         outInteger.value = 0;
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      return RetCode.Success ;
   }
   public RetCode cdlEngulfingStateFree( struct TA_cdlEngulfing_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlEngulfingStateSave( struct TA_cdlEngulfing_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLENGULFING_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode cdlEngulfingStateLoad( struct TA_cdlEngulfing_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlEngulfing ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLENGULFING_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLENGULFING_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode cdlEngulfing( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      int i, outIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlEngulfingLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 && ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( ( inClose[i] >= inOpen[i-1] && inOpen[i] < inClose[i-1] ) ||
            ( inClose[i] > inOpen[i-1] && inOpen[i] <= inClose[i-1] )
            )
            )
            ||
            ( ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 && ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( ( inOpen[i] >= inClose[i-1] && inClose[i] < inOpen[i-1] ) ||
            ( inOpen[i] > inClose[i-1] && inClose[i] <= inOpen[i-1] )
            )
            )
            )
            if( inOpen[i] != inClose[i-1] && inClose[i] != inOpen[i-1] )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 80;
         else
            outInteger[outIdx++] = 0;
         i++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlEveningDojiStarLookback( double optInPenetration )
   {
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return -1;
      return ((( ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) ? ( ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) +
         2;
   }
   public RetCode cdlEveningDojiStar( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      double optInPenetration,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, BodyLongPeriodTotal, BodyShortPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, BodyLongTrailingIdx, BodyShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      lookbackTotal = cdlEveningDojiStarLookback (optInPenetration);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyDojiPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyDojiTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyDojiTrailingIdx;
      while( i < startIdx-1 ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inClose[i] < inClose[i-2] - ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) * optInPenetration
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyDojiTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlEveningDojiStarStateInit( struct TA_cdlEveningDojiStar_State** _state,
      double optInPenetration )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlEveningDojiStar ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInPenetration = optInPenetration;
      _state.value .value .mem_size = cdlEveningDojiStarLookback (optInPenetration );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLEVENINGDOJISTAR_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlEveningDojiStarState( struct TA_cdlEveningDojiStar_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1,i2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyLongPeriodTotal = 0.;
         _state.value .BodyDojiPeriodTotal = 0.;
         _state.value .BodyShortPeriodTotal = 0.;
         _state.value .periodBodyLong = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) +2;
         _state.value .periodBodyDoji = (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) +1;
         _state.value .periodBodyShort = (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
         _state.value .gapBodyLong = _state.value .mem_size - _state.value .periodBodyLong+2;
         _state.value .gapBodyDoji = _state.value .mem_size - _state.value .periodBodyDoji+1;
         _state.value .gapBodyShort = _state.value .mem_size - _state.value .periodBodyShort;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) == 1 &&
            ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? _state.value .BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ((( ( _state.value .memory+i1).value .inOpen ) < ( ( _state.value .memory+i1).value .inClose )) ? ( ( _state.value .memory+i1).value .inOpen ) : ( ( _state.value .memory+i1).value .inClose )) > ((( ( _state.value .memory+i2).value .inOpen ) > ( ( _state.value .memory+i2).value .inClose )) ? ( ( _state.value .memory+i2).value .inOpen ) : ( ( _state.value .memory+i2).value .inClose )) ) &&
            ( Math.abs ( inClose - inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? _state.value .BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose >= inOpen ? 1 : -1 ) == -1 &&
            inClose < ( _state.value .memory+i2).value .inClose - ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) * _state.value .optInPenetration
            )
            outInteger.value = -100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyLong)
      {
         _state.value .BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyDoji)
      {
         _state.value .BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyShort)
      {
         _state.value .BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .BodyLongPeriodTotal -= ( - _state.value .periodBodyLong!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyDojiPeriodTotal -= ( - _state.value .periodBodyDoji!=0?( ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyShortPeriodTotal -= ( - _state.value .periodBodyShort!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlEveningDojiStarStateFree( struct TA_cdlEveningDojiStar_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlEveningDojiStarStateSave( struct TA_cdlEveningDojiStar_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLEVENINGDOJISTAR_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInPenetration,sizeof( _state.value .optInPenetration),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyDojiPeriodTotal,sizeof( _state.value .BodyDojiPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyLongPeriodTotal,sizeof( _state.value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyShortPeriodTotal,sizeof( _state.value .BodyShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyLong,sizeof( _state.value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyLong,sizeof( _state.value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyShort,sizeof( _state.value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyShort,sizeof( _state.value .gapBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyDoji,sizeof( _state.value .periodBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyDoji,sizeof( _state.value .gapBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlEveningDojiStarStateLoad( struct TA_cdlEveningDojiStar_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlEveningDojiStar ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLEVENINGDOJISTAR_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLEVENINGDOJISTAR_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInPenetration,sizeof( _state.value .value .optInPenetration),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyDojiPeriodTotal,sizeof( _state.value .value .BodyDojiPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyLongPeriodTotal,sizeof( _state.value .value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyShortPeriodTotal,sizeof( _state.value .value .BodyShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyLong,sizeof( _state.value .value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyLong,sizeof( _state.value .value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyShort,sizeof( _state.value .value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyShort,sizeof( _state.value .value .gapBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyDoji,sizeof( _state.value .value .periodBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyDoji,sizeof( _state.value .value .gapBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlEveningDojiStar( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      double optInPenetration,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, BodyLongPeriodTotal, BodyShortPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, BodyLongTrailingIdx, BodyShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      lookbackTotal = cdlEveningDojiStarLookback (optInPenetration);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyDojiPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyDojiTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyDojiTrailingIdx;
      while( i < startIdx-1 ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inClose[i] < inClose[i-2] - ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) * optInPenetration
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyDojiTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlEveningStarLookback( double optInPenetration )
   {
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return -1;
      return ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) + 2;
   }
   public RetCode cdlEveningStar( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      double optInPenetration,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyShortPeriodTotal, BodyLongPeriodTotal, BodyShortPeriodTotal2;
      int i, outIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      lookbackTotal = cdlEveningStarLookback (optInPenetration);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyShortPeriodTotal2 = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx-1 ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         BodyShortPeriodTotal2 += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i+1] - inOpen[i+1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i+1] - inLow[i+1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i+1] - ( inClose[i+1] >= inOpen[i+1] ? inClose[i+1] : inOpen[i+1] ) ) + ( ( inClose[i+1] >= inOpen[i+1] ? inOpen[i+1] : inClose[i+1] ) - inLow[i+1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal2 / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inClose[i] < inClose[i-2] - ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) * optInPenetration
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal2 += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx+1] - inOpen[BodyShortTrailingIdx+1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx+1] - inLow[BodyShortTrailingIdx+1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx+1] - ( inClose[BodyShortTrailingIdx+1] >= inOpen[BodyShortTrailingIdx+1] ? inClose[BodyShortTrailingIdx+1] : inOpen[BodyShortTrailingIdx+1] ) ) + ( ( inClose[BodyShortTrailingIdx+1] >= inOpen[BodyShortTrailingIdx+1] ? inOpen[BodyShortTrailingIdx+1] : inClose[BodyShortTrailingIdx+1] ) - inLow[BodyShortTrailingIdx+1] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlEveningStarStateInit( struct TA_cdlEveningStar_State** _state,
      double optInPenetration )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlEveningStar ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInPenetration = optInPenetration;
      _state.value .value .mem_size = cdlEveningStarLookback (optInPenetration );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLEVENINGSTAR_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlEveningStarState( struct TA_cdlEveningStar_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1,i2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyLongPeriodTotal = 0.;
         _state.value .BodyShortPeriodTotal2 = 0.;
         _state.value .BodyShortPeriodTotal = 0.;
         _state.value .periodBodyLong = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) +2;
         _state.value .periodBodyShort = (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) +1;
         _state.value .gapBodyLong = _state.value .mem_size - _state.value .periodBodyLong+2;
         _state.value .gapBodyShort = _state.value .mem_size - _state.value .periodBodyShort+1;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) == 1 &&
            ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? _state.value .BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ((( ( _state.value .memory+i1).value .inOpen ) < ( ( _state.value .memory+i1).value .inClose )) ? ( ( _state.value .memory+i1).value .inOpen ) : ( ( _state.value .memory+i1).value .inClose )) > ((( ( _state.value .memory+i2).value .inOpen ) > ( ( _state.value .memory+i2).value .inClose )) ? ( ( _state.value .memory+i2).value .inOpen ) : ( ( _state.value .memory+i2).value .inClose )) ) &&
            ( Math.abs ( inClose - inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? _state.value .BodyShortPeriodTotal2 / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose >= inOpen ? 1 : -1 ) == -1 &&
            inClose < ( _state.value .memory+i2).value .inClose - ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) * _state.value .optInPenetration
            )
            outInteger.value = -100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyLong)
      {
         _state.value .BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyShort)
      {
         _state.value .BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
         _state.value .BodyShortPeriodTotal2 += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .BodyLongPeriodTotal -= ( - _state.value .periodBodyLong!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyShortPeriodTotal -= ( - _state.value .periodBodyShort!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyShortPeriodTotal2 -= ( (( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) !=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+(( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) )% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+(( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) )% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+(( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) )% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+(( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) )% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+(( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) )% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+(( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) )% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+(( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) )% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+(( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) )% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+(( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) )% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+(( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) )% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+(( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) )% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+(( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) )% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+(( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) )% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+(( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) )% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlEveningStarStateFree( struct TA_cdlEveningStar_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlEveningStarStateSave( struct TA_cdlEveningStar_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLEVENINGSTAR_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInPenetration,sizeof( _state.value .optInPenetration),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyShortPeriodTotal2,sizeof( _state.value .BodyShortPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyLongPeriodTotal,sizeof( _state.value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyShortPeriodTotal,sizeof( _state.value .BodyShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyLong,sizeof( _state.value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyLong,sizeof( _state.value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyShort,sizeof( _state.value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyShort,sizeof( _state.value .gapBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlEveningStarStateLoad( struct TA_cdlEveningStar_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlEveningStar ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLEVENINGSTAR_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLEVENINGSTAR_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInPenetration,sizeof( _state.value .value .optInPenetration),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyShortPeriodTotal2,sizeof( _state.value .value .BodyShortPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyLongPeriodTotal,sizeof( _state.value .value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyShortPeriodTotal,sizeof( _state.value .value .BodyShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyLong,sizeof( _state.value .value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyLong,sizeof( _state.value .value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyShort,sizeof( _state.value .value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyShort,sizeof( _state.value .value .gapBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlEveningStar( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      double optInPenetration,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyShortPeriodTotal, BodyLongPeriodTotal, BodyShortPeriodTotal2;
      int i, outIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      lookbackTotal = cdlEveningStarLookback (optInPenetration);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyShortPeriodTotal2 = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx-1 ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         BodyShortPeriodTotal2 += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i+1] - inOpen[i+1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i+1] - inLow[i+1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i+1] - ( inClose[i+1] >= inOpen[i+1] ? inClose[i+1] : inOpen[i+1] ) ) + ( ( inClose[i+1] >= inOpen[i+1] ? inOpen[i+1] : inClose[i+1] ) - inLow[i+1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal2 / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inClose[i] < inClose[i-2] - ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) * optInPenetration
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal2 += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx+1] - inOpen[BodyShortTrailingIdx+1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx+1] - inLow[BodyShortTrailingIdx+1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx+1] - ( inClose[BodyShortTrailingIdx+1] >= inOpen[BodyShortTrailingIdx+1] ? inClose[BodyShortTrailingIdx+1] : inOpen[BodyShortTrailingIdx+1] ) ) + ( ( inClose[BodyShortTrailingIdx+1] >= inOpen[BodyShortTrailingIdx+1] ? inOpen[BodyShortTrailingIdx+1] : inClose[BodyShortTrailingIdx+1] ) - inLow[BodyShortTrailingIdx+1] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlGapSideSideWhiteLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) )) + 2;
   }
   public RetCode cdlGapSideSideWhite( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double NearPeriodTotal, EqualPeriodTotal;
      int i, outIdx, NearTrailingIdx, EqualTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlGapSideSideWhiteLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      NearPeriodTotal = 0;
      EqualPeriodTotal = 0;
      NearTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      i = NearTrailingIdx;
      while( i < startIdx ) {
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if(
            (
            ( ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) && ( (((inOpen[i]) < (inClose[i])) ? (inOpen[i]) : (inClose[i])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) )
            ||
            ( ( (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) && ( (((inOpen[i]) > (inClose[i])) ? (inOpen[i]) : (inClose[i])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) )
            ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) >= ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] >= inOpen[i-1] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] <= inOpen[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = ( ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) ? 100 : -100 );
         else
            outInteger[outIdx++] = 0;
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-1] - inOpen[NearTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-1] - inLow[NearTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-1] - ( inClose[NearTrailingIdx-1] >= inOpen[NearTrailingIdx-1] ? inClose[NearTrailingIdx-1] : inOpen[NearTrailingIdx-1] ) ) + ( ( inClose[NearTrailingIdx-1] >= inOpen[NearTrailingIdx-1] ? inOpen[NearTrailingIdx-1] : inClose[NearTrailingIdx-1] ) - inLow[NearTrailingIdx-1] ) : 0 ) ) ) ;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-1] - inOpen[EqualTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-1] - inLow[EqualTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-1] - ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inClose[EqualTrailingIdx-1] : inOpen[EqualTrailingIdx-1] ) ) + ( ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inOpen[EqualTrailingIdx-1] : inClose[EqualTrailingIdx-1] ) - inLow[EqualTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         NearTrailingIdx++;
         EqualTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlGapSideSideWhiteStateInit( struct TA_cdlGapSideSideWhite_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlGapSideSideWhite ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlGapSideSideWhiteLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLGAPSIDESIDEWHITE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlGapSideSideWhiteState( struct TA_cdlGapSideSideWhite_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1,i2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .NearPeriodTotal = 0.;
         _state.value .EqualPeriodTotal = 0.;
         _state.value .periodNear = (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
         _state.value .periodEqual = (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if(
            (
            ( ( ((( ( _state.value .memory+i1).value .inOpen ) < ( ( _state.value .memory+i1).value .inClose )) ? ( ( _state.value .memory+i1).value .inOpen ) : ( ( _state.value .memory+i1).value .inClose )) > ((( ( _state.value .memory+i2).value .inOpen ) > ( ( _state.value .memory+i2).value .inClose )) ? ( ( _state.value .memory+i2).value .inOpen ) : ( ( _state.value .memory+i2).value .inClose )) ) && ( (((inOpen) < (inClose)) ? (inOpen) : (inClose)) > ((( ( _state.value .memory+i2).value .inOpen ) > ( ( _state.value .memory+i2).value .inClose )) ? ( ( _state.value .memory+i2).value .inOpen ) : ( ( _state.value .memory+i2).value .inClose )) ) )
            ||
            ( ( ((( ( _state.value .memory+i1).value .inOpen ) > ( ( _state.value .memory+i1).value .inClose )) ? ( ( _state.value .memory+i1).value .inOpen ) : ( ( _state.value .memory+i1).value .inClose )) < ((( ( _state.value .memory+i2).value .inOpen ) < ( ( _state.value .memory+i2).value .inClose )) ? ( ( _state.value .memory+i2).value .inOpen ) : ( ( _state.value .memory+i2).value .inClose )) ) && ( (((inOpen) > (inClose)) ? (inOpen) : (inClose)) < ((( ( _state.value .memory+i2).value .inOpen ) < ( ( _state.value .memory+i2).value .inClose )) ? ( ( _state.value .memory+i2).value .inOpen ) : ( ( _state.value .memory+i2).value .inClose )) ) )
            ) &&
            ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == 1 &&
            ( inClose >= inOpen ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose - inOpen ) ) >= ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? _state.value .NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose - inOpen ) ) <= ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? _state.value .NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen >= ( _state.value .memory+i1).value .inOpen - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? _state.value .EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen <= ( _state.value .memory+i1).value .inOpen + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? _state.value .EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger.value = ( ( ((( ( _state.value .memory+i1).value .inOpen ) < ( ( _state.value .memory+i1).value .inClose )) ? ( ( _state.value .memory+i1).value .inOpen ) : ( ( _state.value .memory+i1).value .inClose )) > ((( ( _state.value .memory+i2).value .inOpen ) > ( ( _state.value .memory+i2).value .inClose )) ? ( ( _state.value .memory+i2).value .inOpen ) : ( ( _state.value .memory+i2).value .inClose )) ) ? 100 : -100 );
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .mem_size - _state.value .periodNear)
      {
         _state.value .NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .mem_size - _state.value .periodEqual)
      {
         _state.value .EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .NearPeriodTotal -= ( - _state.value .periodNear -1!=0?( ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear -1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear -1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear -1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear -1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear -1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear -1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear -1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear -1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear -1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear -1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear -1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear -1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear -1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear -1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .EqualPeriodTotal -= ( - _state.value .periodEqual -1!=0?( ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      if ( _state.value .mem_size > 0)
      {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlGapSideSideWhiteStateFree( struct TA_cdlGapSideSideWhite_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlGapSideSideWhiteStateSave( struct TA_cdlGapSideSideWhite_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLGAPSIDESIDEWHITE_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .NearPeriodTotal,sizeof( _state.value .NearPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .EqualPeriodTotal,sizeof( _state.value .EqualPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodNear,sizeof( _state.value .periodNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodEqual,sizeof( _state.value .periodEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlGapSideSideWhiteStateLoad( struct TA_cdlGapSideSideWhite_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlGapSideSideWhite ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLGAPSIDESIDEWHITE_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLGAPSIDESIDEWHITE_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .NearPeriodTotal,sizeof( _state.value .value .NearPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .EqualPeriodTotal,sizeof( _state.value .value .EqualPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodNear,sizeof( _state.value .value .periodNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodEqual,sizeof( _state.value .value .periodEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlGapSideSideWhite( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double NearPeriodTotal, EqualPeriodTotal;
      int i, outIdx, NearTrailingIdx, EqualTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlGapSideSideWhiteLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      NearPeriodTotal = 0;
      EqualPeriodTotal = 0;
      NearTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      i = NearTrailingIdx;
      while( i < startIdx ) {
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if(
            (
            ( ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) && ( (((inOpen[i]) < (inClose[i])) ? (inOpen[i]) : (inClose[i])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) )
            ||
            ( ( (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) && ( (((inOpen[i]) > (inClose[i])) ? (inOpen[i]) : (inClose[i])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) )
            ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) >= ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] >= inOpen[i-1] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] <= inOpen[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = ( ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) ? 100 : -100 );
         else
            outInteger[outIdx++] = 0;
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-1] - inOpen[NearTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-1] - inLow[NearTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-1] - ( inClose[NearTrailingIdx-1] >= inOpen[NearTrailingIdx-1] ? inClose[NearTrailingIdx-1] : inOpen[NearTrailingIdx-1] ) ) + ( ( inClose[NearTrailingIdx-1] >= inOpen[NearTrailingIdx-1] ? inOpen[NearTrailingIdx-1] : inClose[NearTrailingIdx-1] ) - inLow[NearTrailingIdx-1] ) : 0 ) ) ) ;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-1] - inOpen[EqualTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-1] - inLow[EqualTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-1] - ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inClose[EqualTrailingIdx-1] : inOpen[EqualTrailingIdx-1] ) ) + ( ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inOpen[EqualTrailingIdx-1] : inClose[EqualTrailingIdx-1] ) - inLow[EqualTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         NearTrailingIdx++;
         EqualTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlGravestoneDojiLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ;
   }
   public RetCode cdlGravestoneDoji( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlGravestoneDojiLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyDojiPeriodTotal = 0;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyDojiTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlGravestoneDojiStateInit( struct TA_cdlGravestoneDoji_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlGravestoneDoji ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlGravestoneDojiLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLGRAVESTONEDOJI_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlGravestoneDojiState( struct TA_cdlGravestoneDoji_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .ShadowVeryShortPeriodTotal = 0.;
         _state.value .BodyDojiPeriodTotal = 0.;
         _state.value .periodBodyDoji = (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
         _state.value .periodShadowVeryShort = (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
         _state.value .gapBodyDoji = _state.value .mem_size - _state.value .periodBodyDoji;
         _state.value .gapShadowVeryShort = _state.value .mem_size - _state.value .periodShadowVeryShort;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( Math.abs ( inClose - inOpen ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? _state.value .BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger.value = 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyDoji)
      {
         _state.value .BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadowVeryShort)
      {
         _state.value .ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .BodyDojiPeriodTotal -= ( - _state.value .periodBodyDoji!=0?( ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowVeryShortPeriodTotal -= ( - _state.value .periodShadowVeryShort!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      if ( _state.value .mem_size > 0)
      {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlGravestoneDojiStateFree( struct TA_cdlGravestoneDoji_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlGravestoneDojiStateSave( struct TA_cdlGravestoneDoji_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLGRAVESTONEDOJI_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyDojiPeriodTotal,sizeof( _state.value .BodyDojiPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal,sizeof( _state.value .ShadowVeryShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowVeryShort,sizeof( _state.value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadowVeryShort,sizeof( _state.value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyDoji,sizeof( _state.value .periodBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyDoji,sizeof( _state.value .gapBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlGravestoneDojiStateLoad( struct TA_cdlGravestoneDoji_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlGravestoneDoji ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLGRAVESTONEDOJI_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLGRAVESTONEDOJI_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyDojiPeriodTotal,sizeof( _state.value .value .BodyDojiPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal,sizeof( _state.value .value .ShadowVeryShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowVeryShort,sizeof( _state.value .value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadowVeryShort,sizeof( _state.value .value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyDoji,sizeof( _state.value .value .periodBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyDoji,sizeof( _state.value .value .gapBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlGravestoneDoji( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlGravestoneDojiLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyDojiPeriodTotal = 0;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyDojiTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlHammerLookback( )
   {
      return ((( ((( ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ? ( ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ) > ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) ? ( ((( ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ? ( ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) +
         1;
   }
   public RetCode cdlHammer( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal, ShadowLongPeriodTotal, ShadowVeryShortPeriodTotal, NearPeriodTotal;
      int i, outIdx, BodyTrailingIdx, ShadowLongTrailingIdx, ShadowVeryShortTrailingIdx, NearTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHammerLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      NearPeriodTotal = 0;
      NearTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = NearTrailingIdx;
      while( i < startIdx-1 ) {
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (((inClose[i]) < (inOpen[i])) ? (inClose[i]) : (inOpen[i])) <= inLow[i-1] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx] - inOpen[ShadowLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx] - inLow[ShadowLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx] - ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inClose[ShadowLongTrailingIdx] : inOpen[ShadowLongTrailingIdx] ) ) + ( ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inOpen[ShadowLongTrailingIdx] : inClose[ShadowLongTrailingIdx] ) - inLow[ShadowLongTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx] - inOpen[NearTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx] - inLow[NearTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx] - ( inClose[NearTrailingIdx] >= inOpen[NearTrailingIdx] ? inClose[NearTrailingIdx] : inOpen[NearTrailingIdx] ) ) + ( ( inClose[NearTrailingIdx] >= inOpen[NearTrailingIdx] ? inOpen[NearTrailingIdx] : inClose[NearTrailingIdx] ) - inLow[NearTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
         ShadowLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
         NearTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlHammerStateInit( struct TA_cdlHammer_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlHammer ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlHammerLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLHAMMER_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlHammerState( struct TA_cdlHammer_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyPeriodTotal = 0.;
         _state.value .ShadowLongPeriodTotal = 0.;
         _state.value .ShadowVeryShortPeriodTotal = 0.;
         _state.value .NearPeriodTotal = 0.;
         _state.value .periodBody = (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
         _state.value .periodNear = (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) +1;
         _state.value .periodShadowVeryShort = (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
         _state.value .periodShadowLong = (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
         _state.value .gapShadowLong = _state.value .mem_size - _state.value .periodShadowLong;
         _state.value .gapNear = _state.value .mem_size - _state.value .periodNear+1;
         _state.value .gapShadowVeryShort = _state.value .mem_size - _state.value .periodShadowVeryShort;
         _state.value .gapBody = _state.value .mem_size - _state.value .periodBody;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( Math.abs ( inClose - inOpen ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? _state.value .BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? _state.value .ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (((inClose) < (inOpen)) ? (inClose) : (inOpen)) <= ( _state.value .memory+i1).value .inLow + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? _state.value .NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger.value = 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadowVeryShort)
      {
         _state.value .ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapNear)
      {
         _state.value .NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadowLong)
      {
         _state.value .ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBody)
      {
         _state.value .BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .ShadowVeryShortPeriodTotal -= ( - _state.value .periodShadowVeryShort!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowLongPeriodTotal -= ( - _state.value .periodShadowLong!=0?( ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .NearPeriodTotal -= ( - _state.value .periodNear!=0?( ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyPeriodTotal -= ( - _state.value .periodBody!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlHammerStateFree( struct TA_cdlHammer_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlHammerStateSave( struct TA_cdlHammer_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLHAMMER_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyPeriodTotal,sizeof( _state.value .BodyPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal,sizeof( _state.value .ShadowVeryShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowLongPeriodTotal,sizeof( _state.value .ShadowLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .NearPeriodTotal,sizeof( _state.value .NearPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowVeryShort,sizeof( _state.value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadowVeryShort,sizeof( _state.value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBody,sizeof( _state.value .periodBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBody,sizeof( _state.value .gapBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowLong,sizeof( _state.value .periodShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadowLong,sizeof( _state.value .gapShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodNear,sizeof( _state.value .periodNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapNear,sizeof( _state.value .gapNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlHammerStateLoad( struct TA_cdlHammer_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlHammer ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLHAMMER_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLHAMMER_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyPeriodTotal,sizeof( _state.value .value .BodyPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal,sizeof( _state.value .value .ShadowVeryShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowLongPeriodTotal,sizeof( _state.value .value .ShadowLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .NearPeriodTotal,sizeof( _state.value .value .NearPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowVeryShort,sizeof( _state.value .value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadowVeryShort,sizeof( _state.value .value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBody,sizeof( _state.value .value .periodBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBody,sizeof( _state.value .value .gapBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowLong,sizeof( _state.value .value .periodShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadowLong,sizeof( _state.value .value .gapShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodNear,sizeof( _state.value .value .periodNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapNear,sizeof( _state.value .value .gapNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlHammer( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal, ShadowLongPeriodTotal, ShadowVeryShortPeriodTotal, NearPeriodTotal;
      int i, outIdx, BodyTrailingIdx, ShadowLongTrailingIdx, ShadowVeryShortTrailingIdx, NearTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHammerLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      NearPeriodTotal = 0;
      NearTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = NearTrailingIdx;
      while( i < startIdx-1 ) {
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (((inClose[i]) < (inOpen[i])) ? (inClose[i]) : (inOpen[i])) <= inLow[i-1] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx] - inOpen[ShadowLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx] - inLow[ShadowLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx] - ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inClose[ShadowLongTrailingIdx] : inOpen[ShadowLongTrailingIdx] ) ) + ( ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inOpen[ShadowLongTrailingIdx] : inClose[ShadowLongTrailingIdx] ) - inLow[ShadowLongTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx] - inOpen[NearTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx] - inLow[NearTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx] - ( inClose[NearTrailingIdx] >= inOpen[NearTrailingIdx] ? inClose[NearTrailingIdx] : inOpen[NearTrailingIdx] ) ) + ( ( inClose[NearTrailingIdx] >= inOpen[NearTrailingIdx] ? inOpen[NearTrailingIdx] : inClose[NearTrailingIdx] ) - inLow[NearTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
         ShadowLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
         NearTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlHangingManLookback( )
   {
      return ((( ((( ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ? ( ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ) > ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) ? ( ((( ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ? ( ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) +
         1;
   }
   public RetCode cdlHangingMan( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal, ShadowLongPeriodTotal, ShadowVeryShortPeriodTotal, NearPeriodTotal;
      int i, outIdx, BodyTrailingIdx, ShadowLongTrailingIdx, ShadowVeryShortTrailingIdx, NearTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHangingManLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      NearPeriodTotal = 0;
      NearTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = NearTrailingIdx;
      while( i < startIdx-1 ) {
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (((inClose[i]) < (inOpen[i])) ? (inClose[i]) : (inOpen[i])) >= inHigh[i-1] - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx] - inOpen[ShadowLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx] - inLow[ShadowLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx] - ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inClose[ShadowLongTrailingIdx] : inOpen[ShadowLongTrailingIdx] ) ) + ( ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inOpen[ShadowLongTrailingIdx] : inClose[ShadowLongTrailingIdx] ) - inLow[ShadowLongTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx] - inOpen[NearTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx] - inLow[NearTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx] - ( inClose[NearTrailingIdx] >= inOpen[NearTrailingIdx] ? inClose[NearTrailingIdx] : inOpen[NearTrailingIdx] ) ) + ( ( inClose[NearTrailingIdx] >= inOpen[NearTrailingIdx] ? inOpen[NearTrailingIdx] : inClose[NearTrailingIdx] ) - inLow[NearTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
         ShadowLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
         NearTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlHangingManStateInit( struct TA_cdlHangingMan_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlHangingMan ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlHangingManLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLHANGINGMAN_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlHangingManState( struct TA_cdlHangingMan_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyPeriodTotal = 0.;
         _state.value .ShadowLongPeriodTotal = 0.;
         _state.value .ShadowVeryShortPeriodTotal = 0.;
         _state.value .NearPeriodTotal = 0.;
         _state.value .periodBody = (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
         _state.value .periodNear = (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) +1;
         _state.value .periodShadowVeryShort = (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
         _state.value .periodShadowLong = (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
         _state.value .gapShadowLong = _state.value .mem_size - _state.value .periodShadowLong;
         _state.value .gapNear = _state.value .mem_size - _state.value .periodNear+1;
         _state.value .gapShadowVeryShort = _state.value .mem_size - _state.value .periodShadowVeryShort;
         _state.value .gapBody = _state.value .mem_size - _state.value .periodBody;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( Math.abs ( inClose - inOpen ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? _state.value .BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? _state.value .ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (((inClose) < (inOpen)) ? (inClose) : (inOpen)) >= ( _state.value .memory+i1).value .inHigh - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? _state.value .NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger.value = -100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadowVeryShort)
      {
         _state.value .ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapNear)
      {
         _state.value .NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadowLong)
      {
         _state.value .ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBody)
      {
         _state.value .BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .ShadowVeryShortPeriodTotal -= ( - _state.value .periodShadowVeryShort!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowLongPeriodTotal -= ( - _state.value .periodShadowLong!=0?( ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .NearPeriodTotal -= ( - _state.value .periodNear!=0?( ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyPeriodTotal -= ( - _state.value .periodBody!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlHangingManStateFree( struct TA_cdlHangingMan_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlHangingManStateSave( struct TA_cdlHangingMan_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLHANGINGMAN_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyPeriodTotal,sizeof( _state.value .BodyPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal,sizeof( _state.value .ShadowVeryShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowLongPeriodTotal,sizeof( _state.value .ShadowLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .NearPeriodTotal,sizeof( _state.value .NearPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowVeryShort,sizeof( _state.value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadowVeryShort,sizeof( _state.value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBody,sizeof( _state.value .periodBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBody,sizeof( _state.value .gapBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowLong,sizeof( _state.value .periodShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadowLong,sizeof( _state.value .gapShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodNear,sizeof( _state.value .periodNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapNear,sizeof( _state.value .gapNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlHangingManStateLoad( struct TA_cdlHangingMan_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlHangingMan ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLHANGINGMAN_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLHANGINGMAN_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyPeriodTotal,sizeof( _state.value .value .BodyPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal,sizeof( _state.value .value .ShadowVeryShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowLongPeriodTotal,sizeof( _state.value .value .ShadowLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .NearPeriodTotal,sizeof( _state.value .value .NearPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowVeryShort,sizeof( _state.value .value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadowVeryShort,sizeof( _state.value .value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBody,sizeof( _state.value .value .periodBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBody,sizeof( _state.value .value .gapBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowLong,sizeof( _state.value .value .periodShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadowLong,sizeof( _state.value .value .gapShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodNear,sizeof( _state.value .value .periodNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapNear,sizeof( _state.value .value .gapNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlHangingMan( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal, ShadowLongPeriodTotal, ShadowVeryShortPeriodTotal, NearPeriodTotal;
      int i, outIdx, BodyTrailingIdx, ShadowLongTrailingIdx, ShadowVeryShortTrailingIdx, NearTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHangingManLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      NearPeriodTotal = 0;
      NearTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = NearTrailingIdx;
      while( i < startIdx-1 ) {
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (((inClose[i]) < (inOpen[i])) ? (inClose[i]) : (inOpen[i])) >= inHigh[i-1] - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx] - inOpen[ShadowLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx] - inLow[ShadowLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx] - ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inClose[ShadowLongTrailingIdx] : inOpen[ShadowLongTrailingIdx] ) ) + ( ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inOpen[ShadowLongTrailingIdx] : inClose[ShadowLongTrailingIdx] ) - inLow[ShadowLongTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx] - inOpen[NearTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx] - inLow[NearTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx] - ( inClose[NearTrailingIdx] >= inOpen[NearTrailingIdx] ? inClose[NearTrailingIdx] : inOpen[NearTrailingIdx] ) ) + ( ( inClose[NearTrailingIdx] >= inOpen[NearTrailingIdx] ? inOpen[NearTrailingIdx] : inClose[NearTrailingIdx] ) - inLow[NearTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
         ShadowLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
         NearTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlHaramiLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) + 1;
   }
   public RetCode cdlHarami( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyShortPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHaramiLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-1 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            if ( (((inClose[i]) > (inOpen[i])) ? (inClose[i]) : (inOpen[i])) < (((inClose[i-1]) > (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) &&
            (((inClose[i]) < (inOpen[i])) ? (inClose[i]) : (inOpen[i])) > (((inClose[i-1]) < (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1]))
            )
            outInteger[outIdx++] = - ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 100;
         else
            if ( (((inClose[i]) > (inOpen[i])) ? (inClose[i]) : (inOpen[i])) <= (((inClose[i-1]) > (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) &&
            (((inClose[i]) < (inOpen[i])) ? (inClose[i]) : (inOpen[i])) >= (((inClose[i-1]) < (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1]))
            )
            outInteger[outIdx++] = - ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 80;
         else
            outInteger[outIdx++] = 0;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlHaramiStateInit( struct TA_cdlHarami_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlHarami ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlHaramiLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLHARAMI_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlHaramiState( struct TA_cdlHarami_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyLongPeriodTotal = 0.;
         _state.value .BodyShortPeriodTotal = 0.;
         _state.value .periodBodyLong = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) +1;
         _state.value .periodBodyShort = (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
         _state.value .gapBodyLong = _state.value .mem_size - _state.value .periodBodyLong+1;
         _state.value .gapBodyShort = _state.value .mem_size - _state.value .periodBodyShort;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose - inOpen ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? _state.value .BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            if ( (((inClose) > (inOpen)) ? (inClose) : (inOpen)) < ((( ( _state.value .memory+i1).value .inClose ) > ( ( _state.value .memory+i1).value .inOpen )) ? ( ( _state.value .memory+i1).value .inClose ) : ( ( _state.value .memory+i1).value .inOpen )) &&
            (((inClose) < (inOpen)) ? (inClose) : (inOpen)) > ((( ( _state.value .memory+i1).value .inClose ) < ( ( _state.value .memory+i1).value .inOpen )) ? ( ( _state.value .memory+i1).value .inClose ) : ( ( _state.value .memory+i1).value .inOpen ))
            )
            outInteger.value = - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) * 100;
         else
            if ( (((inClose) > (inOpen)) ? (inClose) : (inOpen)) <= ((( ( _state.value .memory+i1).value .inClose ) > ( ( _state.value .memory+i1).value .inOpen )) ? ( ( _state.value .memory+i1).value .inClose ) : ( ( _state.value .memory+i1).value .inOpen )) &&
            (((inClose) < (inOpen)) ? (inClose) : (inOpen)) >= ((( ( _state.value .memory+i1).value .inClose ) < ( ( _state.value .memory+i1).value .inOpen )) ? ( ( _state.value .memory+i1).value .inClose ) : ( ( _state.value .memory+i1).value .inOpen ))
            )
            outInteger.value = - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) * 80;
         else
            outInteger.value = 0;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyLong)
      {
         _state.value .BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyShort)
      {
         _state.value .BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .BodyLongPeriodTotal -= ( - _state.value .periodBodyLong!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyShortPeriodTotal -= ( - _state.value .periodBodyShort!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlHaramiStateFree( struct TA_cdlHarami_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlHaramiStateSave( struct TA_cdlHarami_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLHARAMI_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyShortPeriodTotal,sizeof( _state.value .BodyShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyLongPeriodTotal,sizeof( _state.value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyLong,sizeof( _state.value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyLong,sizeof( _state.value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyShort,sizeof( _state.value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyShort,sizeof( _state.value .gapBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlHaramiStateLoad( struct TA_cdlHarami_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlHarami ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLHARAMI_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLHARAMI_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyShortPeriodTotal,sizeof( _state.value .value .BodyShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyLongPeriodTotal,sizeof( _state.value .value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyLong,sizeof( _state.value .value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyLong,sizeof( _state.value .value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyShort,sizeof( _state.value .value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyShort,sizeof( _state.value .value .gapBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlHarami( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyShortPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHaramiLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-1 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            if ( (((inClose[i]) > (inOpen[i])) ? (inClose[i]) : (inOpen[i])) < (((inClose[i-1]) > (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) &&
            (((inClose[i]) < (inOpen[i])) ? (inClose[i]) : (inOpen[i])) > (((inClose[i-1]) < (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1]))
            )
            outInteger[outIdx++] = - ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 100;
         else
            if ( (((inClose[i]) > (inOpen[i])) ? (inClose[i]) : (inOpen[i])) <= (((inClose[i-1]) > (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) &&
            (((inClose[i]) < (inOpen[i])) ? (inClose[i]) : (inOpen[i])) >= (((inClose[i-1]) < (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1]))
            )
            outInteger[outIdx++] = - ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 80;
         else
            outInteger[outIdx++] = 0;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlHaramiCrossLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) + 1;
   }
   public RetCode cdlHaramiCross( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHaramiCrossLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyDojiPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-1 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            if ( (((inClose[i]) > (inOpen[i])) ? (inClose[i]) : (inOpen[i])) < (((inClose[i-1]) > (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) &&
            (((inClose[i]) < (inOpen[i])) ? (inClose[i]) : (inOpen[i])) > (((inClose[i-1]) < (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1]))
            )
            outInteger[outIdx++] = - ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 100;
         else
            if ( (((inClose[i]) > (inOpen[i])) ? (inClose[i]) : (inOpen[i])) <= (((inClose[i-1]) > (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) &&
            (((inClose[i]) < (inOpen[i])) ? (inClose[i]) : (inOpen[i])) >= (((inClose[i-1]) < (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1]))
            )
            outInteger[outIdx++] = - ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 80;
         else
            outInteger[outIdx++] = 0;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyDojiTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlHaramiCrossStateInit( struct TA_cdlHaramiCross_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlHaramiCross ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlHaramiCrossLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLHARAMICROSS_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlHaramiCrossState( struct TA_cdlHaramiCross_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyLongPeriodTotal = 0.;
         _state.value .BodyDojiPeriodTotal = 0.;
         _state.value .periodBodyLong = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) +1;
         _state.value .periodBodyDoji = (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
         _state.value .gapBodyLong = _state.value .mem_size - _state.value .periodBodyLong+1;
         _state.value .gapBodyDoji = _state.value .mem_size - _state.value .periodBodyDoji;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose - inOpen ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? _state.value .BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            if ( (((inClose) > (inOpen)) ? (inClose) : (inOpen)) < ((( ( _state.value .memory+i1).value .inClose ) > ( ( _state.value .memory+i1).value .inOpen )) ? ( ( _state.value .memory+i1).value .inClose ) : ( ( _state.value .memory+i1).value .inOpen )) &&
            (((inClose) < (inOpen)) ? (inClose) : (inOpen)) > ((( ( _state.value .memory+i1).value .inClose ) < ( ( _state.value .memory+i1).value .inOpen )) ? ( ( _state.value .memory+i1).value .inClose ) : ( ( _state.value .memory+i1).value .inOpen ))
            )
            outInteger.value = - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) * 100;
         else
            if ( (((inClose) > (inOpen)) ? (inClose) : (inOpen)) <= ((( ( _state.value .memory+i1).value .inClose ) > ( ( _state.value .memory+i1).value .inOpen )) ? ( ( _state.value .memory+i1).value .inClose ) : ( ( _state.value .memory+i1).value .inOpen )) &&
            (((inClose) < (inOpen)) ? (inClose) : (inOpen)) >= ((( ( _state.value .memory+i1).value .inClose ) < ( ( _state.value .memory+i1).value .inOpen )) ? ( ( _state.value .memory+i1).value .inClose ) : ( ( _state.value .memory+i1).value .inOpen ))
            )
            outInteger.value = - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) * 80;
         else
            outInteger.value = 0;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyLong)
      {
         _state.value .BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyDoji)
      {
         _state.value .BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .BodyLongPeriodTotal -= ( - _state.value .periodBodyLong!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyDojiPeriodTotal -= ( - _state.value .periodBodyDoji!=0?( ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlHaramiCrossStateFree( struct TA_cdlHaramiCross_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlHaramiCrossStateSave( struct TA_cdlHaramiCross_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLHARAMICROSS_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyDojiPeriodTotal,sizeof( _state.value .BodyDojiPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyLongPeriodTotal,sizeof( _state.value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyLong,sizeof( _state.value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyLong,sizeof( _state.value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyDoji,sizeof( _state.value .periodBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyDoji,sizeof( _state.value .gapBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlHaramiCrossStateLoad( struct TA_cdlHaramiCross_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlHaramiCross ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLHARAMICROSS_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLHARAMICROSS_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyDojiPeriodTotal,sizeof( _state.value .value .BodyDojiPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyLongPeriodTotal,sizeof( _state.value .value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyLong,sizeof( _state.value .value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyLong,sizeof( _state.value .value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyDoji,sizeof( _state.value .value .periodBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyDoji,sizeof( _state.value .value .gapBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlHaramiCross( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHaramiCrossLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyDojiPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-1 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            if ( (((inClose[i]) > (inOpen[i])) ? (inClose[i]) : (inOpen[i])) < (((inClose[i-1]) > (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) &&
            (((inClose[i]) < (inOpen[i])) ? (inClose[i]) : (inOpen[i])) > (((inClose[i-1]) < (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1]))
            )
            outInteger[outIdx++] = - ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 100;
         else
            if ( (((inClose[i]) > (inOpen[i])) ? (inClose[i]) : (inOpen[i])) <= (((inClose[i-1]) > (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) &&
            (((inClose[i]) < (inOpen[i])) ? (inClose[i]) : (inOpen[i])) >= (((inClose[i-1]) < (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1]))
            )
            outInteger[outIdx++] = - ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 80;
         else
            outInteger[outIdx++] = 0;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyDojiTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlHignWaveLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) )) ;
   }
   public RetCode cdlHignWave( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal, ShadowPeriodTotal;
      int i, outIdx, BodyTrailingIdx, ShadowTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHignWaveLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      ShadowPeriodTotal = 0;
      ShadowTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowTrailingIdx;
      while( i < startIdx ) {
         ShadowPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) != 0.0? ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) != 0.0? ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         ShadowPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowTrailingIdx] - inOpen[ShadowTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowTrailingIdx] - inLow[ShadowTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowTrailingIdx] - ( inClose[ShadowTrailingIdx] >= inOpen[ShadowTrailingIdx] ? inClose[ShadowTrailingIdx] : inOpen[ShadowTrailingIdx] ) ) + ( ( inClose[ShadowTrailingIdx] >= inOpen[ShadowTrailingIdx] ? inOpen[ShadowTrailingIdx] : inClose[ShadowTrailingIdx] ) - inLow[ShadowTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
         ShadowTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlHignWaveStateInit( struct TA_cdlHignWave_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlHignWave ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlHignWaveLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLHIGHWAVE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlHignWaveState( struct TA_cdlHignWave_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyPeriodTotal = 0.;
         _state.value .ShadowPeriodTotal = 0.;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( Math.abs ( inClose - inOpen ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? _state.value .BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) != 0.0? _state.value .ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) > ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) != 0.0? _state.value .ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            outInteger.value = ( inClose >= inOpen ? 1 : -1 ) * 100;
         else
            outInteger.value = 0;
      }
      _state.value .BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      _state.value .ShadowPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .BodyPeriodTotal -= ( - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) !=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowPeriodTotal -= ( - (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) !=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) )% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      if ( _state.value .mem_size > 0)
      {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlHignWaveStateFree( struct TA_cdlHignWave_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlHignWaveStateSave( struct TA_cdlHignWave_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLHIGHWAVE_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyPeriodTotal,sizeof( _state.value .BodyPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowPeriodTotal,sizeof( _state.value .ShadowPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBody,sizeof( _state.value .periodBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadow,sizeof( _state.value .periodShadow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlHignWaveStateLoad( struct TA_cdlHignWave_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlHignWave ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLHIGHWAVE_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLHIGHWAVE_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyPeriodTotal,sizeof( _state.value .value .BodyPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowPeriodTotal,sizeof( _state.value .value .ShadowPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBody,sizeof( _state.value .value .periodBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadow,sizeof( _state.value .value .periodShadow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlHignWave( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal, ShadowPeriodTotal;
      int i, outIdx, BodyTrailingIdx, ShadowTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHignWaveLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      ShadowPeriodTotal = 0;
      ShadowTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowTrailingIdx;
      while( i < startIdx ) {
         ShadowPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) != 0.0? ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) != 0.0? ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         ShadowPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowTrailingIdx] - inOpen[ShadowTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowTrailingIdx] - inLow[ShadowTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowTrailingIdx] - ( inClose[ShadowTrailingIdx] >= inOpen[ShadowTrailingIdx] ? inClose[ShadowTrailingIdx] : inOpen[ShadowTrailingIdx] ) ) + ( ( inClose[ShadowTrailingIdx] >= inOpen[ShadowTrailingIdx] ? inOpen[ShadowTrailingIdx] : inClose[ShadowTrailingIdx] ) - inLow[ShadowTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
         ShadowTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlHikkakeLookback( )
   {
      return 5;
   }
   public RetCode cdlHikkake( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      int i, outIdx, lookbackTotal, patternIdx, patternResult;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHikkakeLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      patternIdx = 0;
      patternResult = 0;
      i = startIdx - 3;
      while( i < startIdx ) {
         if( inHigh[i-1] < inHigh[i-2] && inLow[i-1] > inLow[i-2] &&
            ( ( inHigh[i] < inHigh[i-1] && inLow[i] < inLow[i-1] )
            ||
            ( inHigh[i] > inHigh[i-1] && inLow[i] > inLow[i-1] )
            )
            ) {
            patternResult = 100 * ( inHigh[i] < inHigh[i-1] ? 1 : -1 );
            patternIdx = i;
         } else
            if( i <= patternIdx+3 &&
            ( ( patternResult > 0 && inClose[i] > inHigh[patternIdx-1] )
            ||
            ( patternResult < 0 && inClose[i] < inLow[patternIdx-1] )
            )
            )
            patternIdx = 0;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( inHigh[i-1] < inHigh[i-2] && inLow[i-1] > inLow[i-2] &&
            ( ( inHigh[i] < inHigh[i-1] && inLow[i] < inLow[i-1] )
            ||
            ( inHigh[i] > inHigh[i-1] && inLow[i] > inLow[i-1] )
            )
            ) {
            patternResult = 100 * ( inHigh[i] < inHigh[i-1] ? 1 : -1 );
            patternIdx = i;
            outInteger[outIdx++] = patternResult;
         } else
            if( i <= patternIdx+3 &&
            ( ( patternResult > 0 && inClose[i] > inHigh[patternIdx-1] )
            ||
            ( patternResult < 0 && inClose[i] < inLow[patternIdx-1] )
            )
            ) {
            outInteger[outIdx++] = patternResult + 100 * ( patternResult > 0 ? 1 : -1 );
            patternIdx = 0;
         } else
            outInteger[outIdx++] = 0;
         i++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlHikkakeStateInit( struct TA_cdlHikkake_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlHikkake ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlHikkakeLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLHIKKAKE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlHikkakeState( struct TA_cdlHikkake_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1,i2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .patternResult = 0.;
         _state.value .patternIdx = 0.;
         _state.value .patternHigh = 0.;
         _state.value .patternLow = 0.;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
      if ( _state.value .mem_index >= 3)
      {
         if( ( _state.value .memory+i1).value .inHigh < ( _state.value .memory+i2).value .inHigh && ( _state.value .memory+i1).value .inLow > ( _state.value .memory+i2).value .inLow &&
            ( ( inHigh < ( _state.value .memory+i1).value .inHigh && inLow < ( _state.value .memory+i1).value .inLow )
            ||
            ( inHigh > ( _state.value .memory+i1).value .inHigh && inLow > ( _state.value .memory+i1).value .inLow )
            )
            )
         {
            _state.value .patternResult = 100 * ( inHigh < ( _state.value .memory+i1).value .inHigh ? 1 : -1 );
            _state.value .patternIdx = _state.value .mem_index-1;
            _state.value .patternHigh = ( _state.value .memory+i1).value .inHigh ;
            _state.value .patternLow = ( _state.value .memory+i1).value .inLow ;
            outInteger.value = _state.value .patternResult;
         } else
            if( (int) _state.value .mem_index-1 <= _state.value .patternIdx+3 &&
            ( ( _state.value .patternResult > 0 && inClose > _state.value .patternHigh )
            ||
            ( _state.value .patternResult < 0 && inClose < _state.value .patternLow )
            )
            )
         {
            outInteger.value = _state.value .patternResult + 100 * ( _state.value .patternResult > 0 ? 1 : -1 );
            _state.value .patternIdx = 0;
         } else
            outInteger.value = 0;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlHikkakeStateFree( struct TA_cdlHikkake_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlHikkakeStateSave( struct TA_cdlHikkake_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLHIKKAKE_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .patternResult,sizeof( _state.value .patternResult),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .patternIdx,sizeof( _state.value .patternIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .patternHigh,sizeof( _state.value .patternHigh),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .patternLow,sizeof( _state.value .patternLow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlHikkakeStateLoad( struct TA_cdlHikkake_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlHikkake ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLHIKKAKE_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLHIKKAKE_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .patternResult,sizeof( _state.value .value .patternResult),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .patternIdx,sizeof( _state.value .value .patternIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .patternHigh,sizeof( _state.value .value .patternHigh),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .patternLow,sizeof( _state.value .value .patternLow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlHikkake( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      int i, outIdx, lookbackTotal, patternIdx, patternResult;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHikkakeLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      patternIdx = 0;
      patternResult = 0;
      i = startIdx - 3;
      while( i < startIdx ) {
         if( inHigh[i-1] < inHigh[i-2] && inLow[i-1] > inLow[i-2] &&
            ( ( inHigh[i] < inHigh[i-1] && inLow[i] < inLow[i-1] )
            ||
            ( inHigh[i] > inHigh[i-1] && inLow[i] > inLow[i-1] )
            )
            ) {
            patternResult = 100 * ( inHigh[i] < inHigh[i-1] ? 1 : -1 );
            patternIdx = i;
         } else
            if( i <= patternIdx+3 &&
            ( ( patternResult > 0 && inClose[i] > inHigh[patternIdx-1] )
            ||
            ( patternResult < 0 && inClose[i] < inLow[patternIdx-1] )
            )
            )
            patternIdx = 0;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( inHigh[i-1] < inHigh[i-2] && inLow[i-1] > inLow[i-2] &&
            ( ( inHigh[i] < inHigh[i-1] && inLow[i] < inLow[i-1] )
            ||
            ( inHigh[i] > inHigh[i-1] && inLow[i] > inLow[i-1] )
            )
            ) {
            patternResult = 100 * ( inHigh[i] < inHigh[i-1] ? 1 : -1 );
            patternIdx = i;
            outInteger[outIdx++] = patternResult;
         } else
            if( i <= patternIdx+3 &&
            ( ( patternResult > 0 && inClose[i] > inHigh[patternIdx-1] )
            ||
            ( patternResult < 0 && inClose[i] < inLow[patternIdx-1] )
            )
            ) {
            outInteger[outIdx++] = patternResult + 100 * ( patternResult > 0 ? 1 : -1 );
            patternIdx = 0;
         } else
            outInteger[outIdx++] = 0;
         i++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlHikkakeModLookback( )
   {
      return (((1) > ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) ? (1) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) + 5;
   }
   public RetCode cdlHikkakeMod( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double NearPeriodTotal;
      int i, outIdx, NearTrailingIdx, lookbackTotal, patternIdx, patternResult;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHikkakeModLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      NearPeriodTotal = 0;
      NearTrailingIdx = startIdx - 3 - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      i = NearTrailingIdx;
      while( i < startIdx - 3 ) {
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         i++;
      }
      patternIdx = 0;
      patternResult = 0;
      i = startIdx - 3;
      while( i < startIdx ) {
         if( inHigh[i-2] < inHigh[i-3] && inLow[i-2] > inLow[i-3] &&
            inHigh[i-1] < inHigh[i-2] && inLow[i-1] > inLow[i-2] &&
            ( ( inHigh[i] < inHigh[i-1] && inLow[i] < inLow[i-1] &&
            inClose[i-2] <= inLow[i-2] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ||
            ( inHigh[i] > inHigh[i-1] && inLow[i] > inLow[i-1] &&
            inClose[i-2] >= inHigh[i-2] - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            ) {
            patternResult = 100 * ( inHigh[i] < inHigh[i-1] ? 1 : -1 );
            patternIdx = i;
         } else
            if( i <= patternIdx+3 &&
            ( ( patternResult > 0 && inClose[i] > inHigh[patternIdx-1] )
            ||
            ( patternResult < 0 && inClose[i] < inLow[patternIdx-1] )
            )
            )
            patternIdx = 0;
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-2] - inOpen[NearTrailingIdx-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-2] - inLow[NearTrailingIdx-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-2] - ( inClose[NearTrailingIdx-2] >= inOpen[NearTrailingIdx-2] ? inClose[NearTrailingIdx-2] : inOpen[NearTrailingIdx-2] ) ) + ( ( inClose[NearTrailingIdx-2] >= inOpen[NearTrailingIdx-2] ? inOpen[NearTrailingIdx-2] : inClose[NearTrailingIdx-2] ) - inLow[NearTrailingIdx-2] ) : 0 ) ) ) ;
         NearTrailingIdx++;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( inHigh[i-2] < inHigh[i-3] && inLow[i-2] > inLow[i-3] &&
            inHigh[i-1] < inHigh[i-2] && inLow[i-1] > inLow[i-2] &&
            ( ( inHigh[i] < inHigh[i-1] && inLow[i] < inLow[i-1] &&
            inClose[i-2] <= inLow[i-2] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ||
            ( inHigh[i] > inHigh[i-1] && inLow[i] > inLow[i-1] &&
            inClose[i-2] >= inHigh[i-2] - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            ) {
            patternResult = 100 * ( inHigh[i] < inHigh[i-1] ? 1 : -1 );
            patternIdx = i;
            outInteger[outIdx++] = patternResult;
         } else
            if( i <= patternIdx+3 &&
            ( ( patternResult > 0 && inClose[i] > inHigh[patternIdx-1] )
            ||
            ( patternResult < 0 && inClose[i] < inLow[patternIdx-1] )
            )
            ) {
            outInteger[outIdx++] = patternResult + 100 * ( patternResult > 0 ? 1 : -1 );
            patternIdx = 0;
         } else
            outInteger[outIdx++] = 0;
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-2] - inOpen[NearTrailingIdx-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-2] - inLow[NearTrailingIdx-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-2] - ( inClose[NearTrailingIdx-2] >= inOpen[NearTrailingIdx-2] ? inClose[NearTrailingIdx-2] : inOpen[NearTrailingIdx-2] ) ) + ( ( inClose[NearTrailingIdx-2] >= inOpen[NearTrailingIdx-2] ? inOpen[NearTrailingIdx-2] : inClose[NearTrailingIdx-2] ) - inLow[NearTrailingIdx-2] ) : 0 ) ) ) ;
         NearTrailingIdx++;
         i++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlHikkakeModStateInit( struct TA_cdlHikkakeMod_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlHikkakeMod ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlHikkakeModLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLHIKKAKEMOD_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlHikkakeModState( struct TA_cdlHikkakeMod_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1,i2,i3;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .patternResult = 0.;
         _state.value .patternIdx = 0.;
         _state.value .patternHigh = 0.;
         _state.value .patternLow = 0.;
         _state.value .NearPeriodTotal = 0.;
         _state.value .periodNear = (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) +3;
         _state.value .gapNear = _state.value .mem_size - _state.value .periodNear;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
      i3 = (( _state.value .mem_index-1+-3)% _state.value .mem_size ) ;
      if ((int) _state.value .mem_index-1 >= (int) _state.value .mem_size -3)
      {
         if( ( _state.value .memory+i2).value .inHigh < ( _state.value .memory+i3).value .inHigh && ( _state.value .memory+i2).value .inLow > ( _state.value .memory+i3).value .inLow &&
            ( _state.value .memory+i1).value .inHigh < ( _state.value .memory+i2).value .inHigh && ( _state.value .memory+i1).value .inLow > ( _state.value .memory+i2).value .inLow &&
            ( ( inHigh < ( _state.value .memory+i1).value .inHigh && inLow < ( _state.value .memory+i1).value .inLow &&
            ( _state.value .memory+i2).value .inClose <= ( _state.value .memory+i2).value .inLow + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? _state.value .NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ||
            ( inHigh > ( _state.value .memory+i1).value .inHigh && inLow > ( _state.value .memory+i1).value .inLow &&
            ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inHigh - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? _state.value .NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            )
         {
            _state.value .patternResult = 100 * ( inHigh < ( _state.value .memory+i1).value .inHigh ? 1 : -1 );
            _state.value .patternIdx = _state.value .mem_index-1;
            _state.value .patternHigh = ( _state.value .memory+i1).value .inHigh ;
            _state.value .patternLow = ( _state.value .memory+i1).value .inLow ;
            outInteger.value = _state.value .patternResult;
         } else
            if( (int) _state.value .mem_index-1 <= _state.value .patternIdx+3 &&
            ( ( _state.value .patternResult > 0 && inClose > _state.value .patternHigh )
            ||
            ( _state.value .patternResult < 0 && inClose < _state.value .patternLow )
            )
            )
         {
            outInteger.value = _state.value .patternResult + 100 * ( _state.value .patternResult > 0 ? 1 : -1 );
            _state.value .patternIdx = 0;
         } else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapNear)
         _state.value .NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
      if ((int) _state.value .mem_index-1 >= (int) _state.value .mem_size -3)
         _state.value .NearPeriodTotal -= ( - _state.value .periodNear-2!=0?( ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlHikkakeModStateFree( struct TA_cdlHikkakeMod_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlHikkakeModStateSave( struct TA_cdlHikkakeMod_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLHIKKAKEMOD_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .patternResult,sizeof( _state.value .patternResult),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .patternIdx,sizeof( _state.value .patternIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .patternHigh,sizeof( _state.value .patternHigh),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .patternLow,sizeof( _state.value .patternLow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .NearPeriodTotal,sizeof( _state.value .NearPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodNear,sizeof( _state.value .periodNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapNear,sizeof( _state.value .gapNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlHikkakeModStateLoad( struct TA_cdlHikkakeMod_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlHikkakeMod ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLHIKKAKEMOD_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLHIKKAKEMOD_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .patternResult,sizeof( _state.value .value .patternResult),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .patternIdx,sizeof( _state.value .value .patternIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .patternHigh,sizeof( _state.value .value .patternHigh),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .patternLow,sizeof( _state.value .value .patternLow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .NearPeriodTotal,sizeof( _state.value .value .NearPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodNear,sizeof( _state.value .value .periodNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapNear,sizeof( _state.value .value .gapNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlHikkakeMod( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double NearPeriodTotal;
      int i, outIdx, NearTrailingIdx, lookbackTotal, patternIdx, patternResult;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHikkakeModLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      NearPeriodTotal = 0;
      NearTrailingIdx = startIdx - 3 - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      i = NearTrailingIdx;
      while( i < startIdx - 3 ) {
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         i++;
      }
      patternIdx = 0;
      patternResult = 0;
      i = startIdx - 3;
      while( i < startIdx ) {
         if( inHigh[i-2] < inHigh[i-3] && inLow[i-2] > inLow[i-3] &&
            inHigh[i-1] < inHigh[i-2] && inLow[i-1] > inLow[i-2] &&
            ( ( inHigh[i] < inHigh[i-1] && inLow[i] < inLow[i-1] &&
            inClose[i-2] <= inLow[i-2] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ||
            ( inHigh[i] > inHigh[i-1] && inLow[i] > inLow[i-1] &&
            inClose[i-2] >= inHigh[i-2] - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            ) {
            patternResult = 100 * ( inHigh[i] < inHigh[i-1] ? 1 : -1 );
            patternIdx = i;
         } else
            if( i <= patternIdx+3 &&
            ( ( patternResult > 0 && inClose[i] > inHigh[patternIdx-1] )
            ||
            ( patternResult < 0 && inClose[i] < inLow[patternIdx-1] )
            )
            )
            patternIdx = 0;
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-2] - inOpen[NearTrailingIdx-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-2] - inLow[NearTrailingIdx-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-2] - ( inClose[NearTrailingIdx-2] >= inOpen[NearTrailingIdx-2] ? inClose[NearTrailingIdx-2] : inOpen[NearTrailingIdx-2] ) ) + ( ( inClose[NearTrailingIdx-2] >= inOpen[NearTrailingIdx-2] ? inOpen[NearTrailingIdx-2] : inClose[NearTrailingIdx-2] ) - inLow[NearTrailingIdx-2] ) : 0 ) ) ) ;
         NearTrailingIdx++;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( inHigh[i-2] < inHigh[i-3] && inLow[i-2] > inLow[i-3] &&
            inHigh[i-1] < inHigh[i-2] && inLow[i-1] > inLow[i-2] &&
            ( ( inHigh[i] < inHigh[i-1] && inLow[i] < inLow[i-1] &&
            inClose[i-2] <= inLow[i-2] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ||
            ( inHigh[i] > inHigh[i-1] && inLow[i] > inLow[i-1] &&
            inClose[i-2] >= inHigh[i-2] - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            ) {
            patternResult = 100 * ( inHigh[i] < inHigh[i-1] ? 1 : -1 );
            patternIdx = i;
            outInteger[outIdx++] = patternResult;
         } else
            if( i <= patternIdx+3 &&
            ( ( patternResult > 0 && inClose[i] > inHigh[patternIdx-1] )
            ||
            ( patternResult < 0 && inClose[i] < inLow[patternIdx-1] )
            )
            ) {
            outInteger[outIdx++] = patternResult + 100 * ( patternResult > 0 ? 1 : -1 );
            patternIdx = 0;
         } else
            outInteger[outIdx++] = 0;
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-2] - inOpen[NearTrailingIdx-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-2] - inLow[NearTrailingIdx-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-2] - ( inClose[NearTrailingIdx-2] >= inOpen[NearTrailingIdx-2] ? inClose[NearTrailingIdx-2] : inOpen[NearTrailingIdx-2] ) ) + ( ( inClose[NearTrailingIdx-2] >= inOpen[NearTrailingIdx-2] ? inOpen[NearTrailingIdx-2] : inClose[NearTrailingIdx-2] ) - inLow[NearTrailingIdx-2] ) : 0 ) ) ) ;
         NearTrailingIdx++;
         i++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlHomingPigeonLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) + 1;
   }
   public RetCode cdlHomingPigeon( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyShortPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHomingPigeonLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] < inOpen[i-1] &&
            inClose[i] > inClose[i-1]
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-1] - inOpen[BodyLongTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-1] - inLow[BodyLongTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-1] - ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inClose[BodyLongTrailingIdx-1] : inOpen[BodyLongTrailingIdx-1] ) ) + ( ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inOpen[BodyLongTrailingIdx-1] : inClose[BodyLongTrailingIdx-1] ) - inLow[BodyLongTrailingIdx-1] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlHomingPigeonStateInit( struct TA_cdlHomingPigeon_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlHomingPigeon ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlHomingPigeonLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLHOMINGPIGEON_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlHomingPigeonState( struct TA_cdlHomingPigeon_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyLongPeriodTotal = 0.;
         _state.value .BodyShortPeriodTotal = 0.;
         _state.value .periodBodyLong = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
         _state.value .periodBodyShort = (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
         _state.value .gapBodyLong = _state.value .mem_size - _state.value .periodBodyLong;
         _state.value .gapBodyShort = _state.value .mem_size - _state.value .periodBodyShort;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == -1 &&
            ( inClose >= inOpen ? 1 : -1 ) == -1 &&
            ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose - inOpen ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? _state.value .BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen < ( _state.value .memory+i1).value .inOpen &&
            inClose > ( _state.value .memory+i1).value .inClose
            )
            outInteger.value = 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyLong)
      {
         _state.value .BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyShort)
      {
         _state.value .BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .BodyLongPeriodTotal -= ( - _state.value .periodBodyLong-1!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyShortPeriodTotal -= ( - _state.value .periodBodyShort!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlHomingPigeonStateFree( struct TA_cdlHomingPigeon_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlHomingPigeonStateSave( struct TA_cdlHomingPigeon_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLHOMINGPIGEON_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyLongPeriodTotal,sizeof( _state.value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyShortPeriodTotal,sizeof( _state.value .BodyShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyLong,sizeof( _state.value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyShort,sizeof( _state.value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyLong,sizeof( _state.value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyShort,sizeof( _state.value .gapBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlHomingPigeonStateLoad( struct TA_cdlHomingPigeon_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlHomingPigeon ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLHOMINGPIGEON_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLHOMINGPIGEON_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyLongPeriodTotal,sizeof( _state.value .value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyShortPeriodTotal,sizeof( _state.value .value .BodyShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyLong,sizeof( _state.value .value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyShort,sizeof( _state.value .value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyLong,sizeof( _state.value .value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyShort,sizeof( _state.value .value .gapBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlHomingPigeon( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyShortPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHomingPigeonLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] < inOpen[i-1] &&
            inClose[i] > inClose[i-1]
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-1] - inOpen[BodyLongTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-1] - inLow[BodyLongTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-1] - ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inClose[BodyLongTrailingIdx-1] : inOpen[BodyLongTrailingIdx-1] ) ) + ( ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inOpen[BodyLongTrailingIdx-1] : inClose[BodyLongTrailingIdx-1] ) - inLow[BodyLongTrailingIdx-1] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlIdentical3CrowsLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) )) +
         2;
   }
   public RetCode cdlIdentical3Crows( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []ShadowVeryShortPeriodTotal = new double[3] ;
      double []EqualPeriodTotal = new double[3] ;
      int i, outIdx, totIdx, ShadowVeryShortTrailingIdx, EqualTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlIdentical3CrowsLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal[2] = 0;
      ShadowVeryShortPeriodTotal[1] = 0;
      ShadowVeryShortPeriodTotal[0] = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      EqualPeriodTotal[2] = 0;
      EqualPeriodTotal[1] = 0;
      EqualPeriodTotal[0] = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         EqualPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[2] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i-2] > inClose[i-1] &&
            inClose[i-1] > inClose[i] &&
            inOpen[i-1] <= inClose[i-2] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal[2] / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i-1] >= inClose[i-2] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal[2] / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] <= inClose[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal[1] / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] >= inClose[i-1] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal[1] / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 2; totIdx >= 0; --totIdx)
            ShadowVeryShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-totIdx] - inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inClose[ShadowVeryShortTrailingIdx-totIdx] : inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inOpen[ShadowVeryShortTrailingIdx-totIdx] : inClose[ShadowVeryShortTrailingIdx-totIdx] ) - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         for (totIdx = 2; totIdx >= 1; --totIdx)
            EqualPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-totIdx] - inOpen[EqualTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-totIdx] - inLow[EqualTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-totIdx] - ( inClose[EqualTrailingIdx-totIdx] >= inOpen[EqualTrailingIdx-totIdx] ? inClose[EqualTrailingIdx-totIdx] : inOpen[EqualTrailingIdx-totIdx] ) ) + ( ( inClose[EqualTrailingIdx-totIdx] >= inOpen[EqualTrailingIdx-totIdx] ? inOpen[EqualTrailingIdx-totIdx] : inClose[EqualTrailingIdx-totIdx] ) - inLow[EqualTrailingIdx-totIdx] ) : 0 ) ) ) ;
         i++;
         ShadowVeryShortTrailingIdx++;
         EqualTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlIdentical3CrowsStateInit( struct TA_cdlIdentical3Crows_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlIdentical3Crows ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlIdentical3CrowsLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLIDENTICAL3CROWS_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlIdentical3CrowsState( struct TA_cdlIdentical3Crows_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1,i2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .ShadowVeryShortPeriodTotal0 = 0.;
         _state.value .ShadowVeryShortPeriodTotal1 = 0.;
         _state.value .ShadowVeryShortPeriodTotal2 = 0.;
         _state.value .EqualPeriodTotal1 = 0.;
         _state.value .EqualPeriodTotal2 = 0.;
         _state.value .periodEqual = (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
         _state.value .periodShadowVeryShort = (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
         _state.value .gapEqual = _state.value .mem_size - _state.value .periodEqual;
         _state.value .gapShadowVeryShort = _state.value .mem_size - _state.value .periodShadowVeryShort;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) == -1 &&
            ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal2 / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == -1 &&
            ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal1 / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose >= inOpen ? 1 : -1 ) == -1 &&
            ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal0 / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( _state.value .memory+i2).value .inClose > ( _state.value .memory+i1).value .inClose &&
            ( _state.value .memory+i1).value .inClose > inClose &&
            ( _state.value .memory+i1).value .inOpen <= ( _state.value .memory+i2).value .inClose + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? _state.value .EqualPeriodTotal2 / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( _state.value .memory+i1).value .inOpen >= ( _state.value .memory+i2).value .inClose - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? _state.value .EqualPeriodTotal2 / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen <= ( _state.value .memory+i1).value .inClose + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? _state.value .EqualPeriodTotal1 / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen >= ( _state.value .memory+i1).value .inClose - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? _state.value .EqualPeriodTotal1 / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger.value = -100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadowVeryShort)
      {
         _state.value .ShadowVeryShortPeriodTotal2 += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
         _state.value .ShadowVeryShortPeriodTotal1 += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
         _state.value .ShadowVeryShortPeriodTotal0 += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapEqual)
      {
         _state.value .EqualPeriodTotal2 += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
         _state.value .EqualPeriodTotal1 += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .ShadowVeryShortPeriodTotal2 -= ( - _state.value .periodShadowVeryShort-2!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-2)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowVeryShortPeriodTotal1 -= ( - _state.value .periodShadowVeryShort-1!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowVeryShortPeriodTotal0 -= ( - _state.value .periodShadowVeryShort!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .EqualPeriodTotal2 -= ( - _state.value .periodEqual-2!=0?( ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-2)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-2)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-2)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-2)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-2)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-2)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-2)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-2)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-2)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-2)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .EqualPeriodTotal1 -= ( - _state.value .periodEqual-1!=0?( ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlIdentical3CrowsStateFree( struct TA_cdlIdentical3Crows_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlIdentical3CrowsStateSave( struct TA_cdlIdentical3Crows_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLIDENTICAL3CROWS_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal0,sizeof( _state.value .ShadowVeryShortPeriodTotal0),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal1,sizeof( _state.value .ShadowVeryShortPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal2,sizeof( _state.value .ShadowVeryShortPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .EqualPeriodTotal1,sizeof( _state.value .EqualPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .EqualPeriodTotal2,sizeof( _state.value .EqualPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadowVeryShort,sizeof( _state.value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowVeryShort,sizeof( _state.value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapEqual,sizeof( _state.value .gapEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodEqual,sizeof( _state.value .periodEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlIdentical3CrowsStateLoad( struct TA_cdlIdentical3Crows_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlIdentical3Crows ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLIDENTICAL3CROWS_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLIDENTICAL3CROWS_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal0,sizeof( _state.value .value .ShadowVeryShortPeriodTotal0),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal1,sizeof( _state.value .value .ShadowVeryShortPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal2,sizeof( _state.value .value .ShadowVeryShortPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .EqualPeriodTotal1,sizeof( _state.value .value .EqualPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .EqualPeriodTotal2,sizeof( _state.value .value .EqualPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadowVeryShort,sizeof( _state.value .value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowVeryShort,sizeof( _state.value .value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapEqual,sizeof( _state.value .value .gapEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodEqual,sizeof( _state.value .value .periodEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlIdentical3Crows( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []ShadowVeryShortPeriodTotal = new double[3] ;
      double []EqualPeriodTotal = new double[3] ;
      int i, outIdx, totIdx, ShadowVeryShortTrailingIdx, EqualTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlIdentical3CrowsLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal[2] = 0;
      ShadowVeryShortPeriodTotal[1] = 0;
      ShadowVeryShortPeriodTotal[0] = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      EqualPeriodTotal[2] = 0;
      EqualPeriodTotal[1] = 0;
      EqualPeriodTotal[0] = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         EqualPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[2] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i-2] > inClose[i-1] &&
            inClose[i-1] > inClose[i] &&
            inOpen[i-1] <= inClose[i-2] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal[2] / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i-1] >= inClose[i-2] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal[2] / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] <= inClose[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal[1] / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] >= inClose[i-1] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal[1] / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 2; totIdx >= 0; --totIdx)
            ShadowVeryShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-totIdx] - inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inClose[ShadowVeryShortTrailingIdx-totIdx] : inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inOpen[ShadowVeryShortTrailingIdx-totIdx] : inClose[ShadowVeryShortTrailingIdx-totIdx] ) - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         for (totIdx = 2; totIdx >= 1; --totIdx)
            EqualPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-totIdx] - inOpen[EqualTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-totIdx] - inLow[EqualTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-totIdx] - ( inClose[EqualTrailingIdx-totIdx] >= inOpen[EqualTrailingIdx-totIdx] ? inClose[EqualTrailingIdx-totIdx] : inOpen[EqualTrailingIdx-totIdx] ) ) + ( ( inClose[EqualTrailingIdx-totIdx] >= inOpen[EqualTrailingIdx-totIdx] ? inOpen[EqualTrailingIdx-totIdx] : inClose[EqualTrailingIdx-totIdx] ) - inLow[EqualTrailingIdx-totIdx] ) : 0 ) ) ) ;
         i++;
         ShadowVeryShortTrailingIdx++;
         EqualTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlInNeckLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) +
         1;
   }
   public RetCode cdlInNeck( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double EqualPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, EqualTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlInNeckLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      EqualPeriodTotal = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inOpen[i] < inLow[i-1] &&
            inClose[i] <= inClose[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] >= inClose[i-1]
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-1] - inOpen[EqualTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-1] - inLow[EqualTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-1] - ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inClose[EqualTrailingIdx-1] : inOpen[EqualTrailingIdx-1] ) ) + ( ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inOpen[EqualTrailingIdx-1] : inClose[EqualTrailingIdx-1] ) - inLow[EqualTrailingIdx-1] ) : 0 ) ) ) ;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-1] - inOpen[BodyLongTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-1] - inLow[BodyLongTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-1] - ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inClose[BodyLongTrailingIdx-1] : inOpen[BodyLongTrailingIdx-1] ) ) + ( ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inOpen[BodyLongTrailingIdx-1] : inClose[BodyLongTrailingIdx-1] ) - inLow[BodyLongTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         EqualTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlInNeckStateInit( struct TA_cdlInNeck_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlInNeck ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlInNeckLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLINNECK_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlInNeckState( struct TA_cdlInNeck_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyLongPeriodTotal = 0.;
         _state.value .EqualPeriodTotal = 0.;
         _state.value .periodEqual = (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
         _state.value .periodBodyLong = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
         _state.value .gapEqual = _state.value .mem_size - _state.value .periodEqual;
         _state.value .gapBodyLong = _state.value .mem_size - _state.value .periodBodyLong;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == -1 &&
            ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose >= inOpen ? 1 : -1 ) == 1 &&
            inOpen < ( _state.value .memory+i1).value .inLow &&
            inClose <= ( _state.value .memory+i1).value .inClose + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? _state.value .EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose >= ( _state.value .memory+i1).value .inClose
            )
            outInteger.value = -100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapEqual)
      {
         _state.value .EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyLong)
      {
         _state.value .BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .EqualPeriodTotal -= ( - _state.value .periodEqual-1!=0?( ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyLongPeriodTotal -= ( - _state.value .periodBodyLong-1!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlInNeckStateFree( struct TA_cdlInNeck_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlInNeckStateSave( struct TA_cdlInNeck_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLINNECK_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyLongPeriodTotal,sizeof( _state.value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .EqualPeriodTotal,sizeof( _state.value .EqualPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyLong,sizeof( _state.value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyLong,sizeof( _state.value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodEqual,sizeof( _state.value .periodEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapEqual,sizeof( _state.value .gapEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlInNeckStateLoad( struct TA_cdlInNeck_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlInNeck ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLINNECK_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLINNECK_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyLongPeriodTotal,sizeof( _state.value .value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .EqualPeriodTotal,sizeof( _state.value .value .EqualPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyLong,sizeof( _state.value .value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyLong,sizeof( _state.value .value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodEqual,sizeof( _state.value .value .periodEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapEqual,sizeof( _state.value .value .gapEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlInNeck( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double EqualPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, EqualTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlInNeckLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      EqualPeriodTotal = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inOpen[i] < inLow[i-1] &&
            inClose[i] <= inClose[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] >= inClose[i-1]
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-1] - inOpen[EqualTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-1] - inLow[EqualTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-1] - ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inClose[EqualTrailingIdx-1] : inOpen[EqualTrailingIdx-1] ) ) + ( ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inOpen[EqualTrailingIdx-1] : inClose[EqualTrailingIdx-1] ) - inLow[EqualTrailingIdx-1] ) : 0 ) ) ) ;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-1] - inOpen[BodyLongTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-1] - inLow[BodyLongTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-1] - ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inClose[BodyLongTrailingIdx-1] : inOpen[BodyLongTrailingIdx-1] ) ) + ( ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inOpen[BodyLongTrailingIdx-1] : inClose[BodyLongTrailingIdx-1] ) - inLow[BodyLongTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         EqualTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlInvertedHammerLookback( )
   {
      return ((( ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ? ( ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) +
         1;
   }
   public RetCode cdlInvertedHammer( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal, ShadowLongPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, BodyTrailingIdx, ShadowLongTrailingIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlInvertedHammerLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i]) > (inClose[i])) ? (inOpen[i]) : (inClose[i])) < (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) ) )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx] - inOpen[ShadowLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx] - inLow[ShadowLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx] - ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inClose[ShadowLongTrailingIdx] : inOpen[ShadowLongTrailingIdx] ) ) + ( ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inOpen[ShadowLongTrailingIdx] : inClose[ShadowLongTrailingIdx] ) - inLow[ShadowLongTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
         ShadowLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlInvertedHammerStateInit( struct TA_cdlInvertedHammer_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlInvertedHammer ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlInvertedHammerLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLINVERTEDHAMMER_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlInvertedHammerState( struct TA_cdlInvertedHammer_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyPeriodTotal = 0.;
         _state.value .ShadowLongPeriodTotal = 0.;
         _state.value .ShadowVeryShortPeriodTotal = 0.;
         _state.value .periodBody = (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
         _state.value .periodShadowVeryShort = (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
         _state.value .periodShadowLong = (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
         _state.value .gapShadowLong = _state.value .mem_size - _state.value .periodShadowLong;
         _state.value .gapShadowVeryShort = _state.value .mem_size - _state.value .periodShadowVeryShort;
         _state.value .gapBody = _state.value .mem_size - _state.value .periodBody;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( Math.abs ( inClose - inOpen ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? _state.value .BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? _state.value .ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen) > (inClose)) ? (inOpen) : (inClose)) < ((( ( _state.value .memory+i1).value .inOpen ) < ( ( _state.value .memory+i1).value .inClose )) ? ( ( _state.value .memory+i1).value .inOpen ) : ( ( _state.value .memory+i1).value .inClose )) )
            )
            outInteger.value = 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadowVeryShort)
      {
         _state.value .ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadowLong)
      {
         _state.value .ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBody)
      {
         _state.value .BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .ShadowVeryShortPeriodTotal -= ( - _state.value .periodShadowVeryShort!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowLongPeriodTotal -= ( - _state.value .periodShadowLong!=0?( ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyPeriodTotal -= ( - _state.value .periodBody!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlInvertedHammerStateFree( struct TA_cdlInvertedHammer_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlInvertedHammerStateSave( struct TA_cdlInvertedHammer_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLINVERTEDHAMMER_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyPeriodTotal,sizeof( _state.value .BodyPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal,sizeof( _state.value .ShadowVeryShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowLongPeriodTotal,sizeof( _state.value .ShadowLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowVeryShort,sizeof( _state.value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadowVeryShort,sizeof( _state.value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBody,sizeof( _state.value .periodBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBody,sizeof( _state.value .gapBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowLong,sizeof( _state.value .periodShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadowLong,sizeof( _state.value .gapShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlInvertedHammerStateLoad( struct TA_cdlInvertedHammer_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlInvertedHammer ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLINVERTEDHAMMER_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLINVERTEDHAMMER_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyPeriodTotal,sizeof( _state.value .value .BodyPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal,sizeof( _state.value .value .ShadowVeryShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowLongPeriodTotal,sizeof( _state.value .value .ShadowLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowVeryShort,sizeof( _state.value .value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadowVeryShort,sizeof( _state.value .value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBody,sizeof( _state.value .value .periodBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBody,sizeof( _state.value .value .gapBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowLong,sizeof( _state.value .value .periodShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadowLong,sizeof( _state.value .value .gapShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlInvertedHammer( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal, ShadowLongPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, BodyTrailingIdx, ShadowLongTrailingIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlInvertedHammerLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i]) > (inClose[i])) ? (inOpen[i]) : (inClose[i])) < (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) ) )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx] - inOpen[ShadowLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx] - inLow[ShadowLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx] - ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inClose[ShadowLongTrailingIdx] : inOpen[ShadowLongTrailingIdx] ) ) + ( ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inOpen[ShadowLongTrailingIdx] : inClose[ShadowLongTrailingIdx] ) - inLow[ShadowLongTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
         ShadowLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlKickingLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) +
         1;
   }
   public RetCode cdlKicking( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []ShadowVeryShortPeriodTotal = new double[2] ;
      double []BodyLongPeriodTotal = new double[2] ;
      int i, outIdx, totIdx, ShadowVeryShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlKickingLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal[1] = 0;
      ShadowVeryShortPeriodTotal[0] = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal[1] = 0;
      BodyLongPeriodTotal[0] = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         BodyLongPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == - ( inClose[i] >= inOpen[i] ? 1 : -1 ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[1] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[0] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 && ( inLow[i] > inHigh[i-1] ) )
            ||
            ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 && ( inHigh[i] < inLow[i-1] ) )
            )
            )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 1; totIdx >= 0; --totIdx) {
            BodyLongPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-totIdx] - inOpen[BodyLongTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-totIdx] - inLow[BodyLongTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-totIdx] - ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inClose[BodyLongTrailingIdx-totIdx] : inOpen[BodyLongTrailingIdx-totIdx] ) ) + ( ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inOpen[BodyLongTrailingIdx-totIdx] : inClose[BodyLongTrailingIdx-totIdx] ) - inLow[BodyLongTrailingIdx-totIdx] ) : 0 ) ) ) ;
            ShadowVeryShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-totIdx] - inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inClose[ShadowVeryShortTrailingIdx-totIdx] : inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inOpen[ShadowVeryShortTrailingIdx-totIdx] : inClose[ShadowVeryShortTrailingIdx-totIdx] ) - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         }
         i++;
         ShadowVeryShortTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlKickingStateInit( struct TA_cdlKicking_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlKicking ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlKickingLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLKICKING_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlKickingState( struct TA_cdlKicking_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyPeriodTotal0 = 0.;
         _state.value .ShadowVeryShortPeriodTotal0 = 0.;
         _state.value .BodyPeriodTotal1 = 0.;
         _state.value .ShadowVeryShortPeriodTotal1 = 0.;
         _state.value .periodBody = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
         _state.value .periodShadowVeryShort = (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
         _state.value .gapShadowVeryShort = _state.value .mem_size - _state.value .periodShadowVeryShort;
         _state.value .gapBody = _state.value .mem_size - _state.value .periodBody;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == - ( inClose >= inOpen ? 1 : -1 ) &&
            ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyPeriodTotal1 / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal1 / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal1 / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose - inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyPeriodTotal0 / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal0 / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal0 / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == -1 && ( inLow > ( _state.value .memory+i1).value .inHigh ) )
            ||
            ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == 1 && ( inHigh < ( _state.value .memory+i1).value .inLow ) )
            )
            )
            outInteger.value = ( inClose >= inOpen ? 1 : -1 ) * 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadowVeryShort)
      {
         _state.value .ShadowVeryShortPeriodTotal0 += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
         _state.value .ShadowVeryShortPeriodTotal1 += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBody)
      {
         _state.value .BodyPeriodTotal0 += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
         _state.value .BodyPeriodTotal1 += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .ShadowVeryShortPeriodTotal0 -= ( - _state.value .periodShadowVeryShort!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyPeriodTotal0 -= ( - _state.value .periodBody!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowVeryShortPeriodTotal1 -= ( - _state.value .periodShadowVeryShort - 1!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort - 1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort - 1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort - 1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort - 1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort - 1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort - 1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort - 1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort - 1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort - 1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort - 1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort - 1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort - 1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort - 1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort - 1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyPeriodTotal1 -= ( - _state.value .periodBody - 1!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody - 1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody - 1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody - 1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody - 1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody - 1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody - 1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody - 1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody - 1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody - 1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody - 1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody - 1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody - 1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody - 1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody - 1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlKickingStateFree( struct TA_cdlKicking_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlKickingStateSave( struct TA_cdlKicking_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLKICKING_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyPeriodTotal0,sizeof( _state.value .BodyPeriodTotal0),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal0,sizeof( _state.value .ShadowVeryShortPeriodTotal0),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyPeriodTotal1,sizeof( _state.value .BodyPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal1,sizeof( _state.value .ShadowVeryShortPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowVeryShort,sizeof( _state.value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadowVeryShort,sizeof( _state.value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBody,sizeof( _state.value .periodBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBody,sizeof( _state.value .gapBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlKickingStateLoad( struct TA_cdlKicking_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlKicking ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLKICKING_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLKICKING_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyPeriodTotal0,sizeof( _state.value .value .BodyPeriodTotal0),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal0,sizeof( _state.value .value .ShadowVeryShortPeriodTotal0),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyPeriodTotal1,sizeof( _state.value .value .BodyPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal1,sizeof( _state.value .value .ShadowVeryShortPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowVeryShort,sizeof( _state.value .value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadowVeryShort,sizeof( _state.value .value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBody,sizeof( _state.value .value .periodBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBody,sizeof( _state.value .value .gapBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlKicking( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []ShadowVeryShortPeriodTotal = new double[2] ;
      double []BodyLongPeriodTotal = new double[2] ;
      int i, outIdx, totIdx, ShadowVeryShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlKickingLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal[1] = 0;
      ShadowVeryShortPeriodTotal[0] = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal[1] = 0;
      BodyLongPeriodTotal[0] = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         BodyLongPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == - ( inClose[i] >= inOpen[i] ? 1 : -1 ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[1] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[0] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 && ( inLow[i] > inHigh[i-1] ) )
            ||
            ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 && ( inHigh[i] < inLow[i-1] ) )
            )
            )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 1; totIdx >= 0; --totIdx) {
            BodyLongPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-totIdx] - inOpen[BodyLongTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-totIdx] - inLow[BodyLongTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-totIdx] - ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inClose[BodyLongTrailingIdx-totIdx] : inOpen[BodyLongTrailingIdx-totIdx] ) ) + ( ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inOpen[BodyLongTrailingIdx-totIdx] : inClose[BodyLongTrailingIdx-totIdx] ) - inLow[BodyLongTrailingIdx-totIdx] ) : 0 ) ) ) ;
            ShadowVeryShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-totIdx] - inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inClose[ShadowVeryShortTrailingIdx-totIdx] : inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inOpen[ShadowVeryShortTrailingIdx-totIdx] : inClose[ShadowVeryShortTrailingIdx-totIdx] ) - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         }
         i++;
         ShadowVeryShortTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlKickingByLengthLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) +
         1;
   }
   public RetCode cdlKickingByLength( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []ShadowVeryShortPeriodTotal = new double[2] ;
      double []BodyLongPeriodTotal = new double[2] ;
      int i, outIdx, totIdx, ShadowVeryShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlKickingByLengthLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal[1] = 0;
      ShadowVeryShortPeriodTotal[0] = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal[1] = 0;
      BodyLongPeriodTotal[0] = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         BodyLongPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == - ( inClose[i] >= inOpen[i] ? 1 : -1 ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[1] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[0] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 && ( inLow[i] > inHigh[i-1] ) )
            ||
            ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 && ( inHigh[i] < inLow[i-1] ) )
            )
            )
            outInteger[outIdx++] = ( inClose[( ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) ? i : i-1 )] >= inOpen[( ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) ? i : i-1 )] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 1; totIdx >= 0; --totIdx) {
            BodyLongPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-totIdx] - inOpen[BodyLongTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-totIdx] - inLow[BodyLongTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-totIdx] - ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inClose[BodyLongTrailingIdx-totIdx] : inOpen[BodyLongTrailingIdx-totIdx] ) ) + ( ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inOpen[BodyLongTrailingIdx-totIdx] : inClose[BodyLongTrailingIdx-totIdx] ) - inLow[BodyLongTrailingIdx-totIdx] ) : 0 ) ) ) ;
            ShadowVeryShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-totIdx] - inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inClose[ShadowVeryShortTrailingIdx-totIdx] : inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inOpen[ShadowVeryShortTrailingIdx-totIdx] : inClose[ShadowVeryShortTrailingIdx-totIdx] ) - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         }
         i++;
         ShadowVeryShortTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlKickingByLengthStateInit( struct TA_cdlKickingByLength_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlKickingByLength ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlKickingByLengthLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLKICKINGBYLENGTH_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlKickingByLengthState( struct TA_cdlKickingByLength_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyPeriodTotal0 = 0.;
         _state.value .ShadowVeryShortPeriodTotal0 = 0.;
         _state.value .BodyPeriodTotal1 = 0.;
         _state.value .ShadowVeryShortPeriodTotal1 = 0.;
         _state.value .periodBody = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
         _state.value .periodShadowVeryShort = (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
         _state.value .gapShadowVeryShort = _state.value .mem_size - _state.value .periodShadowVeryShort;
         _state.value .gapBody = _state.value .mem_size - _state.value .periodBody;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == - ( inClose >= inOpen ? 1 : -1 ) &&
            ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyPeriodTotal1 / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal1 / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal1 / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose - inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyPeriodTotal0 / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal0 / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal0 / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == -1 && ( inLow > ( _state.value .memory+i1).value .inHigh ) )
            ||
            ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == 1 && ( inHigh < ( _state.value .memory+i1).value .inLow ) )
            )
            )
         {
            if ( ( Math.abs ( inClose - inOpen ) ) > ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) )
               outInteger.value = ( inClose >= inOpen ? 1 : -1 ) * 100;
            else
               outInteger.value = ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) * 100;
         }
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadowVeryShort)
      {
         _state.value .ShadowVeryShortPeriodTotal0 += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
         _state.value .ShadowVeryShortPeriodTotal1 += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBody)
      {
         _state.value .BodyPeriodTotal0 += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
         _state.value .BodyPeriodTotal1 += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .ShadowVeryShortPeriodTotal0 -= ( - _state.value .periodShadowVeryShort!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyPeriodTotal0 -= ( - _state.value .periodBody!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowVeryShortPeriodTotal1 -= ( - _state.value .periodShadowVeryShort - 1!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort - 1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort - 1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort - 1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort - 1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort - 1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort - 1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort - 1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort - 1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort - 1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort - 1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort - 1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort - 1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort - 1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort - 1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyPeriodTotal1 -= ( - _state.value .periodBody - 1!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody - 1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody - 1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody - 1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody - 1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody - 1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody - 1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody - 1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody - 1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody - 1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody - 1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody - 1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody - 1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody - 1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody - 1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlKickingByLengthStateFree( struct TA_cdlKickingByLength_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlKickingByLengthStateSave( struct TA_cdlKickingByLength_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLKICKINGBYLENGTH_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyPeriodTotal0,sizeof( _state.value .BodyPeriodTotal0),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal0,sizeof( _state.value .ShadowVeryShortPeriodTotal0),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyPeriodTotal1,sizeof( _state.value .BodyPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal1,sizeof( _state.value .ShadowVeryShortPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowVeryShort,sizeof( _state.value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadowVeryShort,sizeof( _state.value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBody,sizeof( _state.value .periodBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBody,sizeof( _state.value .gapBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlKickingByLengthStateLoad( struct TA_cdlKickingByLength_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlKickingByLength ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLKICKINGBYLENGTH_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLKICKINGBYLENGTH_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyPeriodTotal0,sizeof( _state.value .value .BodyPeriodTotal0),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal0,sizeof( _state.value .value .ShadowVeryShortPeriodTotal0),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyPeriodTotal1,sizeof( _state.value .value .BodyPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal1,sizeof( _state.value .value .ShadowVeryShortPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowVeryShort,sizeof( _state.value .value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadowVeryShort,sizeof( _state.value .value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBody,sizeof( _state.value .value .periodBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBody,sizeof( _state.value .value .gapBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlKickingByLength( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []ShadowVeryShortPeriodTotal = new double[2] ;
      double []BodyLongPeriodTotal = new double[2] ;
      int i, outIdx, totIdx, ShadowVeryShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlKickingByLengthLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal[1] = 0;
      ShadowVeryShortPeriodTotal[0] = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal[1] = 0;
      BodyLongPeriodTotal[0] = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         BodyLongPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == - ( inClose[i] >= inOpen[i] ? 1 : -1 ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[1] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[0] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 && ( inLow[i] > inHigh[i-1] ) )
            ||
            ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 && ( inHigh[i] < inLow[i-1] ) )
            )
            )
            outInteger[outIdx++] = ( inClose[( ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) ? i : i-1 )] >= inOpen[( ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) ? i : i-1 )] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 1; totIdx >= 0; --totIdx) {
            BodyLongPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-totIdx] - inOpen[BodyLongTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-totIdx] - inLow[BodyLongTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-totIdx] - ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inClose[BodyLongTrailingIdx-totIdx] : inOpen[BodyLongTrailingIdx-totIdx] ) ) + ( ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inOpen[BodyLongTrailingIdx-totIdx] : inClose[BodyLongTrailingIdx-totIdx] ) - inLow[BodyLongTrailingIdx-totIdx] ) : 0 ) ) ) ;
            ShadowVeryShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-totIdx] - inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inClose[ShadowVeryShortTrailingIdx-totIdx] : inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inOpen[ShadowVeryShortTrailingIdx-totIdx] : inClose[ShadowVeryShortTrailingIdx-totIdx] ) - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         }
         i++;
         ShadowVeryShortTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlLadderBottomLookback( )
   {
      return (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) + 4;
   }
   public RetCode cdlLadderBottom( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double ShadowVeryShortPeriodTotal;
      int i, outIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlLadderBottomLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if(
            ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) == -1 && ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) == -1 && ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            inOpen[i-4] > inOpen[i-3] && inOpen[i-3] > inOpen[i-2] &&
            inClose[i-4] > inClose[i-3] && inClose[i-3] > inClose[i-2] &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inOpen[i] > inOpen[i-1] &&
            inClose[i] > inHigh[i-1]
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-1] - inOpen[ShadowVeryShortTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-1] - inLow[ShadowVeryShortTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-1] - ( inClose[ShadowVeryShortTrailingIdx-1] >= inOpen[ShadowVeryShortTrailingIdx-1] ? inClose[ShadowVeryShortTrailingIdx-1] : inOpen[ShadowVeryShortTrailingIdx-1] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-1] >= inOpen[ShadowVeryShortTrailingIdx-1] ? inOpen[ShadowVeryShortTrailingIdx-1] : inClose[ShadowVeryShortTrailingIdx-1] ) - inLow[ShadowVeryShortTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlLadderBottomStateInit( struct TA_cdlLadderBottom_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlLadderBottom ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlLadderBottomLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLLADDERBOTTOM_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlLadderBottomState( struct TA_cdlLadderBottom_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1, i2, i3, i4;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .ShadowVeryShortPeriodTotal = 0.;
         _state.value .periodShadowVeryShort = (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
         _state.value .gapShadowVeryShort = _state.value .mem_size - _state.value .periodShadowVeryShort;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
      i3 = (( _state.value .mem_index-1+-3)% _state.value .mem_size ) ;
      i4 = (( _state.value .mem_index-1+-4)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if(
            ( ( _state.value .memory+i4).value .inClose >= ( _state.value .memory+i4).value .inOpen ? 1 : -1 ) == -1 && ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? 1 : -1 ) == -1 && ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) == -1 &&
            ( _state.value .memory+i4).value .inOpen > ( _state.value .memory+i3).value .inOpen && ( _state.value .memory+i3).value .inOpen > ( _state.value .memory+i2).value .inOpen &&
            ( _state.value .memory+i4).value .inClose > ( _state.value .memory+i3).value .inClose && ( _state.value .memory+i3).value .inClose > ( _state.value .memory+i2).value .inClose &&
            ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == -1 &&
            ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose >= inOpen ? 1 : -1 ) == 1 &&
            inOpen > ( _state.value .memory+i1).value .inOpen &&
            inClose > ( _state.value .memory+i1).value .inHigh
            )
            outInteger.value = 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadowVeryShort)
      {
         _state.value .ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .ShadowVeryShortPeriodTotal -= ( - _state.value .periodShadowVeryShort-1!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort-1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlLadderBottomStateFree( struct TA_cdlLadderBottom_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlLadderBottomStateSave( struct TA_cdlLadderBottom_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLLADDERBOTTOM_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal,sizeof( _state.value .ShadowVeryShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowVeryShort,sizeof( _state.value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadowVeryShort,sizeof( _state.value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlLadderBottomStateLoad( struct TA_cdlLadderBottom_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlLadderBottom ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLLADDERBOTTOM_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLLADDERBOTTOM_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal,sizeof( _state.value .value .ShadowVeryShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowVeryShort,sizeof( _state.value .value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadowVeryShort,sizeof( _state.value .value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlLadderBottom( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double ShadowVeryShortPeriodTotal;
      int i, outIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlLadderBottomLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if(
            ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) == -1 && ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) == -1 && ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            inOpen[i-4] > inOpen[i-3] && inOpen[i-3] > inOpen[i-2] &&
            inClose[i-4] > inClose[i-3] && inClose[i-3] > inClose[i-2] &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inOpen[i] > inOpen[i-1] &&
            inClose[i] > inHigh[i-1]
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-1] - inOpen[ShadowVeryShortTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-1] - inLow[ShadowVeryShortTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-1] - ( inClose[ShadowVeryShortTrailingIdx-1] >= inOpen[ShadowVeryShortTrailingIdx-1] ? inClose[ShadowVeryShortTrailingIdx-1] : inOpen[ShadowVeryShortTrailingIdx-1] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-1] >= inOpen[ShadowVeryShortTrailingIdx-1] ? inOpen[ShadowVeryShortTrailingIdx-1] : inClose[ShadowVeryShortTrailingIdx-1] ) - inLow[ShadowVeryShortTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlLongLeggedDojiLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ;
   }
   public RetCode cdlLongLeggedDoji( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, ShadowLongPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, ShadowLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlLongLeggedDojiLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyDojiPeriodTotal = 0;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ||
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx] - inOpen[ShadowLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx] - inLow[ShadowLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx] - ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inClose[ShadowLongTrailingIdx] : inOpen[ShadowLongTrailingIdx] ) ) + ( ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inOpen[ShadowLongTrailingIdx] : inClose[ShadowLongTrailingIdx] ) - inLow[ShadowLongTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyDojiTrailingIdx++;
         ShadowLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlLongLeggedDojiStateInit( struct TA_cdlLongLeggedDoji_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlLongLeggedDoji ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlLongLeggedDojiLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLLONGLEGGEDDOJI_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlLongLeggedDojiState( struct TA_cdlLongLeggedDoji_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .ShadowLongPeriodTotal = 0.;
         _state.value .BodyDojiPeriodTotal = 0.;
         _state.value .periodBodyDoji = (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
         _state.value .periodShadowLong = (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
         _state.value .gapBodyDoji = _state.value .mem_size - _state.value .periodBodyDoji;
         _state.value .gapShadowLong = _state.value .mem_size - _state.value .periodShadowLong;
      }
      if( ( Math.abs ( inClose - inOpen ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? _state.value .BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
         (
         ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? _state.value .ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) ||
         ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? _state.value .ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
         )
         )
         outInteger.value = 100;
      else
         outInteger.value = 0;
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyDoji)
      {
         _state.value .BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadowLong)
      {
         _state.value .ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .BodyDojiPeriodTotal -= ( - _state.value .periodBodyDoji!=0?( ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowLongPeriodTotal -= ( - _state.value .periodShadowLong!=0?( ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      if ( _state.value .mem_size > 0)
      {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlLongLeggedDojiStateFree( struct TA_cdlLongLeggedDoji_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlLongLeggedDojiStateSave( struct TA_cdlLongLeggedDoji_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLLONGLEGGEDDOJI_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyDojiPeriodTotal,sizeof( _state.value .BodyDojiPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowLongPeriodTotal,sizeof( _state.value .ShadowLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowLong,sizeof( _state.value .periodShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadowLong,sizeof( _state.value .gapShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyDoji,sizeof( _state.value .periodBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyDoji,sizeof( _state.value .gapBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlLongLeggedDojiStateLoad( struct TA_cdlLongLeggedDoji_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlLongLeggedDoji ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLLONGLEGGEDDOJI_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLLONGLEGGEDDOJI_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyDojiPeriodTotal,sizeof( _state.value .value .BodyDojiPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowLongPeriodTotal,sizeof( _state.value .value .ShadowLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowLong,sizeof( _state.value .value .periodShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadowLong,sizeof( _state.value .value .gapShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyDoji,sizeof( _state.value .value .periodBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyDoji,sizeof( _state.value .value .gapBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlLongLeggedDoji( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, ShadowLongPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, ShadowLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlLongLeggedDojiLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyDojiPeriodTotal = 0;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ||
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx] - inOpen[ShadowLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx] - inLow[ShadowLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx] - ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inClose[ShadowLongTrailingIdx] : inOpen[ShadowLongTrailingIdx] ) ) + ( ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inOpen[ShadowLongTrailingIdx] : inClose[ShadowLongTrailingIdx] ) - inLow[ShadowLongTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyDojiTrailingIdx++;
         ShadowLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlLongLineLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) )) ;
   }
   public RetCode cdlLongLine( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal, ShadowPeriodTotal;
      int i, outIdx, BodyTrailingIdx, ShadowTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlLongLineLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      ShadowPeriodTotal = 0;
      ShadowTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowTrailingIdx;
      while( i < startIdx ) {
         ShadowPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         ShadowPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowTrailingIdx] - inOpen[ShadowTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowTrailingIdx] - inLow[ShadowTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowTrailingIdx] - ( inClose[ShadowTrailingIdx] >= inOpen[ShadowTrailingIdx] ? inClose[ShadowTrailingIdx] : inOpen[ShadowTrailingIdx] ) ) + ( ( inClose[ShadowTrailingIdx] >= inOpen[ShadowTrailingIdx] ? inOpen[ShadowTrailingIdx] : inClose[ShadowTrailingIdx] ) - inLow[ShadowTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
         ShadowTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlLongLineStateInit( struct TA_cdlLongLine_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlLongLine ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlLongLineLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLLONGLINE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlLongLineState( struct TA_cdlLongLine_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyPeriodTotal = 0.;
         _state.value .ShadowPeriodTotal = 0.;
         _state.value .periodBody = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
         _state.value .periodShadow = (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) ;
         _state.value .gapShadow = _state.value .mem_size - _state.value .periodShadow;
         _state.value .gapBody = _state.value .mem_size - _state.value .periodBody;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( Math.abs ( inClose - inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) < ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) < ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            outInteger.value = ( inClose >= inOpen ? 1 : -1 ) * 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadow)
      {
         _state.value .ShadowPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBody)
      {
         _state.value .BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .ShadowPeriodTotal -= ( - _state.value .periodShadow!=0?( ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadow)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadow)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadow)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadow)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadow)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadow)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadow)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadow)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadow)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadow)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadow)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadow)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadow)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadow)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyPeriodTotal -= ( - _state.value .periodBody!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlLongLineStateFree( struct TA_cdlLongLine_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlLongLineStateSave( struct TA_cdlLongLine_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLLONGLINE_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .ShadowPeriodTotal,sizeof( _state.value .ShadowPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadow,sizeof( _state.value .periodShadow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadow,sizeof( _state.value .gapShadow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyPeriodTotal,sizeof( _state.value .BodyPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBody,sizeof( _state.value .periodBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBody,sizeof( _state.value .gapBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlLongLineStateLoad( struct TA_cdlLongLine_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlLongLine ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLLONGLINE_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLLONGLINE_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .ShadowPeriodTotal,sizeof( _state.value .value .ShadowPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadow,sizeof( _state.value .value .periodShadow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadow,sizeof( _state.value .value .gapShadow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyPeriodTotal,sizeof( _state.value .value .BodyPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBody,sizeof( _state.value .value .periodBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBody,sizeof( _state.value .value .gapBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlLongLine( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal, ShadowPeriodTotal;
      int i, outIdx, BodyTrailingIdx, ShadowTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlLongLineLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      ShadowPeriodTotal = 0;
      ShadowTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowTrailingIdx;
      while( i < startIdx ) {
         ShadowPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         ShadowPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowTrailingIdx] - inOpen[ShadowTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowTrailingIdx] - inLow[ShadowTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowTrailingIdx] - ( inClose[ShadowTrailingIdx] >= inOpen[ShadowTrailingIdx] ? inClose[ShadowTrailingIdx] : inOpen[ShadowTrailingIdx] ) ) + ( ( inClose[ShadowTrailingIdx] >= inOpen[ShadowTrailingIdx] ? inOpen[ShadowTrailingIdx] : inClose[ShadowTrailingIdx] ) - inLow[ShadowTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
         ShadowTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlMarubozuLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ;
   }
   public RetCode cdlMarubozu( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyLongPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, BodyLongTrailingIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlMarubozuLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlMarubozuStateInit( struct TA_cdlMarubozu_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlMarubozu ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlMarubozuLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLMARUBOZU_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlMarubozuState( struct TA_cdlMarubozu_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .ShadowVeryShortPeriodTotal = 0.;
         _state.value .BodyLongPeriodTotal = 0.;
         _state.value .periodShadowVeryShort = (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
         _state.value .periodBodyLong = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
         _state.value .gapShadowVeryShort = _state.value .mem_size - _state.value .periodShadowVeryShort;
         _state.value .gapBodyLong = _state.value .mem_size - _state.value .periodBodyLong;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( Math.abs ( inClose - inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            outInteger.value = ( inClose >= inOpen ? 1 : -1 ) * 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadowVeryShort)
      {
         _state.value .ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyLong)
      {
         _state.value .BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .ShadowVeryShortPeriodTotal -= ( - _state.value .periodShadowVeryShort!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyLongPeriodTotal -= ( - _state.value .periodBodyLong!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      if ( _state.value .mem_size > 0)
      {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlMarubozuStateFree( struct TA_cdlMarubozu_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlMarubozuStateSave( struct TA_cdlMarubozu_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLMARUBOZU_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal,sizeof( _state.value .ShadowVeryShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyLongPeriodTotal,sizeof( _state.value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadowVeryShort,sizeof( _state.value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowVeryShort,sizeof( _state.value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyLong,sizeof( _state.value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyLong,sizeof( _state.value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlMarubozuStateLoad( struct TA_cdlMarubozu_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlMarubozu ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLMARUBOZU_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLMARUBOZU_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal,sizeof( _state.value .value .ShadowVeryShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyLongPeriodTotal,sizeof( _state.value .value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadowVeryShort,sizeof( _state.value .value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowVeryShort,sizeof( _state.value .value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyLong,sizeof( _state.value .value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyLong,sizeof( _state.value .value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlMarubozu( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyLongPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, BodyLongTrailingIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlMarubozuLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlMatchingLowLookback( )
   {
      return (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) + 1;
   }
   public RetCode cdlMatchingLow( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double EqualPeriodTotal;
      int i, outIdx, EqualTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlMatchingLowLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      EqualPeriodTotal = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inClose[i] <= inClose[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] >= inClose[i-1] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-1] - inOpen[EqualTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-1] - inLow[EqualTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-1] - ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inClose[EqualTrailingIdx-1] : inOpen[EqualTrailingIdx-1] ) ) + ( ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inOpen[EqualTrailingIdx-1] : inClose[EqualTrailingIdx-1] ) - inLow[EqualTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         EqualTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlMatchingLowStateInit( struct TA_cdlMatchingLow_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlMatchingLow ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlMatchingLowLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLMATCHINGLOW_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlMatchingLowState( struct TA_cdlMatchingLow_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .EqualPeriodTotal = 0.;
         _state.value .periodEqual = (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
         _state.value .gapEqual = _state.value .mem_size - _state.value .periodEqual;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == -1 &&
            ( inClose >= inOpen ? 1 : -1 ) == -1 &&
            inClose <= ( _state.value .memory+i1).value .inClose + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? _state.value .EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose >= ( _state.value .memory+i1).value .inClose - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? _state.value .EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger.value = 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapEqual)
      {
         _state.value .EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .EqualPeriodTotal -= ( - _state.value .periodEqual -1!=0?( ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlMatchingLowStateFree( struct TA_cdlMatchingLow_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlMatchingLowStateSave( struct TA_cdlMatchingLow_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLMATCHINGLOW_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .EqualPeriodTotal,sizeof( _state.value .EqualPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodEqual,sizeof( _state.value .periodEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapEqual,sizeof( _state.value .gapEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlMatchingLowStateLoad( struct TA_cdlMatchingLow_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlMatchingLow ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLMATCHINGLOW_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLMATCHINGLOW_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .EqualPeriodTotal,sizeof( _state.value .value .EqualPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodEqual,sizeof( _state.value .value .periodEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapEqual,sizeof( _state.value .value .gapEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlMatchingLow( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double EqualPeriodTotal;
      int i, outIdx, EqualTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlMatchingLowLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      EqualPeriodTotal = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inClose[i] <= inClose[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] >= inClose[i-1] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-1] - inOpen[EqualTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-1] - inLow[EqualTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-1] - ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inClose[EqualTrailingIdx-1] : inOpen[EqualTrailingIdx-1] ) ) + ( ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inOpen[EqualTrailingIdx-1] : inClose[EqualTrailingIdx-1] ) - inLow[EqualTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         EqualTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlMatHoldLookback( double optInPenetration )
   {
      if( optInPenetration == (-4e+37) )
         optInPenetration = 5.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return -1;
      return ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) + 4;
   }
   public RetCode cdlMatHold( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      double optInPenetration,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []BodyPeriodTotal = new double[5] ;
      int i, outIdx, totIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 5.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      lookbackTotal = cdlMatHoldLookback (optInPenetration);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal[4] = 0;
      BodyPeriodTotal[3] = 0;
      BodyPeriodTotal[2] = 0;
      BodyPeriodTotal[1] = 0;
      BodyPeriodTotal[0] = 0;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal[3] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ;
         BodyPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         BodyPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal[4] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if(
            ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[4] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[3] / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[2] / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[1] / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) == 1 &&
            ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) == -1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            ( (((inOpen[i-3]) < (inClose[i-3])) ? (inOpen[i-3]) : (inClose[i-3])) > (((inOpen[i-4]) > (inClose[i-4])) ? (inOpen[i-4]) : (inClose[i-4])) ) &&
            (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) < inClose[i-4] &&
            (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < inClose[i-4] &&
            (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) > inClose[i-4] - ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) * optInPenetration &&
            (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > inClose[i-4] - ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) * optInPenetration &&
            (((inClose[i-2]) > (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) < inOpen[i-3] &&
            (((inClose[i-1]) > (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) < (((inClose[i-2]) > (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) &&
            inOpen[i] > inClose[i-1] &&
            inClose[i] > ((( (((inHigh[i-3]) > (inHigh[i-2])) ? (inHigh[i-3]) : (inHigh[i-2])) ) > (inHigh[i-1])) ? ( (((inHigh[i-3]) > (inHigh[i-2])) ? (inHigh[i-3]) : (inHigh[i-2])) ) : (inHigh[i-1]))
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal[4] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-4] - inOpen[BodyLongTrailingIdx-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-4] - inLow[BodyLongTrailingIdx-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-4] - ( inClose[BodyLongTrailingIdx-4] >= inOpen[BodyLongTrailingIdx-4] ? inClose[BodyLongTrailingIdx-4] : inOpen[BodyLongTrailingIdx-4] ) ) + ( ( inClose[BodyLongTrailingIdx-4] >= inOpen[BodyLongTrailingIdx-4] ? inOpen[BodyLongTrailingIdx-4] : inClose[BodyLongTrailingIdx-4] ) - inLow[BodyLongTrailingIdx-4] ) : 0 ) ) ) ;
         for (totIdx = 3; totIdx >= 1; --totIdx)
            BodyPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx-totIdx] - inOpen[BodyShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx-totIdx] - inLow[BodyShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx-totIdx] - ( inClose[BodyShortTrailingIdx-totIdx] >= inOpen[BodyShortTrailingIdx-totIdx] ? inClose[BodyShortTrailingIdx-totIdx] : inOpen[BodyShortTrailingIdx-totIdx] ) ) + ( ( inClose[BodyShortTrailingIdx-totIdx] >= inOpen[BodyShortTrailingIdx-totIdx] ? inOpen[BodyShortTrailingIdx-totIdx] : inClose[BodyShortTrailingIdx-totIdx] ) - inLow[BodyShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         i++;
         BodyShortTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlMatHoldStateInit( struct TA_cdlMatHold_State** _state,
      double optInPenetration )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 5.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlMatHold ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInPenetration = optInPenetration;
      _state.value .value .mem_size = cdlMatHoldLookback (optInPenetration );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLMATHOLD_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlMatHoldState( struct TA_cdlMatHold_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1, i2, i3, i4;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyPeriodTotal1 = 0.;
         _state.value .BodyPeriodTotal2 = 0.;
         _state.value .BodyPeriodTotal3 = 0.;
         _state.value .BodyPeriodTotal4 = 0.;
         _state.value .periodBodyShort = (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
         _state.value .gapBodyShort = _state.value .mem_size - _state.value .periodBodyShort;
         _state.value .periodBodyLong = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
         _state.value .gapBodyLong = _state.value .mem_size - _state.value .periodBodyLong;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
      i3 = (( _state.value .mem_index-1+-3)% _state.value .mem_size ) ;
      i4 = (( _state.value .mem_index-1+-4)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if(
            ( Math.abs ( ( _state.value .memory+i4).value .inClose - ( _state.value .memory+i4).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyPeriodTotal4 / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i4).value .inClose - ( _state.value .memory+i4).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i4).value .inHigh - ( _state.value .memory+i4).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i4).value .inHigh - ( ( _state.value .memory+i4).value .inClose >= ( _state.value .memory+i4).value .inOpen ? ( _state.value .memory+i4).value .inClose : ( _state.value .memory+i4).value .inOpen ) ) + ( ( ( _state.value .memory+i4).value .inClose >= ( _state.value .memory+i4).value .inOpen ? ( _state.value .memory+i4).value .inOpen : ( _state.value .memory+i4).value .inClose ) - ( _state.value .memory+i4).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( ( _state.value .memory+i3).value .inClose - ( _state.value .memory+i3).value .inOpen ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? _state.value .BodyPeriodTotal3 / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i3).value .inClose - ( _state.value .memory+i3).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i3).value .inHigh - ( _state.value .memory+i3).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i3).value .inHigh - ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? ( _state.value .memory+i3).value .inClose : ( _state.value .memory+i3).value .inOpen ) ) + ( ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? ( _state.value .memory+i3).value .inOpen : ( _state.value .memory+i3).value .inClose ) - ( _state.value .memory+i3).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? _state.value .BodyPeriodTotal2 / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? _state.value .BodyPeriodTotal1 / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( _state.value .memory+i4).value .inClose >= ( _state.value .memory+i4).value .inOpen ? 1 : -1 ) == 1 &&
            ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? 1 : -1 ) == -1 &&
            ( inClose >= inOpen ? 1 : -1 ) == 1 &&
            ( ((( ( _state.value .memory+i3).value .inOpen ) < ( ( _state.value .memory+i3).value .inClose )) ? ( ( _state.value .memory+i3).value .inOpen ) : ( ( _state.value .memory+i3).value .inClose )) > ((( ( _state.value .memory+i4).value .inOpen ) > ( ( _state.value .memory+i4).value .inClose )) ? ( ( _state.value .memory+i4).value .inOpen ) : ( ( _state.value .memory+i4).value .inClose )) ) &&
            ((( ( _state.value .memory+i2).value .inOpen ) < ( ( _state.value .memory+i2).value .inClose )) ? ( ( _state.value .memory+i2).value .inOpen ) : ( ( _state.value .memory+i2).value .inClose )) < ( _state.value .memory+i4).value .inClose &&
            ((( ( _state.value .memory+i1).value .inOpen ) < ( ( _state.value .memory+i1).value .inClose )) ? ( ( _state.value .memory+i1).value .inOpen ) : ( ( _state.value .memory+i1).value .inClose )) < ( _state.value .memory+i4).value .inClose &&
            ((( ( _state.value .memory+i2).value .inOpen ) < ( ( _state.value .memory+i2).value .inClose )) ? ( ( _state.value .memory+i2).value .inOpen ) : ( ( _state.value .memory+i2).value .inClose )) > ( _state.value .memory+i4).value .inClose - ( Math.abs ( ( _state.value .memory+i4).value .inClose - ( _state.value .memory+i4).value .inOpen ) ) * _state.value .optInPenetration &&
            ((( ( _state.value .memory+i1).value .inOpen ) < ( ( _state.value .memory+i1).value .inClose )) ? ( ( _state.value .memory+i1).value .inOpen ) : ( ( _state.value .memory+i1).value .inClose )) > ( _state.value .memory+i4).value .inClose - ( Math.abs ( ( _state.value .memory+i4).value .inClose - ( _state.value .memory+i4).value .inOpen ) ) * _state.value .optInPenetration &&
            ((( ( _state.value .memory+i2).value .inClose ) > ( ( _state.value .memory+i2).value .inOpen )) ? ( ( _state.value .memory+i2).value .inClose ) : ( ( _state.value .memory+i2).value .inOpen )) < ( _state.value .memory+i3).value .inOpen &&
            ((( ( _state.value .memory+i1).value .inClose ) > ( ( _state.value .memory+i1).value .inOpen )) ? ( ( _state.value .memory+i1).value .inClose ) : ( ( _state.value .memory+i1).value .inOpen )) < ((( ( _state.value .memory+i2).value .inClose ) > ( ( _state.value .memory+i2).value .inOpen )) ? ( ( _state.value .memory+i2).value .inClose ) : ( ( _state.value .memory+i2).value .inOpen )) &&
            inOpen > ( _state.value .memory+i1).value .inClose &&
            inClose > ((( ((( ( _state.value .memory+i3).value .inHigh ) > ( ( _state.value .memory+i2).value .inHigh )) ? ( ( _state.value .memory+i3).value .inHigh ) : ( ( _state.value .memory+i2).value .inHigh )) ) > ( ( _state.value .memory+i1).value .inHigh )) ? ( ((( ( _state.value .memory+i3).value .inHigh ) > ( ( _state.value .memory+i2).value .inHigh )) ? ( ( _state.value .memory+i3).value .inHigh ) : ( ( _state.value .memory+i2).value .inHigh )) ) : ( ( _state.value .memory+i1).value .inHigh ))
            )
            outInteger.value = 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .periodBodyShort)
      {
         _state.value .BodyPeriodTotal1 += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
         _state.value .BodyPeriodTotal2 += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
         _state.value .BodyPeriodTotal3 += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i3).value .inClose - ( _state.value .memory+i3).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i3).value .inHigh - ( _state.value .memory+i3).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i3).value .inHigh - ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? ( _state.value .memory+i3).value .inClose : ( _state.value .memory+i3).value .inOpen ) ) + ( ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? ( _state.value .memory+i3).value .inOpen : ( _state.value .memory+i3).value .inClose ) - ( _state.value .memory+i3).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .periodBodyLong)
      {
         _state.value .BodyPeriodTotal4 += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i4).value .inClose - ( _state.value .memory+i4).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i4).value .inHigh - ( _state.value .memory+i4).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i4).value .inHigh - ( ( _state.value .memory+i4).value .inClose >= ( _state.value .memory+i4).value .inOpen ? ( _state.value .memory+i4).value .inClose : ( _state.value .memory+i4).value .inOpen ) ) + ( ( ( _state.value .memory+i4).value .inClose >= ( _state.value .memory+i4).value .inOpen ? ( _state.value .memory+i4).value .inOpen : ( _state.value .memory+i4).value .inClose ) - ( _state.value .memory+i4).value .inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .BodyPeriodTotal1 -= ( - _state.value .periodBodyShort-1!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyPeriodTotal2 -= ( - _state.value .periodBodyShort-2!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-2)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-2)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-2)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-2)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-2)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-2)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-2)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-2)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-2)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-2)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyPeriodTotal3 -= ( - _state.value .periodBodyShort-3!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-3)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-3)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-3)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-3)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-3)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-3)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-3)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-3)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-3)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-3)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-3)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-3)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-3)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-3)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyPeriodTotal4 -= ( - _state.value .periodBodyLong-4!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-4)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-4)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-4)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-4)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-4)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-4)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-4)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-4)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-4)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-4)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-4)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-4)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-4)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-4)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlMatHoldStateFree( struct TA_cdlMatHold_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlMatHoldStateSave( struct TA_cdlMatHold_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLMATHOLD_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInPenetration,sizeof( _state.value .optInPenetration),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyPeriodTotal1,sizeof( _state.value .BodyPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyPeriodTotal2,sizeof( _state.value .BodyPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyPeriodTotal3,sizeof( _state.value .BodyPeriodTotal3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyPeriodTotal4,sizeof( _state.value .BodyPeriodTotal4),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyShort,sizeof( _state.value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyShort,sizeof( _state.value .gapBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyLong,sizeof( _state.value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyLong,sizeof( _state.value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlMatHoldStateLoad( struct TA_cdlMatHold_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlMatHold ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLMATHOLD_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLMATHOLD_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInPenetration,sizeof( _state.value .value .optInPenetration),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyPeriodTotal1,sizeof( _state.value .value .BodyPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyPeriodTotal2,sizeof( _state.value .value .BodyPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyPeriodTotal3,sizeof( _state.value .value .BodyPeriodTotal3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyPeriodTotal4,sizeof( _state.value .value .BodyPeriodTotal4),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyShort,sizeof( _state.value .value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyShort,sizeof( _state.value .value .gapBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyLong,sizeof( _state.value .value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyLong,sizeof( _state.value .value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlMatHold( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      double optInPenetration,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []BodyPeriodTotal = new double[5] ;
      int i, outIdx, totIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 5.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      lookbackTotal = cdlMatHoldLookback (optInPenetration);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal[4] = 0;
      BodyPeriodTotal[3] = 0;
      BodyPeriodTotal[2] = 0;
      BodyPeriodTotal[1] = 0;
      BodyPeriodTotal[0] = 0;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal[3] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ;
         BodyPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         BodyPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal[4] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if(
            ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[4] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[3] / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[2] / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[1] / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) == 1 &&
            ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) == -1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            ( (((inOpen[i-3]) < (inClose[i-3])) ? (inOpen[i-3]) : (inClose[i-3])) > (((inOpen[i-4]) > (inClose[i-4])) ? (inOpen[i-4]) : (inClose[i-4])) ) &&
            (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) < inClose[i-4] &&
            (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < inClose[i-4] &&
            (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) > inClose[i-4] - ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) * optInPenetration &&
            (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > inClose[i-4] - ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) * optInPenetration &&
            (((inClose[i-2]) > (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) < inOpen[i-3] &&
            (((inClose[i-1]) > (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) < (((inClose[i-2]) > (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) &&
            inOpen[i] > inClose[i-1] &&
            inClose[i] > ((( (((inHigh[i-3]) > (inHigh[i-2])) ? (inHigh[i-3]) : (inHigh[i-2])) ) > (inHigh[i-1])) ? ( (((inHigh[i-3]) > (inHigh[i-2])) ? (inHigh[i-3]) : (inHigh[i-2])) ) : (inHigh[i-1]))
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal[4] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-4] - inOpen[BodyLongTrailingIdx-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-4] - inLow[BodyLongTrailingIdx-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-4] - ( inClose[BodyLongTrailingIdx-4] >= inOpen[BodyLongTrailingIdx-4] ? inClose[BodyLongTrailingIdx-4] : inOpen[BodyLongTrailingIdx-4] ) ) + ( ( inClose[BodyLongTrailingIdx-4] >= inOpen[BodyLongTrailingIdx-4] ? inOpen[BodyLongTrailingIdx-4] : inClose[BodyLongTrailingIdx-4] ) - inLow[BodyLongTrailingIdx-4] ) : 0 ) ) ) ;
         for (totIdx = 3; totIdx >= 1; --totIdx)
            BodyPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx-totIdx] - inOpen[BodyShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx-totIdx] - inLow[BodyShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx-totIdx] - ( inClose[BodyShortTrailingIdx-totIdx] >= inOpen[BodyShortTrailingIdx-totIdx] ? inClose[BodyShortTrailingIdx-totIdx] : inOpen[BodyShortTrailingIdx-totIdx] ) ) + ( ( inClose[BodyShortTrailingIdx-totIdx] >= inOpen[BodyShortTrailingIdx-totIdx] ? inOpen[BodyShortTrailingIdx-totIdx] : inClose[BodyShortTrailingIdx-totIdx] ) - inLow[BodyShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         i++;
         BodyShortTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlMorningDojiStarLookback( double optInPenetration )
   {
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return -1;
      return ((( ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) ? ( ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) +
         2;
   }
   public RetCode cdlMorningDojiStar( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      double optInPenetration,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, BodyLongPeriodTotal, BodyShortPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, BodyLongTrailingIdx, BodyShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      lookbackTotal = cdlMorningDojiStarLookback (optInPenetration);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyDojiPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyDojiTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyDojiTrailingIdx;
      while( i < startIdx-1 ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inClose[i] > inClose[i-2] + ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) * optInPenetration
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyDojiTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlMorningDojiStarStateInit( struct TA_cdlMorningDojiStar_State** _state,
      double optInPenetration )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlMorningDojiStar ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInPenetration = optInPenetration;
      _state.value .value .mem_size = cdlMorningDojiStarLookback (optInPenetration );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLMORNINGDOJISTAR_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlMorningDojiStarState( struct TA_cdlMorningDojiStar_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1,i2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyLongPeriodTotal = 0.;
         _state.value .BodyDojiPeriodTotal = 0.;
         _state.value .BodyShortPeriodTotal = 0.;
         _state.value .periodBodyLong = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) +2;
         _state.value .periodBodyDoji = (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) +1;
         _state.value .periodBodyShort = (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
         _state.value .gapBodyLong = _state.value .mem_size - _state.value .periodBodyLong+2;
         _state.value .gapBodyDoji = _state.value .mem_size - _state.value .periodBodyDoji+1;
         _state.value .gapBodyShort = _state.value .mem_size - _state.value .periodBodyShort;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) == -1 &&
            ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? _state.value .BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ((( ( _state.value .memory+i1).value .inOpen ) > ( ( _state.value .memory+i1).value .inClose )) ? ( ( _state.value .memory+i1).value .inOpen ) : ( ( _state.value .memory+i1).value .inClose )) < ((( ( _state.value .memory+i2).value .inOpen ) < ( ( _state.value .memory+i2).value .inClose )) ? ( ( _state.value .memory+i2).value .inOpen ) : ( ( _state.value .memory+i2).value .inClose )) ) &&
            ( Math.abs ( inClose - inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? _state.value .BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose >= inOpen ? 1 : -1 ) == 1 &&
            inClose > ( _state.value .memory+i2).value .inClose + ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) * _state.value .optInPenetration
            )
            outInteger.value = 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyLong)
      {
         _state.value .BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyDoji)
      {
         _state.value .BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyShort)
      {
         _state.value .BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .BodyLongPeriodTotal -= ( - _state.value .periodBodyLong!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyDojiPeriodTotal -= ( - _state.value .periodBodyDoji!=0?( ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyShortPeriodTotal -= ( - _state.value .periodBodyShort!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlMorningDojiStarStateFree( struct TA_cdlMorningDojiStar_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlMorningDojiStarStateSave( struct TA_cdlMorningDojiStar_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLMORNINGDOJISTAR_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInPenetration,sizeof( _state.value .optInPenetration),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyDojiPeriodTotal,sizeof( _state.value .BodyDojiPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyLongPeriodTotal,sizeof( _state.value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyShortPeriodTotal,sizeof( _state.value .BodyShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyLong,sizeof( _state.value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyLong,sizeof( _state.value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyShort,sizeof( _state.value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyShort,sizeof( _state.value .gapBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyDoji,sizeof( _state.value .periodBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyDoji,sizeof( _state.value .gapBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlMorningDojiStarStateLoad( struct TA_cdlMorningDojiStar_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlMorningDojiStar ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLMORNINGDOJISTAR_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLMORNINGDOJISTAR_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInPenetration,sizeof( _state.value .value .optInPenetration),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyDojiPeriodTotal,sizeof( _state.value .value .BodyDojiPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyLongPeriodTotal,sizeof( _state.value .value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyShortPeriodTotal,sizeof( _state.value .value .BodyShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyLong,sizeof( _state.value .value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyLong,sizeof( _state.value .value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyShort,sizeof( _state.value .value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyShort,sizeof( _state.value .value .gapBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyDoji,sizeof( _state.value .value .periodBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyDoji,sizeof( _state.value .value .gapBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlMorningDojiStar( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      double optInPenetration,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, BodyLongPeriodTotal, BodyShortPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, BodyLongTrailingIdx, BodyShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      lookbackTotal = cdlMorningDojiStarLookback (optInPenetration);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyDojiPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyDojiTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyDojiTrailingIdx;
      while( i < startIdx-1 ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inClose[i] > inClose[i-2] + ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) * optInPenetration
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyDojiTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlMorningStarLookback( double optInPenetration )
   {
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return -1;
      return ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) + 2;
   }
   public RetCode cdlMorningStar( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      double optInPenetration,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyShortPeriodTotal, BodyLongPeriodTotal, BodyShortPeriodTotal2;
      int i, outIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      lookbackTotal = cdlMorningStarLookback (optInPenetration);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyShortPeriodTotal2 = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx-1 ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         BodyShortPeriodTotal2 += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i+1] - inOpen[i+1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i+1] - inLow[i+1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i+1] - ( inClose[i+1] >= inOpen[i+1] ? inClose[i+1] : inOpen[i+1] ) ) + ( ( inClose[i+1] >= inOpen[i+1] ? inOpen[i+1] : inClose[i+1] ) - inLow[i+1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal2 / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inClose[i] > inClose[i-2] + ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) * optInPenetration
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal2 += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx+1] - inOpen[BodyShortTrailingIdx+1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx+1] - inLow[BodyShortTrailingIdx+1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx+1] - ( inClose[BodyShortTrailingIdx+1] >= inOpen[BodyShortTrailingIdx+1] ? inClose[BodyShortTrailingIdx+1] : inOpen[BodyShortTrailingIdx+1] ) ) + ( ( inClose[BodyShortTrailingIdx+1] >= inOpen[BodyShortTrailingIdx+1] ? inOpen[BodyShortTrailingIdx+1] : inClose[BodyShortTrailingIdx+1] ) - inLow[BodyShortTrailingIdx+1] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlMorningStarStateInit( struct TA_cdlMorningStar_State** _state,
      double optInPenetration )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlMorningStar ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInPenetration = optInPenetration;
      _state.value .value .mem_size = cdlMorningStarLookback (optInPenetration );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLMORNINGSTAR_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlMorningStarState( struct TA_cdlMorningStar_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1,i2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyLongPeriodTotal = 0.;
         _state.value .BodyShortPeriodTotal2 = 0.;
         _state.value .BodyShortPeriodTotal = 0.;
         _state.value .periodBodyLong = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) +2;
         _state.value .periodBodyShort = (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) +1;
         _state.value .gapBodyLong = _state.value .mem_size - _state.value .periodBodyLong+2;
         _state.value .gapBodyShort = _state.value .mem_size - _state.value .periodBodyShort+1;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) == -1 &&
            ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? _state.value .BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ((( ( _state.value .memory+i1).value .inOpen ) > ( ( _state.value .memory+i1).value .inClose )) ? ( ( _state.value .memory+i1).value .inOpen ) : ( ( _state.value .memory+i1).value .inClose )) < ((( ( _state.value .memory+i2).value .inOpen ) < ( ( _state.value .memory+i2).value .inClose )) ? ( ( _state.value .memory+i2).value .inOpen ) : ( ( _state.value .memory+i2).value .inClose )) ) &&
            ( Math.abs ( inClose - inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? _state.value .BodyShortPeriodTotal2 / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose >= inOpen ? 1 : -1 ) == 1 &&
            inClose > ( _state.value .memory+i2).value .inClose + ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) * _state.value .optInPenetration
            )
            outInteger.value = 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyLong)
      {
         _state.value .BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyShort)
      {
         _state.value .BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
         _state.value .BodyShortPeriodTotal2 += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .BodyLongPeriodTotal -= ( - _state.value .periodBodyLong!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyShortPeriodTotal -= ( - _state.value .periodBodyShort!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyShortPeriodTotal2 -= ( (( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) !=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+(( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) )% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+(( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) )% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+(( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) )% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+(( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) )% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+(( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) )% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+(( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) )% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+(( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) )% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+(( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) )% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+(( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) )% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+(( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) )% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+(( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) )% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+(( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) )% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+(( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) )% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+(( _state.value .mem_index-1+- _state.value .periodBodyShort+1)% _state.value .mem_size ) )% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlMorningStarStateFree( struct TA_cdlMorningStar_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlMorningStarStateSave( struct TA_cdlMorningStar_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLMORNINGSTAR_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInPenetration,sizeof( _state.value .optInPenetration),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyShortPeriodTotal2,sizeof( _state.value .BodyShortPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyLongPeriodTotal,sizeof( _state.value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyShortPeriodTotal,sizeof( _state.value .BodyShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyLong,sizeof( _state.value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyLong,sizeof( _state.value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyShort,sizeof( _state.value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyShort,sizeof( _state.value .gapBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlMorningStarStateLoad( struct TA_cdlMorningStar_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlMorningStar ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLMORNINGSTAR_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLMORNINGSTAR_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInPenetration,sizeof( _state.value .value .optInPenetration),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyShortPeriodTotal2,sizeof( _state.value .value .BodyShortPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyLongPeriodTotal,sizeof( _state.value .value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyShortPeriodTotal,sizeof( _state.value .value .BodyShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyLong,sizeof( _state.value .value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyLong,sizeof( _state.value .value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyShort,sizeof( _state.value .value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyShort,sizeof( _state.value .value .gapBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlMorningStar( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      double optInPenetration,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyShortPeriodTotal, BodyLongPeriodTotal, BodyShortPeriodTotal2;
      int i, outIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      lookbackTotal = cdlMorningStarLookback (optInPenetration);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyShortPeriodTotal2 = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx-1 ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         BodyShortPeriodTotal2 += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i+1] - inOpen[i+1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i+1] - inLow[i+1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i+1] - ( inClose[i+1] >= inOpen[i+1] ? inClose[i+1] : inOpen[i+1] ) ) + ( ( inClose[i+1] >= inOpen[i+1] ? inOpen[i+1] : inClose[i+1] ) - inLow[i+1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal2 / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inClose[i] > inClose[i-2] + ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) * optInPenetration
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal2 += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx+1] - inOpen[BodyShortTrailingIdx+1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx+1] - inLow[BodyShortTrailingIdx+1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx+1] - ( inClose[BodyShortTrailingIdx+1] >= inOpen[BodyShortTrailingIdx+1] ? inClose[BodyShortTrailingIdx+1] : inOpen[BodyShortTrailingIdx+1] ) ) + ( ( inClose[BodyShortTrailingIdx+1] >= inOpen[BodyShortTrailingIdx+1] ? inOpen[BodyShortTrailingIdx+1] : inClose[BodyShortTrailingIdx+1] ) - inLow[BodyShortTrailingIdx+1] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlOnNeckLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) +
         1;
   }
   public RetCode cdlOnNeck( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double EqualPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, EqualTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlOnNeckLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      EqualPeriodTotal = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inOpen[i] < inLow[i-1] &&
            inClose[i] <= inLow[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] >= inLow[i-1] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-1] - inOpen[EqualTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-1] - inLow[EqualTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-1] - ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inClose[EqualTrailingIdx-1] : inOpen[EqualTrailingIdx-1] ) ) + ( ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inOpen[EqualTrailingIdx-1] : inClose[EqualTrailingIdx-1] ) - inLow[EqualTrailingIdx-1] ) : 0 ) ) ) ;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-1] - inOpen[BodyLongTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-1] - inLow[BodyLongTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-1] - ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inClose[BodyLongTrailingIdx-1] : inOpen[BodyLongTrailingIdx-1] ) ) + ( ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inOpen[BodyLongTrailingIdx-1] : inClose[BodyLongTrailingIdx-1] ) - inLow[BodyLongTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         EqualTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlOnNeckStateInit( struct TA_cdlOnNeck_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlOnNeck ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlOnNeckLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLONNECK_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlOnNeckState( struct TA_cdlOnNeck_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .EqualPeriodTotal = 0.;
         _state.value .BodyLongPeriodTotal = 0.;
         _state.value .periodBodyLong = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
         _state.value .periodEqual = (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
         _state.value .gapEqual = _state.value .mem_size - _state.value .periodEqual;
         _state.value .gapBodyLong = _state.value .mem_size - _state.value .periodBodyLong;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == -1 &&
            ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose >= inOpen ? 1 : -1 ) == 1 &&
            inOpen < ( _state.value .memory+i1).value .inLow &&
            inClose <= ( _state.value .memory+i1).value .inLow + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? _state.value .EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose >= ( _state.value .memory+i1).value .inLow - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? _state.value .EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger.value = -100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapEqual)
      {
         _state.value .EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyLong)
      {
         _state.value .BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .EqualPeriodTotal -= ( - _state.value .periodEqual -1!=0?( ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyLongPeriodTotal -= ( - _state.value .periodBodyLong -1!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong -1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong -1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong -1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong -1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong -1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong -1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong -1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong -1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong -1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong -1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong -1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong -1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong -1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong -1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlOnNeckStateFree( struct TA_cdlOnNeck_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlOnNeckStateSave( struct TA_cdlOnNeck_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLONNECK_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .EqualPeriodTotal,sizeof( _state.value .EqualPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodEqual,sizeof( _state.value .periodEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapEqual,sizeof( _state.value .gapEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyLongPeriodTotal,sizeof( _state.value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyLong,sizeof( _state.value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyLong,sizeof( _state.value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlOnNeckStateLoad( struct TA_cdlOnNeck_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlOnNeck ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLONNECK_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLONNECK_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .EqualPeriodTotal,sizeof( _state.value .value .EqualPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodEqual,sizeof( _state.value .value .periodEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapEqual,sizeof( _state.value .value .gapEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyLongPeriodTotal,sizeof( _state.value .value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyLong,sizeof( _state.value .value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyLong,sizeof( _state.value .value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlOnNeck( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double EqualPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, EqualTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlOnNeckLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      EqualPeriodTotal = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inOpen[i] < inLow[i-1] &&
            inClose[i] <= inLow[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] >= inLow[i-1] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-1] - inOpen[EqualTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-1] - inLow[EqualTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-1] - ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inClose[EqualTrailingIdx-1] : inOpen[EqualTrailingIdx-1] ) ) + ( ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inOpen[EqualTrailingIdx-1] : inClose[EqualTrailingIdx-1] ) - inLow[EqualTrailingIdx-1] ) : 0 ) ) ) ;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-1] - inOpen[BodyLongTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-1] - inLow[BodyLongTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-1] - ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inClose[BodyLongTrailingIdx-1] : inOpen[BodyLongTrailingIdx-1] ) ) + ( ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inOpen[BodyLongTrailingIdx-1] : inClose[BodyLongTrailingIdx-1] ) - inLow[BodyLongTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         EqualTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlPiercingLookback( )
   {
      return (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) + 1;
   }
   public RetCode cdlPiercing( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []BodyLongPeriodTotal = new double[2] ;
      int i, outIdx, totIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlPiercingLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal[1] = 0;
      BodyLongPeriodTotal[0] = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         BodyLongPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[1] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[0] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] < inLow[i-1] &&
            inClose[i] < inOpen[i-1] &&
            inClose[i] > inClose[i-1] + ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) * 0.5
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 1; totIdx >= 0; --totIdx)
            BodyLongPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-totIdx] - inOpen[BodyLongTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-totIdx] - inLow[BodyLongTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-totIdx] - ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inClose[BodyLongTrailingIdx-totIdx] : inOpen[BodyLongTrailingIdx-totIdx] ) ) + ( ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inOpen[BodyLongTrailingIdx-totIdx] : inClose[BodyLongTrailingIdx-totIdx] ) - inLow[BodyLongTrailingIdx-totIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlPiercingStateInit( struct TA_cdlPiercing_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlPiercing ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlPiercingLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLPIERCING_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlPiercingState( struct TA_cdlPiercing_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyLongPeriodTotal0 = 0.;
         _state.value .BodyLongPeriodTotal1 = 0.;
         _state.value .periodBodyLong = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
         _state.value .gapBodyLong = _state.value .mem_size - _state.value .periodBodyLong;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == -1 &&
            ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal1 / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose >= inOpen ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose - inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal0 / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen < ( _state.value .memory+i1).value .inLow &&
            inClose < ( _state.value .memory+i1).value .inOpen &&
            inClose > ( _state.value .memory+i1).value .inClose + ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) * 0.5
            )
            outInteger.value = 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyLong)
      {
         _state.value .BodyLongPeriodTotal0 += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
         _state.value .BodyLongPeriodTotal1 += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .BodyLongPeriodTotal0 -= ( - _state.value .periodBodyLong!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyLongPeriodTotal1 -= ( - _state.value .periodBodyLong -1!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong -1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong -1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong -1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong -1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong -1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong -1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong -1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong -1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong -1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong -1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong -1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong -1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong -1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong -1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlPiercingStateFree( struct TA_cdlPiercing_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlPiercingStateSave( struct TA_cdlPiercing_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLPIERCING_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyLongPeriodTotal0,sizeof( _state.value .BodyLongPeriodTotal0),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyLongPeriodTotal1,sizeof( _state.value .BodyLongPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyLong,sizeof( _state.value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyLong,sizeof( _state.value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlPiercingStateLoad( struct TA_cdlPiercing_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlPiercing ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLPIERCING_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLPIERCING_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyLongPeriodTotal0,sizeof( _state.value .value .BodyLongPeriodTotal0),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyLongPeriodTotal1,sizeof( _state.value .value .BodyLongPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyLong,sizeof( _state.value .value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyLong,sizeof( _state.value .value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlPiercing( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []BodyLongPeriodTotal = new double[2] ;
      int i, outIdx, totIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlPiercingLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal[1] = 0;
      BodyLongPeriodTotal[0] = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         BodyLongPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[1] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[0] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] < inLow[i-1] &&
            inClose[i] < inOpen[i-1] &&
            inClose[i] > inClose[i-1] + ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) * 0.5
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 1; totIdx >= 0; --totIdx)
            BodyLongPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-totIdx] - inOpen[BodyLongTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-totIdx] - inLow[BodyLongTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-totIdx] - ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inClose[BodyLongTrailingIdx-totIdx] : inOpen[BodyLongTrailingIdx-totIdx] ) ) + ( ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inOpen[BodyLongTrailingIdx-totIdx] : inClose[BodyLongTrailingIdx-totIdx] ) - inLow[BodyLongTrailingIdx-totIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlRickshawManLookback( )
   {
      return ((( ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) > ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) ? ( ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) ;
   }
   public RetCode cdlRickshawMan( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, ShadowLongPeriodTotal, NearPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, ShadowLongTrailingIdx, NearTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlRickshawManLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyDojiPeriodTotal = 0;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      NearPeriodTotal = 0;
      NearTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = NearTrailingIdx;
      while( i < startIdx ) {
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            (((inOpen[i]) < (inClose[i])) ? (inOpen[i]) : (inClose[i]))
            <= inLow[i] + ( inHigh[i] - inLow[i] ) / 2 + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            &&
            (((inOpen[i]) > (inClose[i])) ? (inOpen[i]) : (inClose[i]))
            >= inLow[i] + ( inHigh[i] - inLow[i] ) / 2 - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx] - inOpen[ShadowLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx] - inLow[ShadowLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx] - ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inClose[ShadowLongTrailingIdx] : inOpen[ShadowLongTrailingIdx] ) ) + ( ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inOpen[ShadowLongTrailingIdx] : inClose[ShadowLongTrailingIdx] ) - inLow[ShadowLongTrailingIdx] ) : 0 ) ) ) ;
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx] - inOpen[NearTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx] - inLow[NearTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx] - ( inClose[NearTrailingIdx] >= inOpen[NearTrailingIdx] ? inClose[NearTrailingIdx] : inOpen[NearTrailingIdx] ) ) + ( ( inClose[NearTrailingIdx] >= inOpen[NearTrailingIdx] ? inOpen[NearTrailingIdx] : inClose[NearTrailingIdx] ) - inLow[NearTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyDojiTrailingIdx++;
         ShadowLongTrailingIdx++;
         NearTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlRickshawManStateInit( struct TA_cdlRickshawMan_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlRickshawMan ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlRickshawManLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLRICKSHAWMAN_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlRickshawManState( struct TA_cdlRickshawMan_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyDojiPeriodTotal = 0.;
         _state.value .ShadowLongPeriodTotal = 0.;
         _state.value .NearPeriodTotal = 0.;
         _state.value .periodBodyDoji = (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
         _state.value .periodShadowLong = (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
         _state.value .periodNear = (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
         _state.value .gapBodyDoji = _state.value .mem_size - _state.value .periodBodyDoji;
         _state.value .gapShadowLong = _state.value .mem_size - _state.value .periodShadowLong;
         _state.value .gapNear = _state.value .mem_size - _state.value .periodNear;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( Math.abs ( inClose - inOpen ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? _state.value .BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? _state.value .ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? _state.value .ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            (((inOpen) < (inClose)) ? (inOpen) : (inClose))
            <= inLow + ( inHigh - inLow ) / 2 + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? _state.value .NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            &&
            (((inOpen) > (inClose)) ? (inOpen) : (inClose))
            >= inLow + ( inHigh - inLow ) / 2 - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? _state.value .NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            outInteger.value = 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyDoji)
      {
         _state.value .BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadowLong)
      {
         _state.value .ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapNear)
      {
         _state.value .NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .BodyDojiPeriodTotal -= ( - _state.value .periodBodyDoji!=0?( ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowLongPeriodTotal -= ( - _state.value .periodShadowLong!=0?( ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .NearPeriodTotal -= ( - _state.value .periodNear!=0?( ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlRickshawManStateFree( struct TA_cdlRickshawMan_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlRickshawManStateSave( struct TA_cdlRickshawMan_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLRICKSHAWMAN_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyDojiPeriodTotal,sizeof( _state.value .BodyDojiPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowLongPeriodTotal,sizeof( _state.value .ShadowLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .NearPeriodTotal,sizeof( _state.value .NearPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyDoji,sizeof( _state.value .periodBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowLong,sizeof( _state.value .periodShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodNear,sizeof( _state.value .periodNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyDoji,sizeof( _state.value .gapBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadowLong,sizeof( _state.value .gapShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapNear,sizeof( _state.value .gapNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlRickshawManStateLoad( struct TA_cdlRickshawMan_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlRickshawMan ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLRICKSHAWMAN_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLRICKSHAWMAN_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyDojiPeriodTotal,sizeof( _state.value .value .BodyDojiPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowLongPeriodTotal,sizeof( _state.value .value .ShadowLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .NearPeriodTotal,sizeof( _state.value .value .NearPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyDoji,sizeof( _state.value .value .periodBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowLong,sizeof( _state.value .value .periodShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodNear,sizeof( _state.value .value .periodNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyDoji,sizeof( _state.value .value .gapBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadowLong,sizeof( _state.value .value .gapShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapNear,sizeof( _state.value .value .gapNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlRickshawMan( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, ShadowLongPeriodTotal, NearPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, ShadowLongTrailingIdx, NearTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlRickshawManLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyDojiPeriodTotal = 0;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      NearPeriodTotal = 0;
      NearTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = NearTrailingIdx;
      while( i < startIdx ) {
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            (((inOpen[i]) < (inClose[i])) ? (inOpen[i]) : (inClose[i]))
            <= inLow[i] + ( inHigh[i] - inLow[i] ) / 2 + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            &&
            (((inOpen[i]) > (inClose[i])) ? (inOpen[i]) : (inClose[i]))
            >= inLow[i] + ( inHigh[i] - inLow[i] ) / 2 - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx] - inOpen[ShadowLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx] - inLow[ShadowLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx] - ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inClose[ShadowLongTrailingIdx] : inOpen[ShadowLongTrailingIdx] ) ) + ( ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inOpen[ShadowLongTrailingIdx] : inClose[ShadowLongTrailingIdx] ) - inLow[ShadowLongTrailingIdx] ) : 0 ) ) ) ;
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx] - inOpen[NearTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx] - inLow[NearTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx] - ( inClose[NearTrailingIdx] >= inOpen[NearTrailingIdx] ? inClose[NearTrailingIdx] : inOpen[NearTrailingIdx] ) ) + ( ( inClose[NearTrailingIdx] >= inOpen[NearTrailingIdx] ? inOpen[NearTrailingIdx] : inClose[NearTrailingIdx] ) - inLow[NearTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyDojiTrailingIdx++;
         ShadowLongTrailingIdx++;
         NearTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlRiseFall3MethodsLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) + 4;
   }
   public RetCode cdlRiseFall3Methods( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []BodyPeriodTotal = new double[5] ;
      int i, outIdx, totIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlRiseFall3MethodsLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal[4] = 0;
      BodyPeriodTotal[3] = 0;
      BodyPeriodTotal[2] = 0;
      BodyPeriodTotal[1] = 0;
      BodyPeriodTotal[0] = 0;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal[3] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ;
         BodyPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         BodyPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal[4] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) ;
         BodyPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if(
            ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[4] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[3] / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[2] / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[1] / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[0] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) == - ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) &&
            ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) == ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == - ( inClose[i] >= inOpen[i] ? 1 : -1 ) &&
            (((inOpen[i-3]) < (inClose[i-3])) ? (inOpen[i-3]) : (inClose[i-3])) < inHigh[i-4] && (((inOpen[i-3]) > (inClose[i-3])) ? (inOpen[i-3]) : (inClose[i-3])) > inLow[i-4] &&
            (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) < inHigh[i-4] && (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) > inLow[i-4] &&
            (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < inHigh[i-4] && (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > inLow[i-4] &&
            inClose[i-2] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) < inClose[i-3] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) &&
            inClose[i-1] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) < inClose[i-2] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) &&
            inOpen[i] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) > inClose[i-1] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) &&
            inClose[i] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) > inClose[i-4] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 )
            )
            outInteger[outIdx++] = 100 * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) ;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal[4] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-4] - inOpen[BodyLongTrailingIdx-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-4] - inLow[BodyLongTrailingIdx-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-4] - ( inClose[BodyLongTrailingIdx-4] >= inOpen[BodyLongTrailingIdx-4] ? inClose[BodyLongTrailingIdx-4] : inOpen[BodyLongTrailingIdx-4] ) ) + ( ( inClose[BodyLongTrailingIdx-4] >= inOpen[BodyLongTrailingIdx-4] ? inOpen[BodyLongTrailingIdx-4] : inClose[BodyLongTrailingIdx-4] ) - inLow[BodyLongTrailingIdx-4] ) : 0 ) ) ) ;
         for (totIdx = 3; totIdx >= 1; --totIdx)
            BodyPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx-totIdx] - inOpen[BodyShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx-totIdx] - inLow[BodyShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx-totIdx] - ( inClose[BodyShortTrailingIdx-totIdx] >= inOpen[BodyShortTrailingIdx-totIdx] ? inClose[BodyShortTrailingIdx-totIdx] : inOpen[BodyShortTrailingIdx-totIdx] ) ) + ( ( inClose[BodyShortTrailingIdx-totIdx] >= inOpen[BodyShortTrailingIdx-totIdx] ? inOpen[BodyShortTrailingIdx-totIdx] : inClose[BodyShortTrailingIdx-totIdx] ) - inLow[BodyShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         BodyPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyShortTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlRiseFall3MethodsStateInit( struct TA_cdlRiseFall3Methods_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlRiseFall3Methods ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlRiseFall3MethodsLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLRISEFALL3METHODS_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlRiseFall3MethodsState( struct TA_cdlRiseFall3Methods_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1, i2, i3, i4;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyPeriodTotal0 = 0.;
         _state.value .BodyPeriodTotal1 = 0.;
         _state.value .BodyPeriodTotal2 = 0.;
         _state.value .BodyPeriodTotal3 = 0.;
         _state.value .BodyPeriodTotal4 = 0.;
         _state.value .periodBodyShort = (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
         _state.value .gapBodyShort = _state.value .mem_size - _state.value .periodBodyShort;
         _state.value .periodBodyLong = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
         _state.value .gapBodyLong = _state.value .mem_size - _state.value .periodBodyLong;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
      i3 = (( _state.value .mem_index-1+-3)% _state.value .mem_size ) ;
      i4 = (( _state.value .mem_index-1+-4)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if(
            ( Math.abs ( ( _state.value .memory+i4).value .inClose - ( _state.value .memory+i4).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyPeriodTotal4 / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i4).value .inClose - ( _state.value .memory+i4).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i4).value .inHigh - ( _state.value .memory+i4).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i4).value .inHigh - ( ( _state.value .memory+i4).value .inClose >= ( _state.value .memory+i4).value .inOpen ? ( _state.value .memory+i4).value .inClose : ( _state.value .memory+i4).value .inOpen ) ) + ( ( ( _state.value .memory+i4).value .inClose >= ( _state.value .memory+i4).value .inOpen ? ( _state.value .memory+i4).value .inOpen : ( _state.value .memory+i4).value .inClose ) - ( _state.value .memory+i4).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( ( _state.value .memory+i3).value .inClose - ( _state.value .memory+i3).value .inOpen ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? _state.value .BodyPeriodTotal3 / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i3).value .inClose - ( _state.value .memory+i3).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i3).value .inHigh - ( _state.value .memory+i3).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i3).value .inHigh - ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? ( _state.value .memory+i3).value .inClose : ( _state.value .memory+i3).value .inOpen ) ) + ( ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? ( _state.value .memory+i3).value .inOpen : ( _state.value .memory+i3).value .inClose ) - ( _state.value .memory+i3).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? _state.value .BodyPeriodTotal2 / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? _state.value .BodyPeriodTotal1 / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose - inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyPeriodTotal0 / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( _state.value .memory+i4).value .inClose >= ( _state.value .memory+i4).value .inOpen ? 1 : -1 ) == - ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? 1 : -1 ) &&
            ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? 1 : -1 ) == ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) &&
            ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) == ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) &&
            ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == - ( inClose >= inOpen ? 1 : -1 ) &&
            ((( ( _state.value .memory+i3).value .inOpen ) < ( ( _state.value .memory+i3).value .inClose )) ? ( ( _state.value .memory+i3).value .inOpen ) : ( ( _state.value .memory+i3).value .inClose )) < ( _state.value .memory+i4).value .inHigh && ((( ( _state.value .memory+i3).value .inOpen ) > ( ( _state.value .memory+i3).value .inClose )) ? ( ( _state.value .memory+i3).value .inOpen ) : ( ( _state.value .memory+i3).value .inClose )) > ( _state.value .memory+i4).value .inLow &&
            ((( ( _state.value .memory+i2).value .inOpen ) < ( ( _state.value .memory+i2).value .inClose )) ? ( ( _state.value .memory+i2).value .inOpen ) : ( ( _state.value .memory+i2).value .inClose )) < ( _state.value .memory+i4).value .inHigh && ((( ( _state.value .memory+i2).value .inOpen ) > ( ( _state.value .memory+i2).value .inClose )) ? ( ( _state.value .memory+i2).value .inOpen ) : ( ( _state.value .memory+i2).value .inClose )) > ( _state.value .memory+i4).value .inLow &&
            ((( ( _state.value .memory+i1).value .inOpen ) < ( ( _state.value .memory+i1).value .inClose )) ? ( ( _state.value .memory+i1).value .inOpen ) : ( ( _state.value .memory+i1).value .inClose )) < ( _state.value .memory+i4).value .inHigh && ((( ( _state.value .memory+i1).value .inOpen ) > ( ( _state.value .memory+i1).value .inClose )) ? ( ( _state.value .memory+i1).value .inOpen ) : ( ( _state.value .memory+i1).value .inClose )) > ( _state.value .memory+i4).value .inLow &&
            ( _state.value .memory+i2).value .inClose * ( ( _state.value .memory+i4).value .inClose >= ( _state.value .memory+i4).value .inOpen ? 1 : -1 ) < ( _state.value .memory+i3).value .inClose * ( ( _state.value .memory+i4).value .inClose >= ( _state.value .memory+i4).value .inOpen ? 1 : -1 ) &&
            ( _state.value .memory+i1).value .inClose * ( ( _state.value .memory+i4).value .inClose >= ( _state.value .memory+i4).value .inOpen ? 1 : -1 ) < ( _state.value .memory+i2).value .inClose * ( ( _state.value .memory+i4).value .inClose >= ( _state.value .memory+i4).value .inOpen ? 1 : -1 ) &&
            inOpen * ( ( _state.value .memory+i4).value .inClose >= ( _state.value .memory+i4).value .inOpen ? 1 : -1 ) > ( _state.value .memory+i1).value .inClose * ( ( _state.value .memory+i4).value .inClose >= ( _state.value .memory+i4).value .inOpen ? 1 : -1 ) &&
            inClose * ( ( _state.value .memory+i4).value .inClose >= ( _state.value .memory+i4).value .inOpen ? 1 : -1 ) > ( _state.value .memory+i4).value .inClose * ( ( _state.value .memory+i4).value .inClose >= ( _state.value .memory+i4).value .inOpen ? 1 : -1 )
            )
            outInteger.value = 100 * ( ( _state.value .memory+i4).value .inClose >= ( _state.value .memory+i4).value .inOpen ? 1 : -1 ) ;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .periodBodyShort)
      {
         _state.value .BodyPeriodTotal1 += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
         _state.value .BodyPeriodTotal2 += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
         _state.value .BodyPeriodTotal3 += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i3).value .inClose - ( _state.value .memory+i3).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i3).value .inHigh - ( _state.value .memory+i3).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i3).value .inHigh - ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? ( _state.value .memory+i3).value .inClose : ( _state.value .memory+i3).value .inOpen ) ) + ( ( ( _state.value .memory+i3).value .inClose >= ( _state.value .memory+i3).value .inOpen ? ( _state.value .memory+i3).value .inOpen : ( _state.value .memory+i3).value .inClose ) - ( _state.value .memory+i3).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .periodBodyLong)
      {
         _state.value .BodyPeriodTotal4 += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i4).value .inClose - ( _state.value .memory+i4).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i4).value .inHigh - ( _state.value .memory+i4).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i4).value .inHigh - ( ( _state.value .memory+i4).value .inClose >= ( _state.value .memory+i4).value .inOpen ? ( _state.value .memory+i4).value .inClose : ( _state.value .memory+i4).value .inOpen ) ) + ( ( ( _state.value .memory+i4).value .inClose >= ( _state.value .memory+i4).value .inOpen ? ( _state.value .memory+i4).value .inOpen : ( _state.value .memory+i4).value .inClose ) - ( _state.value .memory+i4).value .inLow ) : 0 ) ) ) ;
         _state.value .BodyPeriodTotal0 += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .BodyPeriodTotal1 -= ( - _state.value .periodBodyShort-1!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyPeriodTotal2 -= ( - _state.value .periodBodyShort-2!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-2)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-2)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-2)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-2)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-2)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-2)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-2)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-2)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-2)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-2)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyPeriodTotal3 -= ( - _state.value .periodBodyShort-3!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-3)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-3)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-3)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-3)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-3)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-3)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-3)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-3)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-3)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-3)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-3)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-3)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-3)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort-3)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyPeriodTotal4 -= ( - _state.value .periodBodyLong-4!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-4)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-4)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-4)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-4)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-4)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-4)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-4)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-4)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-4)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-4)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-4)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-4)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-4)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-4)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyPeriodTotal0 -= ( - _state.value .periodBodyLong!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlRiseFall3MethodsStateFree( struct TA_cdlRiseFall3Methods_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlRiseFall3MethodsStateSave( struct TA_cdlRiseFall3Methods_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLRISEFALL3METHODS_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyPeriodTotal0,sizeof( _state.value .BodyPeriodTotal0),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyPeriodTotal1,sizeof( _state.value .BodyPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyPeriodTotal2,sizeof( _state.value .BodyPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyPeriodTotal3,sizeof( _state.value .BodyPeriodTotal3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyPeriodTotal4,sizeof( _state.value .BodyPeriodTotal4),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyShort,sizeof( _state.value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyShort,sizeof( _state.value .gapBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyLong,sizeof( _state.value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyLong,sizeof( _state.value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlRiseFall3MethodsStateLoad( struct TA_cdlRiseFall3Methods_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlRiseFall3Methods ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLRISEFALL3METHODS_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLRISEFALL3METHODS_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyPeriodTotal0,sizeof( _state.value .value .BodyPeriodTotal0),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyPeriodTotal1,sizeof( _state.value .value .BodyPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyPeriodTotal2,sizeof( _state.value .value .BodyPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyPeriodTotal3,sizeof( _state.value .value .BodyPeriodTotal3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyPeriodTotal4,sizeof( _state.value .value .BodyPeriodTotal4),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyShort,sizeof( _state.value .value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyShort,sizeof( _state.value .value .gapBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyLong,sizeof( _state.value .value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyLong,sizeof( _state.value .value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlRiseFall3Methods( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []BodyPeriodTotal = new double[5] ;
      int i, outIdx, totIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlRiseFall3MethodsLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal[4] = 0;
      BodyPeriodTotal[3] = 0;
      BodyPeriodTotal[2] = 0;
      BodyPeriodTotal[1] = 0;
      BodyPeriodTotal[0] = 0;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal[3] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ;
         BodyPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         BodyPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal[4] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) ;
         BodyPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if(
            ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[4] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[3] / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[2] / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[1] / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[0] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) == - ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) &&
            ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) == ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == - ( inClose[i] >= inOpen[i] ? 1 : -1 ) &&
            (((inOpen[i-3]) < (inClose[i-3])) ? (inOpen[i-3]) : (inClose[i-3])) < inHigh[i-4] && (((inOpen[i-3]) > (inClose[i-3])) ? (inOpen[i-3]) : (inClose[i-3])) > inLow[i-4] &&
            (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) < inHigh[i-4] && (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) > inLow[i-4] &&
            (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < inHigh[i-4] && (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > inLow[i-4] &&
            inClose[i-2] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) < inClose[i-3] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) &&
            inClose[i-1] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) < inClose[i-2] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) &&
            inOpen[i] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) > inClose[i-1] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) &&
            inClose[i] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) > inClose[i-4] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 )
            )
            outInteger[outIdx++] = 100 * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) ;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal[4] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-4] - inOpen[BodyLongTrailingIdx-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-4] - inLow[BodyLongTrailingIdx-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-4] - ( inClose[BodyLongTrailingIdx-4] >= inOpen[BodyLongTrailingIdx-4] ? inClose[BodyLongTrailingIdx-4] : inOpen[BodyLongTrailingIdx-4] ) ) + ( ( inClose[BodyLongTrailingIdx-4] >= inOpen[BodyLongTrailingIdx-4] ? inOpen[BodyLongTrailingIdx-4] : inClose[BodyLongTrailingIdx-4] ) - inLow[BodyLongTrailingIdx-4] ) : 0 ) ) ) ;
         for (totIdx = 3; totIdx >= 1; --totIdx)
            BodyPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx-totIdx] - inOpen[BodyShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx-totIdx] - inLow[BodyShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx-totIdx] - ( inClose[BodyShortTrailingIdx-totIdx] >= inOpen[BodyShortTrailingIdx-totIdx] ? inClose[BodyShortTrailingIdx-totIdx] : inOpen[BodyShortTrailingIdx-totIdx] ) ) + ( ( inClose[BodyShortTrailingIdx-totIdx] >= inOpen[BodyShortTrailingIdx-totIdx] ? inOpen[BodyShortTrailingIdx-totIdx] : inClose[BodyShortTrailingIdx-totIdx] ) - inLow[BodyShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         BodyPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyShortTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlSeperatingLinesLookback( )
   {
      return ((( ((( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ) > ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) )) ? ( ((( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) )) +
         1;
   }
   public RetCode cdlSeperatingLines( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double ShadowVeryShortPeriodTotal, BodyLongPeriodTotal, EqualPeriodTotal;
      int i, outIdx, ShadowVeryShortTrailingIdx, BodyLongTrailingIdx, EqualTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlSeperatingLinesLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      EqualPeriodTotal = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == - ( inClose[i] >= inOpen[i] ? 1 : -1 ) &&
            inOpen[i] <= inOpen[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] >= inOpen[i-1] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            ( ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ||
            ( ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-1] - inOpen[EqualTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-1] - inLow[EqualTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-1] - ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inClose[EqualTrailingIdx-1] : inOpen[EqualTrailingIdx-1] ) ) + ( ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inOpen[EqualTrailingIdx-1] : inClose[EqualTrailingIdx-1] ) - inLow[EqualTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         ShadowVeryShortTrailingIdx++;
         BodyLongTrailingIdx++;
         EqualTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlSeperatingLinesStateInit( struct TA_cdlSeperatingLines_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlSeperatingLines ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlSeperatingLinesLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLSEPARATINGLINES_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlSeperatingLinesState( struct TA_cdlSeperatingLines_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .ShadowVeryShortPeriodTotal = 0.;
         _state.value .BodyLongPeriodTotal = 0.;
         _state.value .EqualPeriodTotal = 0.;
         _state.value .periodShadowVeryShort = (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
         _state.value .periodBodyLong = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
         _state.value .periodEqual = (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
         _state.value .gapShadowVeryShort = _state.value .mem_size - _state.value .periodShadowVeryShort;
         _state.value .gapBodyLong = _state.value .mem_size - _state.value .periodBodyLong;
         _state.value .gapEqual = _state.value .mem_size - _state.value .periodEqual;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == - ( inClose >= inOpen ? 1 : -1 ) &&
            inOpen <= ( _state.value .memory+i1).value .inOpen + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? _state.value .EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen >= ( _state.value .memory+i1).value .inOpen - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? _state.value .EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose - inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            ( ( inClose >= inOpen ? 1 : -1 ) == 1 &&
            ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ||
            ( ( inClose >= inOpen ? 1 : -1 ) == -1 &&
            ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            )
            outInteger.value = ( inClose >= inOpen ? 1 : -1 ) * 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadowVeryShort)
      {
         _state.value .ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyLong)
      {
         _state.value .BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapEqual)
      {
         _state.value .EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .ShadowVeryShortPeriodTotal -= ( - _state.value .periodShadowVeryShort!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyLongPeriodTotal -= ( - _state.value .periodBodyLong!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .EqualPeriodTotal -= ( - _state.value .periodEqual -1!=0?( ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual -1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      if ( _state.value .mem_size > 0)
      {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlSeperatingLinesStateFree( struct TA_cdlSeperatingLines_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlSeperatingLinesStateSave( struct TA_cdlSeperatingLines_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLSEPARATINGLINES_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal,sizeof( _state.value .ShadowVeryShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyLongPeriodTotal,sizeof( _state.value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .EqualPeriodTotal,sizeof( _state.value .EqualPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadowVeryShort,sizeof( _state.value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowVeryShort,sizeof( _state.value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyLong,sizeof( _state.value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyLong,sizeof( _state.value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapEqual,sizeof( _state.value .gapEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodEqual,sizeof( _state.value .periodEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlSeperatingLinesStateLoad( struct TA_cdlSeperatingLines_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlSeperatingLines ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLSEPARATINGLINES_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLSEPARATINGLINES_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal,sizeof( _state.value .value .ShadowVeryShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyLongPeriodTotal,sizeof( _state.value .value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .EqualPeriodTotal,sizeof( _state.value .value .EqualPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadowVeryShort,sizeof( _state.value .value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowVeryShort,sizeof( _state.value .value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyLong,sizeof( _state.value .value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyLong,sizeof( _state.value .value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapEqual,sizeof( _state.value .value .gapEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodEqual,sizeof( _state.value .value .periodEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlSeperatingLines( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double ShadowVeryShortPeriodTotal, BodyLongPeriodTotal, EqualPeriodTotal;
      int i, outIdx, ShadowVeryShortTrailingIdx, BodyLongTrailingIdx, EqualTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlSeperatingLinesLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      EqualPeriodTotal = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == - ( inClose[i] >= inOpen[i] ? 1 : -1 ) &&
            inOpen[i] <= inOpen[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] >= inOpen[i-1] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            ( ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ||
            ( ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-1] - inOpen[EqualTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-1] - inLow[EqualTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-1] - ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inClose[EqualTrailingIdx-1] : inOpen[EqualTrailingIdx-1] ) ) + ( ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inOpen[EqualTrailingIdx-1] : inClose[EqualTrailingIdx-1] ) - inLow[EqualTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         ShadowVeryShortTrailingIdx++;
         BodyLongTrailingIdx++;
         EqualTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlShootingStarLookback( )
   {
      return ((( ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ? ( ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) +
         1;
   }
   public RetCode cdlShootingStar( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal, ShadowLongPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, BodyTrailingIdx, ShadowLongTrailingIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlShootingStarLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i]) < (inClose[i])) ? (inOpen[i]) : (inClose[i])) > (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) ) )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx] - inOpen[ShadowLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx] - inLow[ShadowLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx] - ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inClose[ShadowLongTrailingIdx] : inOpen[ShadowLongTrailingIdx] ) ) + ( ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inOpen[ShadowLongTrailingIdx] : inClose[ShadowLongTrailingIdx] ) - inLow[ShadowLongTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
         ShadowLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlShootingStarStateInit( struct TA_cdlShootingStar_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlShootingStar ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlShootingStarLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLSHOOTINGSTAR_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlShootingStarState( struct TA_cdlShootingStar_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyPeriodTotal = 0.;
         _state.value .ShadowLongPeriodTotal = 0.;
         _state.value .ShadowVeryShortPeriodTotal = 0.;
         _state.value .periodBody = (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
         _state.value .periodShadowLong = (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
         _state.value .periodShadowVeryShort = (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
         _state.value .gapBody = _state.value .mem_size - _state.value .periodBody;
         _state.value .gapShadowLong = _state.value .mem_size - _state.value .periodShadowLong;
         _state.value .gapShadowVeryShort = _state.value .mem_size - _state.value .periodShadowVeryShort;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( Math.abs ( inClose - inOpen ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? _state.value .BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? _state.value .ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen) < (inClose)) ? (inOpen) : (inClose)) > ((( ( _state.value .memory+i1).value .inOpen ) > ( ( _state.value .memory+i1).value .inClose )) ? ( ( _state.value .memory+i1).value .inOpen ) : ( ( _state.value .memory+i1).value .inClose )) ) )
            outInteger.value = -100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBody)
      {
         _state.value .BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadowLong)
      {
         _state.value .ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadowVeryShort)
      {
         _state.value .ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .ShadowLongPeriodTotal -= ( - _state.value .periodShadowLong!=0?( ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowLong)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowVeryShortPeriodTotal -= ( - _state.value .periodShadowVeryShort!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyPeriodTotal -= ( - _state.value .periodBody!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlShootingStarStateFree( struct TA_cdlShootingStar_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlShootingStarStateSave( struct TA_cdlShootingStar_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLSHOOTINGSTAR_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyPeriodTotal,sizeof( _state.value .BodyPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowLongPeriodTotal,sizeof( _state.value .ShadowLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal,sizeof( _state.value .ShadowVeryShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBody,sizeof( _state.value .periodBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowLong,sizeof( _state.value .periodShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowVeryShort,sizeof( _state.value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBody,sizeof( _state.value .gapBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadowLong,sizeof( _state.value .gapShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadowVeryShort,sizeof( _state.value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlShootingStarStateLoad( struct TA_cdlShootingStar_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlShootingStar ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLSHOOTINGSTAR_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLSHOOTINGSTAR_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyPeriodTotal,sizeof( _state.value .value .BodyPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowLongPeriodTotal,sizeof( _state.value .value .ShadowLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal,sizeof( _state.value .value .ShadowVeryShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBody,sizeof( _state.value .value .periodBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowLong,sizeof( _state.value .value .periodShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowVeryShort,sizeof( _state.value .value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBody,sizeof( _state.value .value .gapBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadowLong,sizeof( _state.value .value .gapShadowLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadowVeryShort,sizeof( _state.value .value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlShootingStar( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal, ShadowLongPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, BodyTrailingIdx, ShadowLongTrailingIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlShootingStarLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i]) < (inClose[i])) ? (inOpen[i]) : (inClose[i])) > (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) ) )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx] - inOpen[ShadowLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx] - inLow[ShadowLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx] - ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inClose[ShadowLongTrailingIdx] : inOpen[ShadowLongTrailingIdx] ) ) + ( ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inOpen[ShadowLongTrailingIdx] : inClose[ShadowLongTrailingIdx] ) - inLow[ShadowLongTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
         ShadowLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlShortLineLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) )) ;
   }
   public RetCode cdlShortLine( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal, ShadowPeriodTotal;
      int i, outIdx, BodyTrailingIdx, ShadowTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlShortLineLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      ShadowPeriodTotal = 0;
      ShadowTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowTrailingIdx;
      while( i < startIdx ) {
         ShadowPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         ShadowPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowTrailingIdx] - inOpen[ShadowTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowTrailingIdx] - inLow[ShadowTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowTrailingIdx] - ( inClose[ShadowTrailingIdx] >= inOpen[ShadowTrailingIdx] ? inClose[ShadowTrailingIdx] : inOpen[ShadowTrailingIdx] ) ) + ( ( inClose[ShadowTrailingIdx] >= inOpen[ShadowTrailingIdx] ? inOpen[ShadowTrailingIdx] : inClose[ShadowTrailingIdx] ) - inLow[ShadowTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
         ShadowTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlShortLineStateInit( struct TA_cdlShortLine_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlShortLine ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlShortLineLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLSHORTLINE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlShortLineState( struct TA_cdlShortLine_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyPeriodTotal = 0.;
         _state.value .ShadowPeriodTotal = 0.;
         _state.value .periodBody = (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
         _state.value .periodShadow = (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) ;
         _state.value .gapShadow = _state.value .mem_size - _state.value .periodShadow;
         _state.value .gapBody = _state.value .mem_size - _state.value .periodBody;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( Math.abs ( inClose - inOpen ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? _state.value .BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) < ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) < ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            outInteger.value = ( inClose >= inOpen ? 1 : -1 ) * 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadow)
      {
         _state.value .ShadowPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBody)
      {
         _state.value .BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .ShadowPeriodTotal -= ( - _state.value .periodShadow!=0?( ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadow)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadow)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadow)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadow)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadow)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadow)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadow)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadow)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadow)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadow)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadow)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadow)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadow)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadow)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyPeriodTotal -= ( - _state.value .periodBody!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlShortLineStateFree( struct TA_cdlShortLine_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlShortLineStateSave( struct TA_cdlShortLine_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLSHORTLINE_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .ShadowPeriodTotal,sizeof( _state.value .ShadowPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadow,sizeof( _state.value .periodShadow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadow,sizeof( _state.value .gapShadow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyPeriodTotal,sizeof( _state.value .BodyPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBody,sizeof( _state.value .periodBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBody,sizeof( _state.value .gapBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlShortLineStateLoad( struct TA_cdlShortLine_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlShortLine ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLSHORTLINE_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLSHORTLINE_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .ShadowPeriodTotal,sizeof( _state.value .value .ShadowPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadow,sizeof( _state.value .value .periodShadow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadow,sizeof( _state.value .value .gapShadow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyPeriodTotal,sizeof( _state.value .value .BodyPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBody,sizeof( _state.value .value .periodBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBody,sizeof( _state.value .value .gapBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlShortLine( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal, ShadowPeriodTotal;
      int i, outIdx, BodyTrailingIdx, ShadowTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlShortLineLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      ShadowPeriodTotal = 0;
      ShadowTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowTrailingIdx;
      while( i < startIdx ) {
         ShadowPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         ShadowPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowTrailingIdx] - inOpen[ShadowTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowTrailingIdx] - inLow[ShadowTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowTrailingIdx] - ( inClose[ShadowTrailingIdx] >= inOpen[ShadowTrailingIdx] ? inClose[ShadowTrailingIdx] : inOpen[ShadowTrailingIdx] ) ) + ( ( inClose[ShadowTrailingIdx] >= inOpen[ShadowTrailingIdx] ? inOpen[ShadowTrailingIdx] : inClose[ShadowTrailingIdx] ) - inLow[ShadowTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
         ShadowTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlSpinningTopLookback( )
   {
      return (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
   }
   public RetCode cdlSpinningTop( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal;
      int i, outIdx, BodyTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlSpinningTopLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( Math.abs ( inClose[i] - inOpen[i] ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( Math.abs ( inClose[i] - inOpen[i] ) )
            )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlSpinningTopStateInit( struct TA_cdlSpinningTop_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlSpinningTop ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlSpinningTopLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLSPINNINGTOP_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlSpinningTopState( struct TA_cdlSpinningTop_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyPeriodTotal = 0.;
         _state.value .periodBody = (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
         _state.value .gapBody = _state.value .mem_size - _state.value .periodBody;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( Math.abs ( inClose - inOpen ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? _state.value .BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) > ( Math.abs ( inClose - inOpen ) ) &&
            ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) > ( Math.abs ( inClose - inOpen ) ) )
            outInteger.value = ( inClose >= inOpen ? 1 : -1 ) * 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBody)
      {
         _state.value .BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .BodyPeriodTotal -= ( - _state.value .periodBody!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlSpinningTopStateFree( struct TA_cdlSpinningTop_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlSpinningTopStateSave( struct TA_cdlSpinningTop_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLSPINNINGTOP_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyPeriodTotal,sizeof( _state.value .BodyPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBody,sizeof( _state.value .periodBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBody,sizeof( _state.value .gapBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlSpinningTopStateLoad( struct TA_cdlSpinningTop_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlSpinningTop ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLSPINNINGTOP_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLSPINNINGTOP_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyPeriodTotal,sizeof( _state.value .value .BodyPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBody,sizeof( _state.value .value .periodBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBody,sizeof( _state.value .value .gapBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlSpinningTop( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal;
      int i, outIdx, BodyTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlSpinningTopLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( Math.abs ( inClose[i] - inOpen[i] ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( Math.abs ( inClose[i] - inOpen[i] ) )
            )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlStalledPatternLookback( )
   {
      return ((( ((( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) ) > ( ((( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) )) ? ( ((( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) ) : ( ((( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) )) +
         2;
   }
   public RetCode cdlStalledPattern( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []BodyLongPeriodTotal = new double[3] ;
      double []NearPeriodTotal = new double[3] ;
      double BodyShortPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, totIdx, BodyLongTrailingIdx, BodyShortTrailingIdx, ShadowVeryShortTrailingIdx, NearTrailingIdx,
         lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlStalledPatternLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal[2] = 0;
      BodyLongPeriodTotal[1] = 0;
      BodyLongPeriodTotal[0] = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortPeriodTotal = 0;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      NearPeriodTotal[2] = 0;
      NearPeriodTotal[1] = 0;
      NearPeriodTotal[0] = 0;
      NearTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         BodyLongPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = NearTrailingIdx;
      while( i < startIdx ) {
         NearPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         NearPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inClose[i] > inClose[i-1] && inClose[i-1] > inClose[i-2] &&
            ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[2] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[1] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i-1] > inOpen[i-2] &&
            inOpen[i-1] <= inClose[i-2] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[2] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] >= inClose[i-1] - ( Math.abs ( inClose[i] - inOpen[i] ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[1] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 2; totIdx >= 1; --totIdx) {
            BodyLongPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-totIdx] - inOpen[BodyLongTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-totIdx] - inLow[BodyLongTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-totIdx] - ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inClose[BodyLongTrailingIdx-totIdx] : inOpen[BodyLongTrailingIdx-totIdx] ) ) + ( ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inOpen[BodyLongTrailingIdx-totIdx] : inClose[BodyLongTrailingIdx-totIdx] ) - inLow[BodyLongTrailingIdx-totIdx] ) : 0 ) ) ) ;
            NearPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-totIdx] - inOpen[NearTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-totIdx] - inLow[NearTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-totIdx] - ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inClose[NearTrailingIdx-totIdx] : inOpen[NearTrailingIdx-totIdx] ) ) + ( ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inOpen[NearTrailingIdx-totIdx] : inClose[NearTrailingIdx-totIdx] ) - inLow[NearTrailingIdx-totIdx] ) : 0 ) ) ) ;
         }
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-1] - inOpen[ShadowVeryShortTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-1] - inLow[ShadowVeryShortTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-1] - ( inClose[ShadowVeryShortTrailingIdx-1] >= inOpen[ShadowVeryShortTrailingIdx-1] ? inClose[ShadowVeryShortTrailingIdx-1] : inOpen[ShadowVeryShortTrailingIdx-1] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-1] >= inOpen[ShadowVeryShortTrailingIdx-1] ? inOpen[ShadowVeryShortTrailingIdx-1] : inClose[ShadowVeryShortTrailingIdx-1] ) - inLow[ShadowVeryShortTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
         NearTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlStalledPatternStateInit( struct TA_cdlStalledPattern_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlStalledPattern ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlStalledPatternLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLSTALLEDPATTERN_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlStalledPatternState( struct TA_cdlStalledPattern_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1, i2, i3;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyLongPeriodTotal1 = 0.;
         _state.value .BodyLongPeriodTotal2 = 0.;
         _state.value .periodBodyLong = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
         _state.value .gapBodyLong = _state.value .mem_size - _state.value .periodBodyLong;
         _state.value .BodyShortPeriodTotal = 0.;
         _state.value .periodBodyShort = (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
         _state.value .gapBodyShort = _state.value .mem_size - _state.value .periodBodyShort;
         _state.value .ShadowVeryShortPeriodTotal = 0.;
         _state.value .periodShadowVeryShort = (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
         _state.value .gapShadowVeryShort = _state.value .mem_size - _state.value .periodShadowVeryShort;
         _state.value .NearPeriodTotal1 = 0.;
         _state.value .NearPeriodTotal2 = 0.;
         _state.value .periodNear = (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
         _state.value .gapNear = _state.value .mem_size - _state.value .periodNear;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
      i3 = (( _state.value .mem_index-1+-3)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) == 1 &&
            ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == 1 &&
            ( inClose >= inOpen ? 1 : -1 ) == 1 &&
            inClose > ( _state.value .memory+i1).value .inClose && ( _state.value .memory+i1).value .inClose > ( _state.value .memory+i2).value .inClose &&
            ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal2 / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal1 / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( _state.value .memory+i1).value .inOpen > ( _state.value .memory+i2).value .inOpen &&
            ( _state.value .memory+i1).value .inOpen <= ( _state.value .memory+i2).value .inClose + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? _state.value .NearPeriodTotal2 / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose - inOpen ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? _state.value .BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen >= ( _state.value .memory+i1).value .inClose - ( Math.abs ( inClose - inOpen ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? _state.value .NearPeriodTotal1 / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger.value = -100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyLong)
      {
         _state.value .BodyLongPeriodTotal1 += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
         _state.value .BodyLongPeriodTotal2 += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyShort)
      {
         _state.value .BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadowVeryShort)
      {
         _state.value .ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapNear)
      {
         _state.value .NearPeriodTotal1 += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
         _state.value .NearPeriodTotal2 += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .BodyLongPeriodTotal1 -= ( - _state.value .periodBodyLong-1!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyLongPeriodTotal2 -= ( - _state.value .periodBodyLong-2!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-2)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyShortPeriodTotal -= ( - _state.value .periodBodyShort!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowVeryShortPeriodTotal -= ( - _state.value .periodShadowVeryShort!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .NearPeriodTotal1 -= ( - _state.value .periodNear-1!=0?( ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .NearPeriodTotal2 -= ( - _state.value .periodNear-2!=0?( ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-2)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlStalledPatternStateFree( struct TA_cdlStalledPattern_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlStalledPatternStateSave( struct TA_cdlStalledPattern_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLSTALLEDPATTERN_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyLongPeriodTotal1,sizeof( _state.value .BodyLongPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyLongPeriodTotal2,sizeof( _state.value .BodyLongPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyLong,sizeof( _state.value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyLong,sizeof( _state.value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyShortPeriodTotal,sizeof( _state.value .BodyShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyShort,sizeof( _state.value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyShort,sizeof( _state.value .gapBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal,sizeof( _state.value .ShadowVeryShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowVeryShort,sizeof( _state.value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadowVeryShort,sizeof( _state.value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .NearPeriodTotal1,sizeof( _state.value .NearPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .NearPeriodTotal2,sizeof( _state.value .NearPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodNear,sizeof( _state.value .periodNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapNear,sizeof( _state.value .gapNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlStalledPatternStateLoad( struct TA_cdlStalledPattern_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlStalledPattern ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLSTALLEDPATTERN_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLSTALLEDPATTERN_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyLongPeriodTotal1,sizeof( _state.value .value .BodyLongPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyLongPeriodTotal2,sizeof( _state.value .value .BodyLongPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyLong,sizeof( _state.value .value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyLong,sizeof( _state.value .value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyShortPeriodTotal,sizeof( _state.value .value .BodyShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyShort,sizeof( _state.value .value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyShort,sizeof( _state.value .value .gapBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal,sizeof( _state.value .value .ShadowVeryShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowVeryShort,sizeof( _state.value .value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadowVeryShort,sizeof( _state.value .value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .NearPeriodTotal1,sizeof( _state.value .value .NearPeriodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .NearPeriodTotal2,sizeof( _state.value .value .NearPeriodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodNear,sizeof( _state.value .value .periodNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapNear,sizeof( _state.value .value .gapNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlStalledPattern( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []BodyLongPeriodTotal = new double[3] ;
      double []NearPeriodTotal = new double[3] ;
      double BodyShortPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, totIdx, BodyLongTrailingIdx, BodyShortTrailingIdx, ShadowVeryShortTrailingIdx, NearTrailingIdx,
         lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlStalledPatternLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal[2] = 0;
      BodyLongPeriodTotal[1] = 0;
      BodyLongPeriodTotal[0] = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortPeriodTotal = 0;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      NearPeriodTotal[2] = 0;
      NearPeriodTotal[1] = 0;
      NearPeriodTotal[0] = 0;
      NearTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         BodyLongPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = NearTrailingIdx;
      while( i < startIdx ) {
         NearPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         NearPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inClose[i] > inClose[i-1] && inClose[i-1] > inClose[i-2] &&
            ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[2] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[1] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i-1] > inOpen[i-2] &&
            inOpen[i-1] <= inClose[i-2] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[2] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] >= inClose[i-1] - ( Math.abs ( inClose[i] - inOpen[i] ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[1] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 2; totIdx >= 1; --totIdx) {
            BodyLongPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-totIdx] - inOpen[BodyLongTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-totIdx] - inLow[BodyLongTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-totIdx] - ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inClose[BodyLongTrailingIdx-totIdx] : inOpen[BodyLongTrailingIdx-totIdx] ) ) + ( ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inOpen[BodyLongTrailingIdx-totIdx] : inClose[BodyLongTrailingIdx-totIdx] ) - inLow[BodyLongTrailingIdx-totIdx] ) : 0 ) ) ) ;
            NearPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-totIdx] - inOpen[NearTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-totIdx] - inLow[NearTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-totIdx] - ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inClose[NearTrailingIdx-totIdx] : inOpen[NearTrailingIdx-totIdx] ) ) + ( ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inOpen[NearTrailingIdx-totIdx] : inClose[NearTrailingIdx-totIdx] ) - inLow[NearTrailingIdx-totIdx] ) : 0 ) ) ) ;
         }
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-1] - inOpen[ShadowVeryShortTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-1] - inLow[ShadowVeryShortTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-1] - ( inClose[ShadowVeryShortTrailingIdx-1] >= inOpen[ShadowVeryShortTrailingIdx-1] ? inClose[ShadowVeryShortTrailingIdx-1] : inOpen[ShadowVeryShortTrailingIdx-1] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-1] >= inOpen[ShadowVeryShortTrailingIdx-1] ? inOpen[ShadowVeryShortTrailingIdx-1] : inClose[ShadowVeryShortTrailingIdx-1] ) - inLow[ShadowVeryShortTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
         NearTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlStickSandwhichLookback( )
   {
      return (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) + 2;
   }
   public RetCode cdlStickSandwhich( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double EqualPeriodTotal;
      int i, outIdx, EqualTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlStickSandwhichLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      EqualPeriodTotal = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inLow[i-1] > inClose[i-2] &&
            inClose[i] <= inClose[i-2] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] >= inClose[i-2] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-2] - inOpen[EqualTrailingIdx-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-2] - inLow[EqualTrailingIdx-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-2] - ( inClose[EqualTrailingIdx-2] >= inOpen[EqualTrailingIdx-2] ? inClose[EqualTrailingIdx-2] : inOpen[EqualTrailingIdx-2] ) ) + ( ( inClose[EqualTrailingIdx-2] >= inOpen[EqualTrailingIdx-2] ? inOpen[EqualTrailingIdx-2] : inClose[EqualTrailingIdx-2] ) - inLow[EqualTrailingIdx-2] ) : 0 ) ) ) ;
         i++;
         EqualTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlStickSandwhichStateInit( struct TA_cdlStickSandwhich_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlStickSandwhich ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlStickSandwhichLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLSTICKSANDWICH_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlStickSandwhichState( struct TA_cdlStickSandwhich_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1, i2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .EqualPeriodTotal = 0.;
         _state.value .periodEqual = (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
         _state.value .gapEqual = _state.value .mem_size - _state.value .periodEqual;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) == -1 &&
            ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == 1 &&
            ( inClose >= inOpen ? 1 : -1 ) == -1 &&
            ( _state.value .memory+i1).value .inLow > ( _state.value .memory+i2).value .inClose &&
            inClose <= ( _state.value .memory+i2).value .inClose + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? _state.value .EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose >= ( _state.value .memory+i2).value .inClose - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? _state.value .EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger.value = 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapEqual)
      {
         _state.value .EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .EqualPeriodTotal -= ( - _state.value .periodEqual-2!=0?( ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-2)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-2)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-2)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-2)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-2)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-2)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-2)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-2)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-2)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-2)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-2)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-2)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlStickSandwhichStateFree( struct TA_cdlStickSandwhich_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlStickSandwhichStateSave( struct TA_cdlStickSandwhich_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLSTICKSANDWICH_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .EqualPeriodTotal,sizeof( _state.value .EqualPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodEqual,sizeof( _state.value .periodEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapEqual,sizeof( _state.value .gapEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlStickSandwhichStateLoad( struct TA_cdlStickSandwhich_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlStickSandwhich ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLSTICKSANDWICH_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLSTICKSANDWICH_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .EqualPeriodTotal,sizeof( _state.value .value .EqualPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodEqual,sizeof( _state.value .value .periodEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapEqual,sizeof( _state.value .value .gapEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlStickSandwhich( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double EqualPeriodTotal;
      int i, outIdx, EqualTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlStickSandwhichLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      EqualPeriodTotal = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inLow[i-1] > inClose[i-2] &&
            inClose[i] <= inClose[i-2] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] >= inClose[i-2] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-2] - inOpen[EqualTrailingIdx-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-2] - inLow[EqualTrailingIdx-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-2] - ( inClose[EqualTrailingIdx-2] >= inOpen[EqualTrailingIdx-2] ? inClose[EqualTrailingIdx-2] : inOpen[EqualTrailingIdx-2] ) ) + ( ( inClose[EqualTrailingIdx-2] >= inOpen[EqualTrailingIdx-2] ? inOpen[EqualTrailingIdx-2] : inClose[EqualTrailingIdx-2] ) - inLow[EqualTrailingIdx-2] ) : 0 ) ) ) ;
         i++;
         EqualTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlTakuriLookback( )
   {
      return ((( ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) )) ? ( ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) )) ;
   }
   public RetCode cdlTakuri( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, ShadowVeryShortPeriodTotal, ShadowVeryLongPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, ShadowVeryShortTrailingIdx, ShadowVeryLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlTakuriLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyDojiPeriodTotal = 0;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      ShadowVeryLongPeriodTotal = 0;
      ShadowVeryLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) ;
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryLongTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) != 0.0? ShadowVeryLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryLongTrailingIdx] - inOpen[ShadowVeryLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryLongTrailingIdx] - inLow[ShadowVeryLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryLongTrailingIdx] - ( inClose[ShadowVeryLongTrailingIdx] >= inOpen[ShadowVeryLongTrailingIdx] ? inClose[ShadowVeryLongTrailingIdx] : inOpen[ShadowVeryLongTrailingIdx] ) ) + ( ( inClose[ShadowVeryLongTrailingIdx] >= inOpen[ShadowVeryLongTrailingIdx] ? inOpen[ShadowVeryLongTrailingIdx] : inClose[ShadowVeryLongTrailingIdx] ) - inLow[ShadowVeryLongTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyDojiTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
         ShadowVeryLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlTakuriStateInit( struct TA_cdlTakuri_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlTakuri ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlTakuriLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLTAKURI_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlTakuriState( struct TA_cdlTakuri_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .ShadowVeryShortPeriodTotal = 0.;
         _state.value .ShadowVeryLongPeriodTotal = 0.;
         _state.value .BodyDojiPeriodTotal = 0.;
         _state.value .periodBodyDoji = (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
         _state.value .periodShadowVeryShort = (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
         _state.value .periodShadowVeryLong = (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) ;
         _state.value .gapBodyDoji = _state.value .mem_size - _state.value .periodBodyDoji;
         _state.value .gapShadowVeryShort = _state.value .mem_size - _state.value .periodShadowVeryShort;
         _state.value .gapShadowVeryLong = _state.value .mem_size - _state.value .periodShadowVeryLong;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( Math.abs ( inClose - inOpen ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? _state.value .BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) > ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) != 0.0? _state.value .ShadowVeryLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger.value = 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyDoji)
      {
         _state.value .BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadowVeryShort)
      {
         _state.value .ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapShadowVeryLong)
      {
         _state.value .ShadowVeryLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .BodyDojiPeriodTotal -= ( - _state.value .periodBodyDoji!=0?( ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyDoji)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowVeryShortPeriodTotal -= ( - _state.value .periodShadowVeryShort!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .ShadowVeryLongPeriodTotal -= ( - _state.value .periodShadowVeryLong!=0?( ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryLong)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryLong)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryLong)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryLong)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryLong)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryLong)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryLong)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryLong)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryLong)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodShadowVeryLong)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      if ( _state.value .mem_size > 0)
      {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlTakuriStateFree( struct TA_cdlTakuri_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlTakuriStateSave( struct TA_cdlTakuri_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLTAKURI_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyDojiPeriodTotal,sizeof( _state.value .BodyDojiPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowVeryShortPeriodTotal,sizeof( _state.value .ShadowVeryShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ShadowVeryLongPeriodTotal,sizeof( _state.value .ShadowVeryLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyDoji,sizeof( _state.value .periodBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyDoji,sizeof( _state.value .gapBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowVeryShort,sizeof( _state.value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadowVeryShort,sizeof( _state.value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodShadowVeryLong,sizeof( _state.value .periodShadowVeryLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapShadowVeryLong,sizeof( _state.value .gapShadowVeryLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlTakuriStateLoad( struct TA_cdlTakuri_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlTakuri ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLTAKURI_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLTAKURI_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyDojiPeriodTotal,sizeof( _state.value .value .BodyDojiPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowVeryShortPeriodTotal,sizeof( _state.value .value .ShadowVeryShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ShadowVeryLongPeriodTotal,sizeof( _state.value .value .ShadowVeryLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyDoji,sizeof( _state.value .value .periodBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyDoji,sizeof( _state.value .value .gapBodyDoji),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowVeryShort,sizeof( _state.value .value .periodShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadowVeryShort,sizeof( _state.value .value .gapShadowVeryShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodShadowVeryLong,sizeof( _state.value .value .periodShadowVeryLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapShadowVeryLong,sizeof( _state.value .value .gapShadowVeryLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlTakuri( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, ShadowVeryShortPeriodTotal, ShadowVeryLongPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, ShadowVeryShortTrailingIdx, ShadowVeryLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlTakuriLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyDojiPeriodTotal = 0;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      ShadowVeryLongPeriodTotal = 0;
      ShadowVeryLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) ;
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryLongTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) != 0.0? ShadowVeryLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryLongTrailingIdx] - inOpen[ShadowVeryLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryLongTrailingIdx] - inLow[ShadowVeryLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryLongTrailingIdx] - ( inClose[ShadowVeryLongTrailingIdx] >= inOpen[ShadowVeryLongTrailingIdx] ? inClose[ShadowVeryLongTrailingIdx] : inOpen[ShadowVeryLongTrailingIdx] ) ) + ( ( inClose[ShadowVeryLongTrailingIdx] >= inOpen[ShadowVeryLongTrailingIdx] ? inOpen[ShadowVeryLongTrailingIdx] : inClose[ShadowVeryLongTrailingIdx] ) - inLow[ShadowVeryLongTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyDojiTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
         ShadowVeryLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlTasukiGapLookback( )
   {
      return (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) + 2;
   }
   public RetCode cdlTasukiGap( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double NearPeriodTotal;
      int i, outIdx, NearTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlTasukiGapLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      NearPeriodTotal = 0;
      NearTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      i = NearTrailingIdx;
      while( i < startIdx ) {
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if(
            (
            ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inOpen[i] < inClose[i-1] && inOpen[i] > inOpen[i-1] &&
            inClose[i] < inOpen[i-1] &&
            inClose[i] > (((inClose[i-2]) > (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) &&
            Math.abs ( ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) - ( Math.abs ( inClose[i] - inOpen[i] ) ) ) < ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ) ||
            (
            ( (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inOpen[i] < inOpen[i-1] && inOpen[i] > inClose[i-1] &&
            inClose[i] > inOpen[i-1] &&
            inClose[i] < (((inClose[i-2]) < (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) &&
            Math.abs ( ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) - ( Math.abs ( inClose[i] - inOpen[i] ) ) ) < ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            outInteger[outIdx++] = ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-1] - inOpen[NearTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-1] - inLow[NearTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-1] - ( inClose[NearTrailingIdx-1] >= inOpen[NearTrailingIdx-1] ? inClose[NearTrailingIdx-1] : inOpen[NearTrailingIdx-1] ) ) + ( ( inClose[NearTrailingIdx-1] >= inOpen[NearTrailingIdx-1] ? inOpen[NearTrailingIdx-1] : inClose[NearTrailingIdx-1] ) - inLow[NearTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         NearTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlTasukiGapStateInit( struct TA_cdlTasukiGap_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlTasukiGap ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlTasukiGapLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLTASUKIGAP_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlTasukiGapState( struct TA_cdlTasukiGap_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1, i2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .NearPeriodTotal = 0.;
         _state.value .periodNear = (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
         _state.value .gapNear = _state.value .mem_size - _state.value .periodNear;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if(
            (
            ( ((( ( _state.value .memory+i1).value .inOpen ) < ( ( _state.value .memory+i1).value .inClose )) ? ( ( _state.value .memory+i1).value .inOpen ) : ( ( _state.value .memory+i1).value .inClose )) > ((( ( _state.value .memory+i2).value .inOpen ) > ( ( _state.value .memory+i2).value .inClose )) ? ( ( _state.value .memory+i2).value .inOpen ) : ( ( _state.value .memory+i2).value .inClose )) ) &&
            ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == 1 &&
            ( inClose >= inOpen ? 1 : -1 ) == -1 &&
            inOpen < ( _state.value .memory+i1).value .inClose && inOpen > ( _state.value .memory+i1).value .inOpen &&
            inClose < ( _state.value .memory+i1).value .inOpen &&
            inClose > ((( ( _state.value .memory+i2).value .inClose ) > ( ( _state.value .memory+i2).value .inOpen )) ? ( ( _state.value .memory+i2).value .inClose ) : ( ( _state.value .memory+i2).value .inOpen )) &&
            Math.abs ( ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) - ( Math.abs ( inClose - inOpen ) ) ) < ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? _state.value .NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ) ||
            (
            ( ((( ( _state.value .memory+i1).value .inOpen ) > ( ( _state.value .memory+i1).value .inClose )) ? ( ( _state.value .memory+i1).value .inOpen ) : ( ( _state.value .memory+i1).value .inClose )) < ((( ( _state.value .memory+i2).value .inOpen ) < ( ( _state.value .memory+i2).value .inClose )) ? ( ( _state.value .memory+i2).value .inOpen ) : ( ( _state.value .memory+i2).value .inClose )) ) &&
            ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == -1 &&
            ( inClose >= inOpen ? 1 : -1 ) == 1 &&
            inOpen < ( _state.value .memory+i1).value .inOpen && inOpen > ( _state.value .memory+i1).value .inClose &&
            inClose > ( _state.value .memory+i1).value .inOpen &&
            inClose < ((( ( _state.value .memory+i2).value .inClose ) < ( ( _state.value .memory+i2).value .inOpen )) ? ( ( _state.value .memory+i2).value .inClose ) : ( ( _state.value .memory+i2).value .inOpen )) &&
            Math.abs ( ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) - ( Math.abs ( inClose - inOpen ) ) ) < ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? _state.value .NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            outInteger.value = ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) * 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapNear)
      {
         _state.value .NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .NearPeriodTotal -= ( - _state.value .periodNear-1!=0?( ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodNear-1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlTasukiGapStateFree( struct TA_cdlTasukiGap_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlTasukiGapStateSave( struct TA_cdlTasukiGap_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLTASUKIGAP_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .NearPeriodTotal,sizeof( _state.value .NearPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodNear,sizeof( _state.value .periodNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapNear,sizeof( _state.value .gapNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlTasukiGapStateLoad( struct TA_cdlTasukiGap_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlTasukiGap ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLTASUKIGAP_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLTASUKIGAP_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .NearPeriodTotal,sizeof( _state.value .value .NearPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodNear,sizeof( _state.value .value .periodNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapNear,sizeof( _state.value .value .gapNear),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlTasukiGap( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double NearPeriodTotal;
      int i, outIdx, NearTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlTasukiGapLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      NearPeriodTotal = 0;
      NearTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      i = NearTrailingIdx;
      while( i < startIdx ) {
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if(
            (
            ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inOpen[i] < inClose[i-1] && inOpen[i] > inOpen[i-1] &&
            inClose[i] < inOpen[i-1] &&
            inClose[i] > (((inClose[i-2]) > (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) &&
            Math.abs ( ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) - ( Math.abs ( inClose[i] - inOpen[i] ) ) ) < ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ) ||
            (
            ( (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inOpen[i] < inOpen[i-1] && inOpen[i] > inClose[i-1] &&
            inClose[i] > inOpen[i-1] &&
            inClose[i] < (((inClose[i-2]) < (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) &&
            Math.abs ( ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) - ( Math.abs ( inClose[i] - inOpen[i] ) ) ) < ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            outInteger[outIdx++] = ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-1] - inOpen[NearTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-1] - inLow[NearTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-1] - ( inClose[NearTrailingIdx-1] >= inOpen[NearTrailingIdx-1] ? inClose[NearTrailingIdx-1] : inOpen[NearTrailingIdx-1] ) ) + ( ( inClose[NearTrailingIdx-1] >= inOpen[NearTrailingIdx-1] ? inOpen[NearTrailingIdx-1] : inClose[NearTrailingIdx-1] ) - inLow[NearTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         NearTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlThrustingLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) +
         1;
   }
   public RetCode cdlThrusting( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double EqualPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, EqualTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlThrustingLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      EqualPeriodTotal = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inOpen[i] < inLow[i-1] &&
            inClose[i] > inClose[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] <= inClose[i-1] + ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) * 0.5
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-1] - inOpen[EqualTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-1] - inLow[EqualTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-1] - ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inClose[EqualTrailingIdx-1] : inOpen[EqualTrailingIdx-1] ) ) + ( ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inOpen[EqualTrailingIdx-1] : inClose[EqualTrailingIdx-1] ) - inLow[EqualTrailingIdx-1] ) : 0 ) ) ) ;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-1] - inOpen[BodyLongTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-1] - inLow[BodyLongTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-1] - ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inClose[BodyLongTrailingIdx-1] : inOpen[BodyLongTrailingIdx-1] ) ) + ( ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inOpen[BodyLongTrailingIdx-1] : inClose[BodyLongTrailingIdx-1] ) - inLow[BodyLongTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         EqualTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlThrustingStateInit( struct TA_cdlThrusting_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlThrusting ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlThrustingLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLTHRUSTING_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlThrustingState( struct TA_cdlThrusting_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .EqualPeriodTotal = 0.;
         _state.value .periodEqual = (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
         _state.value .gapEqual = _state.value .mem_size - _state.value .periodEqual;
         _state.value .BodyLongPeriodTotal = 0.;
         _state.value .periodBodyLong = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
         _state.value .gapBodyLong = _state.value .mem_size - _state.value .periodBodyLong;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == -1 &&
            ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose >= inOpen ? 1 : -1 ) == 1 &&
            inOpen < ( _state.value .memory+i1).value .inLow &&
            inClose > ( _state.value .memory+i1).value .inClose + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? _state.value .EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose <= ( _state.value .memory+i1).value .inClose + ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) * 0.5
            )
            outInteger.value = -100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapEqual)
      {
         _state.value .EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyLong)
      {
         _state.value .BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .EqualPeriodTotal -= ( - _state.value .periodEqual-1!=0?( ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodEqual-1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyLongPeriodTotal -= ( - _state.value .periodBodyLong-1!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong-1)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlThrustingStateFree( struct TA_cdlThrusting_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlThrustingStateSave( struct TA_cdlThrusting_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLTHRUSTING_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .EqualPeriodTotal,sizeof( _state.value .EqualPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodEqual,sizeof( _state.value .periodEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapEqual,sizeof( _state.value .gapEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyLongPeriodTotal,sizeof( _state.value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyLong,sizeof( _state.value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyLong,sizeof( _state.value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlThrustingStateLoad( struct TA_cdlThrusting_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlThrusting ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLTHRUSTING_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLTHRUSTING_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .EqualPeriodTotal,sizeof( _state.value .value .EqualPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodEqual,sizeof( _state.value .value .periodEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapEqual,sizeof( _state.value .value .gapEqual),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyLongPeriodTotal,sizeof( _state.value .value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyLong,sizeof( _state.value .value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyLong,sizeof( _state.value .value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlThrusting( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double EqualPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, EqualTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlThrustingLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      EqualPeriodTotal = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inOpen[i] < inLow[i-1] &&
            inClose[i] > inClose[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] <= inClose[i-1] + ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) * 0.5
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-1] - inOpen[EqualTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-1] - inLow[EqualTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-1] - ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inClose[EqualTrailingIdx-1] : inOpen[EqualTrailingIdx-1] ) ) + ( ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inOpen[EqualTrailingIdx-1] : inClose[EqualTrailingIdx-1] ) - inLow[EqualTrailingIdx-1] ) : 0 ) ) ) ;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-1] - inOpen[BodyLongTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-1] - inLow[BodyLongTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-1] - ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inClose[BodyLongTrailingIdx-1] : inOpen[BodyLongTrailingIdx-1] ) ) + ( ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inOpen[BodyLongTrailingIdx-1] : inClose[BodyLongTrailingIdx-1] ) - inLow[BodyLongTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         EqualTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlTristarLookback( )
   {
      return (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) + 2;
   }
   public RetCode cdlTristar( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal;
      int i, outIdx, BodyTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlTristarLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx-2 ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) ) {
            outInteger[outIdx] = 0;
            if ( ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) )
               &&
               (((inOpen[i]) > (inClose[i])) ? (inOpen[i]) : (inClose[i])) < (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1]))
               )
               outInteger[outIdx] = -100;
            if ( ( (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) )
               &&
               (((inOpen[i]) < (inClose[i])) ? (inOpen[i]) : (inClose[i])) > (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1]))
               )
               outInteger[outIdx] = +100;
            outIdx++;
         }
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlTristarStateInit( struct TA_cdlTristar_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlTristar ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlTristarLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLTRISTAR_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlTristarState( struct TA_cdlTristar_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1, i2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyPeriodTotal = 0.;
         _state.value .periodBody = (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) + 2;
         _state.value .gapBody = _state.value .mem_size - _state.value .periodBody;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? _state.value .BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? _state.value .BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose - inOpen ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? _state.value .BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) ) {
            outInteger.value = 0;
            if ( ( ((( ( _state.value .memory+i1).value .inOpen ) < ( ( _state.value .memory+i1).value .inClose )) ? ( ( _state.value .memory+i1).value .inOpen ) : ( ( _state.value .memory+i1).value .inClose )) > ((( ( _state.value .memory+i2).value .inOpen ) > ( ( _state.value .memory+i2).value .inClose )) ? ( ( _state.value .memory+i2).value .inOpen ) : ( ( _state.value .memory+i2).value .inClose )) )
               &&
               (((inOpen) > (inClose)) ? (inOpen) : (inClose)) < ((( ( _state.value .memory+i1).value .inOpen ) > ( ( _state.value .memory+i1).value .inClose )) ? ( ( _state.value .memory+i1).value .inOpen ) : ( ( _state.value .memory+i1).value .inClose ))
               )
               outInteger.value = -100;
            if ( ( ((( ( _state.value .memory+i1).value .inOpen ) > ( ( _state.value .memory+i1).value .inClose )) ? ( ( _state.value .memory+i1).value .inOpen ) : ( ( _state.value .memory+i1).value .inClose )) < ((( ( _state.value .memory+i2).value .inOpen ) < ( ( _state.value .memory+i2).value .inClose )) ? ( ( _state.value .memory+i2).value .inOpen ) : ( ( _state.value .memory+i2).value .inClose )) )
               &&
               (((inOpen) < (inClose)) ? (inOpen) : (inClose)) > ((( ( _state.value .memory+i1).value .inOpen ) < ( ( _state.value .memory+i1).value .inClose )) ? ( ( _state.value .memory+i1).value .inOpen ) : ( ( _state.value .memory+i1).value .inClose ))
               )
               outInteger.value = +100;
         }
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBody)
      {
         _state.value .BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .BodyPeriodTotal -= ( - _state.value .periodBody!=0?( ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBody)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlTristarStateFree( struct TA_cdlTristar_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlTristarStateSave( struct TA_cdlTristar_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLTRISTAR_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyPeriodTotal,sizeof( _state.value .BodyPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBody,sizeof( _state.value .periodBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBody,sizeof( _state.value .gapBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlTristarStateLoad( struct TA_cdlTristar_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlTristar ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLTRISTAR_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLTRISTAR_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyPeriodTotal,sizeof( _state.value .value .BodyPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBody,sizeof( _state.value .value .periodBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBody,sizeof( _state.value .value .gapBody),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlTristar( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal;
      int i, outIdx, BodyTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlTristarLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx-2 ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) ) {
            outInteger[outIdx] = 0;
            if ( ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) )
               &&
               (((inOpen[i]) > (inClose[i])) ? (inOpen[i]) : (inClose[i])) < (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1]))
               )
               outInteger[outIdx] = -100;
            if ( ( (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) )
               &&
               (((inOpen[i]) < (inClose[i])) ? (inOpen[i]) : (inClose[i])) > (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1]))
               )
               outInteger[outIdx] = +100;
            outIdx++;
         }
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlUnique3RiverLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) + 2;
   }
   public RetCode cdlUnique3River( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyShortPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlUnique3RiverLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            inClose[i-1] > inClose[i-2] && inOpen[i-1] <= inOpen[i-2] &&
            inLow[i-1] < inLow[i-2] &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inOpen[i] > inLow[i-1]
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlUnique3RiverStateInit( struct TA_cdlUnique3River_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlUnique3River ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlUnique3RiverLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLUNIQUE3RIVER_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlUnique3RiverState( struct TA_cdlUnique3River_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1,i2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyShortPeriodTotal = 0.;
         _state.value .periodBodyShort = (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
         _state.value .gapBodyShort = _state.value .mem_size - _state.value .periodBodyShort;
         _state.value .BodyLongPeriodTotal = 0.;
         _state.value .periodBodyLong = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) + 2;
         _state.value .gapBodyLong = _state.value .mem_size - _state.value .periodBodyLong;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) == -1 &&
            ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == -1 &&
            ( _state.value .memory+i1).value .inClose > ( _state.value .memory+i2).value .inClose && ( _state.value .memory+i1).value .inOpen <= ( _state.value .memory+i2).value .inOpen &&
            ( _state.value .memory+i1).value .inLow < ( _state.value .memory+i2).value .inLow &&
            ( Math.abs ( inClose - inOpen ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? _state.value .BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose >= inOpen ? 1 : -1 ) == 1 &&
            inOpen > ( _state.value .memory+i1).value .inLow
            )
            outInteger.value = 100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyShort)
      {
         _state.value .BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyLong)
      {
         _state.value .BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .BodyShortPeriodTotal -= ( - _state.value .periodBodyShort!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyLongPeriodTotal -= ( - _state.value .periodBodyLong!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlUnique3RiverStateFree( struct TA_cdlUnique3River_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlUnique3RiverStateSave( struct TA_cdlUnique3River_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLUNIQUE3RIVER_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyLongPeriodTotal,sizeof( _state.value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyShortPeriodTotal,sizeof( _state.value .BodyShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyLong,sizeof( _state.value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyLong,sizeof( _state.value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyShort,sizeof( _state.value .gapBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyShort,sizeof( _state.value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlUnique3RiverStateLoad( struct TA_cdlUnique3River_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlUnique3River ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLUNIQUE3RIVER_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLUNIQUE3RIVER_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyLongPeriodTotal,sizeof( _state.value .value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyShortPeriodTotal,sizeof( _state.value .value .BodyShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyLong,sizeof( _state.value .value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyLong,sizeof( _state.value .value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyShort,sizeof( _state.value .value .gapBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyShort,sizeof( _state.value .value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlUnique3River( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyShortPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlUnique3RiverLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            inClose[i-1] > inClose[i-2] && inOpen[i-1] <= inOpen[i-2] &&
            inLow[i-1] < inLow[i-2] &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inOpen[i] > inLow[i-1]
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlUpsideGap2CrowsLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) + 2;
   }
   public RetCode cdlUpsideGap2Crows( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyShortPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlUpsideGap2CrowsLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx-1 ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inOpen[i] > inOpen[i-1] && inClose[i] < inClose[i-1] &&
            inClose[i] > inClose[i-2]
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlUpsideGap2CrowsStateInit( struct TA_cdlUpsideGap2Crows_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlUpsideGap2Crows ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlUpsideGap2CrowsLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLUPSIDEGAP2CROWS_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlUpsideGap2CrowsState( struct TA_cdlUpsideGap2Crows_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1,i2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .BodyShortPeriodTotal = 0.;
         _state.value .periodBodyShort = (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) + 1;
         _state.value .gapBodyShort = _state.value .mem_size - _state.value .periodBodyShort;
         _state.value .BodyLongPeriodTotal = 0.;
         _state.value .periodBodyLong = (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) + 2;
         _state.value .gapBodyLong = _state.value .mem_size - _state.value .periodBodyLong;
      }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         if( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) == 1 &&
            ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? _state.value .BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == -1 &&
            ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? _state.value .BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ((( ( _state.value .memory+i1).value .inOpen ) < ( ( _state.value .memory+i1).value .inClose )) ? ( ( _state.value .memory+i1).value .inOpen ) : ( ( _state.value .memory+i1).value .inClose )) > ((( ( _state.value .memory+i2).value .inOpen ) > ( ( _state.value .memory+i2).value .inClose )) ? ( ( _state.value .memory+i2).value .inOpen ) : ( ( _state.value .memory+i2).value .inClose )) ) &&
            ( inClose >= inOpen ? 1 : -1 ) == -1 &&
            inOpen > ( _state.value .memory+i1).value .inOpen && inClose < ( _state.value .memory+i1).value .inClose &&
            inClose > ( _state.value .memory+i2).value .inClose
            )
            outInteger.value = -100;
         else
            outInteger.value = 0;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyShort)
      {
         _state.value .BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i1).value .inClose - ( _state.value .memory+i1).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i1).value .inHigh - ( _state.value .memory+i1).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i1).value .inHigh - ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inClose : ( _state.value .memory+i1).value .inOpen ) ) + ( ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? ( _state.value .memory+i1).value .inOpen : ( _state.value .memory+i1).value .inClose ) - ( _state.value .memory+i1).value .inLow ) : 0 ) ) ) ;
      }
      if ((int) _state.value .mem_index-1 >= _state.value .gapBodyLong)
      {
         _state.value .BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+i2).value .inClose - ( _state.value .memory+i2).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+i2).value .inHigh - ( _state.value .memory+i2).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+i2).value .inHigh - ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inClose : ( _state.value .memory+i2).value .inOpen ) ) + ( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? ( _state.value .memory+i2).value .inOpen : ( _state.value .memory+i2).value .inClose ) - ( _state.value .memory+i2).value .inLow ) : 0 ) ) ) ;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         _state.value .BodyShortPeriodTotal -= ( - _state.value .periodBodyShort!=0?( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyShort)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
         _state.value .BodyLongPeriodTotal -= ( - _state.value .periodBodyLong!=0?( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inHigh - ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ) ) + ( ( ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose >= ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen ? ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inOpen : ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inClose ) - ( _state.value .memory+(( _state.value .mem_index-1+- _state.value .periodBodyLong)% _state.value .mem_size ) ).value .inLow ) : 0 ) ) ) ):( ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose - inOpen ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh - inLow ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh - ( inClose >= inOpen ? inClose : inOpen ) ) + ( ( inClose >= inOpen ? inOpen : inClose ) - inLow ) : 0 ) ) ) ) ) ;
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode cdlUpsideGap2CrowsStateFree( struct TA_cdlUpsideGap2Crows_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlUpsideGap2CrowsStateSave( struct TA_cdlUpsideGap2Crows_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLUPSIDEGAP2CROWS_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .BodyLongPeriodTotal,sizeof( _state.value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .BodyShortPeriodTotal,sizeof( _state.value .BodyShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyLong,sizeof( _state.value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyLong,sizeof( _state.value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gapBodyShort,sizeof( _state.value .gapBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodBodyShort,sizeof( _state.value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlUpsideGap2CrowsStateLoad( struct TA_cdlUpsideGap2Crows_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlUpsideGap2Crows ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLUPSIDEGAP2CROWS_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLUPSIDEGAP2CROWS_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .BodyLongPeriodTotal,sizeof( _state.value .value .BodyLongPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .BodyShortPeriodTotal,sizeof( _state.value .value .BodyShortPeriodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyLong,sizeof( _state.value .value .gapBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyLong,sizeof( _state.value .value .periodBodyLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gapBodyShort,sizeof( _state.value .value .gapBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodBodyShort,sizeof( _state.value .value .periodBodyShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cdlUpsideGap2Crows( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyShortPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlUpsideGap2CrowsLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx-1 ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inOpen[i] > inOpen[i-1] && inClose[i] < inClose[i-1] &&
            inClose[i] > inClose[i-2]
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlXSideGap3MethodsLookback( )
   {
      return 2;
   }
   public RetCode cdlXSideGap3Methods( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      int i, outIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlXSideGap3MethodsLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == - ( inClose[i] >= inOpen[i] ? 1 : -1 ) &&
            inOpen[i] < (((inClose[i-1]) > (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) &&
            inOpen[i] > (((inClose[i-1]) < (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) &&
            inClose[i] < (((inClose[i-2]) > (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) &&
            inClose[i] > (((inClose[i-2]) < (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) &&
            ( (
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) )
            ) ||
            (
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) )
            )
            )
            )
            outInteger[outIdx++] = ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         i++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cdlXSideGap3MethodsStateInit( struct TA_cdlXSideGap3Methods_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlXSideGap3Methods ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlXSideGap3MethodsLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLXSIDEGAP3METHODS_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cdlXSideGap3MethodsState( struct TA_cdlXSideGap3Methods_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      int i1,i2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      i1 = (( _state.value .mem_index-1+-1)% _state.value .mem_size ) ;
      i2 = (( _state.value .mem_index-1+-2)% _state.value .mem_size ) ;
      if( ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) == ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) &&
         ( ( _state.value .memory+i1).value .inClose >= ( _state.value .memory+i1).value .inOpen ? 1 : -1 ) == - ( inClose >= inOpen ? 1 : -1 ) &&
         inOpen < ((( ( _state.value .memory+i1).value .inClose ) > ( ( _state.value .memory+i1).value .inOpen )) ? ( ( _state.value .memory+i1).value .inClose ) : ( ( _state.value .memory+i1).value .inOpen )) &&
         inOpen > ((( ( _state.value .memory+i1).value .inClose ) < ( ( _state.value .memory+i1).value .inOpen )) ? ( ( _state.value .memory+i1).value .inClose ) : ( ( _state.value .memory+i1).value .inOpen )) &&
         inClose < ((( ( _state.value .memory+i2).value .inClose ) > ( ( _state.value .memory+i2).value .inOpen )) ? ( ( _state.value .memory+i2).value .inClose ) : ( ( _state.value .memory+i2).value .inOpen )) &&
         inClose > ((( ( _state.value .memory+i2).value .inClose ) < ( ( _state.value .memory+i2).value .inOpen )) ? ( ( _state.value .memory+i2).value .inClose ) : ( ( _state.value .memory+i2).value .inOpen )) &&
         ( (
         ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) == 1 &&
         ( ((( ( _state.value .memory+i1).value .inOpen ) < ( ( _state.value .memory+i1).value .inClose )) ? ( ( _state.value .memory+i1).value .inOpen ) : ( ( _state.value .memory+i1).value .inClose )) > ((( ( _state.value .memory+i2).value .inOpen ) > ( ( _state.value .memory+i2).value .inClose )) ? ( ( _state.value .memory+i2).value .inOpen ) : ( ( _state.value .memory+i2).value .inClose )) )
         ) ||
         (
         ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) == -1 &&
         ( ((( ( _state.value .memory+i1).value .inOpen ) > ( ( _state.value .memory+i1).value .inClose )) ? ( ( _state.value .memory+i1).value .inOpen ) : ( ( _state.value .memory+i1).value .inClose )) < ((( ( _state.value .memory+i2).value .inOpen ) < ( ( _state.value .memory+i2).value .inClose )) ? ( ( _state.value .memory+i2).value .inOpen ) : ( ( _state.value .memory+i2).value .inClose )) )
         )
         )
         )
         outInteger.value = ( ( _state.value .memory+i2).value .inClose >= ( _state.value .memory+i2).value .inOpen ? 1 : -1 ) * 100;
      else
         outInteger.value = 0;
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      return RetCode.Success ;
   }
   public RetCode cdlXSideGap3MethodsStateFree( struct TA_cdlXSideGap3Methods_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlXSideGap3MethodsStateSave( struct TA_cdlXSideGap3Methods_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CDLXSIDEGAP3METHODS_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode cdlXSideGap3MethodsStateLoad( struct TA_cdlXSideGap3Methods_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlXSideGap3Methods ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CDLXSIDEGAP3METHODS_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CDLXSIDEGAP3METHODS_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode cdlXSideGap3Methods( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      int i, outIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlXSideGap3MethodsLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == - ( inClose[i] >= inOpen[i] ? 1 : -1 ) &&
            inOpen[i] < (((inClose[i-1]) > (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) &&
            inOpen[i] > (((inClose[i-1]) < (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) &&
            inClose[i] < (((inClose[i-2]) > (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) &&
            inClose[i] > (((inClose[i-2]) < (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) &&
            ( (
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) )
            ) ||
            (
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) )
            )
            )
            )
            outInteger[outIdx++] = ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         i++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int ceilLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode ceil( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.ceil (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode ceilStateInit( struct TA_ceil_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct ceil ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = ceilLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CEIL_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode ceilState( struct TA_ceil_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.ceil (inReal);
      return RetCode.Success ;
   }
   public RetCode ceilStateFree( struct TA_ceil_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode ceilStateSave( struct TA_ceil_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CEIL_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode ceilStateLoad( struct TA_ceil_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct ceil ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CEIL_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CEIL_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode ceil( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.ceil (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cmoLookback( int optInTimePeriod )
   {
      int retValue;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      retValue = optInTimePeriod + (this.unstablePeriod[FuncUnstId.Cmo.ordinal()]) ;
      if( (this.compatibility) == Compatibility.Metastock )
         retValue--;
      return retValue;
   }
   public RetCode cmo( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int today, lookbackTotal, unstablePeriod, i;
      double prevGain, prevLoss, prevValue, savePrevValue;
      double tempValue1, tempValue2, tempValue3, tempValue4;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      lookbackTotal = cmoLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
         return RetCode.Success ;
      outIdx = 0;
      if( optInTimePeriod == 1 )
      {
         outBegIdx.value = startIdx;
         i = (endIdx-startIdx)+1;
         outNBElement.value = i;
         System.arraycopy(inReal,startIdx,outReal,0,i) ;
         return RetCode.Success ;
      }
      today = startIdx-lookbackTotal;
      prevValue = inReal[today];
      unstablePeriod = (this.unstablePeriod[FuncUnstId.Cmo.ordinal()]) ;
      if( (unstablePeriod == 0) &&
         ( (this.compatibility) == Compatibility.Metastock ))
      {
         savePrevValue = prevValue;
         prevGain = 0.0;
         prevLoss = 0.0;
         for( i=optInTimePeriod; i > 0; i-- )
         {
            tempValue1 = inReal[today++];
            tempValue2 = tempValue1 - prevValue;
            prevValue = tempValue1;
            if( tempValue2 < 0 )
               prevLoss -= tempValue2;
            else
               prevGain += tempValue2;
         }
         tempValue1 = prevLoss/optInTimePeriod;
         tempValue2 = prevGain/optInTimePeriod;
         tempValue3 = tempValue2-tempValue1;
         tempValue4 = tempValue1+tempValue2;
         if( ! (((- (0.00000000000001) )<tempValue4)&&(tempValue4< (0.00000000000001) )) )
            outReal[outIdx++] = 100*(tempValue3/tempValue4);
         else
            outReal[outIdx++] = 0.0;
         if( today > endIdx )
         {
            outBegIdx.value = startIdx;
            outNBElement.value = outIdx;
            return RetCode.Success ;
         }
         today -= optInTimePeriod;
         prevValue = savePrevValue;
      }
      prevGain = 0.0;
      prevLoss = 0.0;
      today++;
      for( i=optInTimePeriod; i > 0; i-- )
      {
         tempValue1 = inReal[today++];
         tempValue2 = tempValue1 - prevValue;
         prevValue = tempValue1;
         if( tempValue2 < 0 )
            prevLoss -= tempValue2;
         else
            prevGain += tempValue2;
      }
      prevLoss /= optInTimePeriod;
      prevGain /= optInTimePeriod;
      if( today > startIdx )
      {
         tempValue1 = prevGain+prevLoss;
         if( ! (((- (0.00000000000001) )<tempValue1)&&(tempValue1< (0.00000000000001) )) )
            outReal[outIdx++] = 100.0*((prevGain-prevLoss)/tempValue1);
         else
            outReal[outIdx++] = 0.0;
      }
      else
      {
         while( today < startIdx )
         {
            tempValue1 = inReal[today];
            tempValue2 = tempValue1 - prevValue;
            prevValue = tempValue1;
            prevLoss *= (optInTimePeriod-1);
            prevGain *= (optInTimePeriod-1);
            if( tempValue2 < 0 )
               prevLoss -= tempValue2;
            else
               prevGain += tempValue2;
            prevLoss /= optInTimePeriod;
            prevGain /= optInTimePeriod;
            today++;
         }
      }
      while( today <= endIdx )
      {
         tempValue1 = inReal[today++];
         tempValue2 = tempValue1 - prevValue;
         prevValue = tempValue1;
         prevLoss *= (optInTimePeriod-1);
         prevGain *= (optInTimePeriod-1);
         if( tempValue2 < 0 )
            prevLoss -= tempValue2;
         else
            prevGain += tempValue2;
         prevLoss /= optInTimePeriod;
         prevGain /= optInTimePeriod;
         tempValue1 = prevGain+prevLoss;
         if( ! (((- (0.00000000000001) )<tempValue1)&&(tempValue1< (0.00000000000001) )) )
            outReal[outIdx++] = 100.0*((prevGain-prevLoss)/tempValue1);
         else
            outReal[outIdx++] = 0.0;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode cmoStateInit( struct TA_cmo_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cmo ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = cmoLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      if( ( (this.unstablePeriod[FuncUnstId.Cmo.ordinal()]) == 0) &&
         ( (this.compatibility) == Compatibility.Metastock ))
         _state.value .value .MetastockMode = 1;
      else
         _state.value .value .MetastockMode = 0;
      return RetCode.Success ;
   }
   public RetCode cmoState( struct TA_cmo_State* _state,
      double inReal,
      double *outReal )
   {
      double tempValue1, tempValue2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if( _state.value .optInTimePeriod == 1 )
      {
         outReal.value = inReal;
         return RetCode.Success ;
      }
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .prevLoss = 0.0;
         _state.value .prevGain = 0.0;
         _state.value .prevValue = inReal;
         if ( _state.value .MetastockMode == 0)
            return RetCode.NeedMoreData ;
      }
      tempValue2 = inReal - _state.value .prevValue;
      _state.value .prevValue = inReal;
      if ( _state.value .mem_index+ _state.value .MetastockMode-1 > (unsigned int) ( _state.value .optInTimePeriod+ _state.value .MetastockMode))
      {
         _state.value .prevLoss *= ( _state.value .optInTimePeriod-1);
         _state.value .prevGain *= ( _state.value .optInTimePeriod-1);
      }
      if (tempValue2 < 0)
         _state.value .prevLoss -= tempValue2;
      else
         _state.value .prevGain += tempValue2;
      if ( _state.value .mem_index+ _state.value .MetastockMode-1 >= (unsigned int) ( _state.value .optInTimePeriod+ _state.value .MetastockMode))
      {
         _state.value .prevLoss /= _state.value .optInTimePeriod;
         _state.value .prevGain /= _state.value .optInTimePeriod;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      tempValue1 = _state.value .prevGain+ _state.value .prevLoss;
      if( ! (((- (0.00000000000001) )<tempValue1)&&(tempValue1< (0.00000000000001) )) )
         outReal.value = 100*(( _state.value .prevGain- _state.value .prevLoss)/tempValue1);
      else
         outReal.value = 0.0;
      return RetCode.Success ;
   }
   public RetCode cmoStateFree( struct TA_cmo_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cmoStateSave( struct TA_cmo_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CMO_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .MetastockMode,sizeof( _state.value .MetastockMode),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevGain,sizeof( _state.value .prevGain),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevLoss,sizeof( _state.value .prevLoss),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevValue,sizeof( _state.value .prevValue),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cmoStateLoad( struct TA_cmo_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cmo ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CMO_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CMO_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .MetastockMode,sizeof( _state.value .value .MetastockMode),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevGain,sizeof( _state.value .value .prevGain),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevLoss,sizeof( _state.value .value .prevLoss),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevValue,sizeof( _state.value .value .prevValue),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode cmo( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int today, lookbackTotal, unstablePeriod, i;
      double prevGain, prevLoss, prevValue, savePrevValue;
      double tempValue1, tempValue2, tempValue3, tempValue4;
      int mmmixi, mmmixdestIdx, mmmixsrcIdx ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      lookbackTotal = cmoLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
         return RetCode.Success ;
      outIdx = 0;
      if( optInTimePeriod == 1 )
      {
         outBegIdx.value = startIdx;
         i = (endIdx-startIdx)+1;
         outNBElement.value = i;
         { for( mmmixi=0, mmmixdestIdx=0, mmmixsrcIdx=startIdx; mmmixi < i; mmmixi++, mmmixdestIdx++, mmmixsrcIdx++ ) { outReal[mmmixdestIdx] = inReal[mmmixsrcIdx]; } } ;
         return RetCode.Success ;
      }
      today = startIdx-lookbackTotal;
      prevValue = inReal[today];
      unstablePeriod = (this.unstablePeriod[FuncUnstId.Cmo.ordinal()]) ;
      if( (unstablePeriod == 0) &&
         ( (this.compatibility) == Compatibility.Metastock ))
      {
         savePrevValue = prevValue;
         prevGain = 0.0;
         prevLoss = 0.0;
         for( i=optInTimePeriod; i > 0; i-- )
         {
            tempValue1 = inReal[today++];
            tempValue2 = tempValue1 - prevValue;
            prevValue = tempValue1;
            if( tempValue2 < 0 )
               prevLoss -= tempValue2;
            else
               prevGain += tempValue2;
         }
         tempValue1 = prevLoss/optInTimePeriod;
         tempValue2 = prevGain/optInTimePeriod;
         tempValue3 = tempValue2-tempValue1;
         tempValue4 = tempValue1+tempValue2;
         if( ! (((- (0.00000000000001) )<tempValue4)&&(tempValue4< (0.00000000000001) )) )
            outReal[outIdx++] = 100*(tempValue3/tempValue4);
         else
            outReal[outIdx++] = 0.0;
         if( today > endIdx )
         {
            outBegIdx.value = startIdx;
            outNBElement.value = outIdx;
            return RetCode.Success ;
         }
         today -= optInTimePeriod;
         prevValue = savePrevValue;
      }
      prevGain = 0.0;
      prevLoss = 0.0;
      today++;
      for( i=optInTimePeriod; i > 0; i-- )
      {
         tempValue1 = inReal[today++];
         tempValue2 = tempValue1 - prevValue;
         prevValue = tempValue1;
         if( tempValue2 < 0 )
            prevLoss -= tempValue2;
         else
            prevGain += tempValue2;
      }
      prevLoss /= optInTimePeriod;
      prevGain /= optInTimePeriod;
      if( today > startIdx )
      {
         tempValue1 = prevGain+prevLoss;
         if( ! (((- (0.00000000000001) )<tempValue1)&&(tempValue1< (0.00000000000001) )) )
            outReal[outIdx++] = 100.0*((prevGain-prevLoss)/tempValue1);
         else
            outReal[outIdx++] = 0.0;
      }
      else
      {
         while( today < startIdx )
         {
            tempValue1 = inReal[today];
            tempValue2 = tempValue1 - prevValue;
            prevValue = tempValue1;
            prevLoss *= (optInTimePeriod-1);
            prevGain *= (optInTimePeriod-1);
            if( tempValue2 < 0 )
               prevLoss -= tempValue2;
            else
               prevGain += tempValue2;
            prevLoss /= optInTimePeriod;
            prevGain /= optInTimePeriod;
            today++;
         }
      }
      while( today <= endIdx )
      {
         tempValue1 = inReal[today++];
         tempValue2 = tempValue1 - prevValue;
         prevValue = tempValue1;
         prevLoss *= (optInTimePeriod-1);
         prevGain *= (optInTimePeriod-1);
         if( tempValue2 < 0 )
            prevLoss -= tempValue2;
         else
            prevGain += tempValue2;
         prevLoss /= optInTimePeriod;
         prevGain /= optInTimePeriod;
         tempValue1 = prevGain+prevLoss;
         if( ! (((- (0.00000000000001) )<tempValue1)&&(tempValue1< (0.00000000000001) )) )
            outReal[outIdx++] = 100.0*((prevGain-prevLoss)/tempValue1);
         else
            outReal[outIdx++] = 0.0;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int correlLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod-1;
   }
   public RetCode correl( int startIdx,
      int endIdx,
      double inReal0[],
      double inReal1[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double sumXY, sumX, sumY, sumX2, sumY2, x, y, trailingX, trailingY;
      double tempReal;
      int lookbackTotal, today, trailingIdx, outIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = optInTimePeriod-1;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingIdx = startIdx - lookbackTotal;
      sumXY = sumX = sumY = sumX2 = sumY2 = 0.0;
      for( today=trailingIdx; today <= startIdx; today++ )
      {
         x = inReal0[today];
         sumX += x;
         sumX2 += x*x;
         y = inReal1[today];
         sumXY += x*y;
         sumY += y;
         sumY2 += y*y;
      }
      trailingX = inReal0[trailingIdx];
      trailingY = inReal1[trailingIdx++];
      tempReal = (sumX2-((sumX*sumX)/optInTimePeriod)) * (sumY2-((sumY*sumY)/optInTimePeriod));
      if( ! (tempReal< (0.00000000000001) ) )
         outReal[0] = (sumXY-((sumX*sumY)/optInTimePeriod)) / Math.sqrt (tempReal);
      else
         outReal[0] = 0.0;
      outIdx = 1;
      while( today <= endIdx )
      {
         sumX -= trailingX;
         sumX2 -= trailingX*trailingX;
         sumXY -= trailingX*trailingY;
         sumY -= trailingY;
         sumY2 -= trailingY*trailingY;
         x = inReal0[today];
         sumX += x;
         sumX2 += x*x;
         y = inReal1[today++];
         sumXY += x*y;
         sumY += y;
         sumY2 += y*y;
         trailingX = inReal0[trailingIdx];
         trailingY = inReal1[trailingIdx++];
         tempReal = (sumX2-((sumX*sumX)/optInTimePeriod)) * (sumY2-((sumY*sumY)/optInTimePeriod));
         if( ! (tempReal< (0.00000000000001) ) )
            outReal[outIdx++] = (sumXY-((sumX*sumY)/optInTimePeriod)) / Math.sqrt (tempReal);
         else
            outReal[outIdx++] = 0.0;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode correlStateInit( struct TA_correl_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct correl ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = correlLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CORREL_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode correlState( struct TA_correl_State* _state,
      double inReal0,
      double inReal1,
      double *outReal )
   {
      double x,y, tempReal;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .sumXY = 0.0;
         _state.value .sumX = 0.0;
         _state.value .sumY = 0.0;
         _state.value .sumX2 = 0.0;
         _state.value .sumY2 = 0.0;
      }
      { _state.value .sumX += 1*inReal0; _state.value .sumX2 += 1*inReal0*inReal0; _state.value .sumXY += 1*inReal0*inReal1; _state.value .sumY += 1*inReal1; _state.value .sumY2 += 1*inReal1*inReal1; }
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
      {
         ( _state.value .memory+_cur_idx).value .inReal0 = inReal0 ;
         ( _state.value .memory+_cur_idx).value .inReal1 = inReal1 ;
         return RetCode.NeedMoreData ;
      }
      tempReal = ( _state.value .sumX2-(( _state.value .sumX* _state.value .sumX)/ _state.value .optInTimePeriod)) * ( _state.value .sumY2-(( _state.value .sumY* _state.value .sumY)/ _state.value .optInTimePeriod));
      if( ! (tempReal< (0.00000000000001) ) )
         outReal.value = ( _state.value .sumXY-(( _state.value .sumX* _state.value .sumY)/ _state.value .optInTimePeriod)) / Math.sqrt (tempReal);
      else
         outReal.value = 0.0;
      x= ( _state.value .memory+_cur_idx).value .inReal0 ;
      y= ( _state.value .memory+_cur_idx).value .inReal1 ;
      { _state.value .sumX += -1*x; _state.value .sumX2 += -1*x*x; _state.value .sumXY += -1*x*y; _state.value .sumY += -1*y; _state.value .sumY2 += -1*y*y; }
      ( _state.value .memory+_cur_idx).value .inReal0 = inReal0 ;
      ( _state.value .memory+_cur_idx).value .inReal1 = inReal1 ;
      return RetCode.Success ;
   }
   public RetCode correlStateFree( struct TA_correl_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode correlStateSave( struct TA_correl_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_CORREL_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .sumXY,sizeof( _state.value .sumXY),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .sumX,sizeof( _state.value .sumX),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .sumY,sizeof( _state.value .sumY),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .sumX2,sizeof( _state.value .sumX2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .sumY2,sizeof( _state.value .sumY2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode correlStateLoad( struct TA_correl_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct correl ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_CORREL_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_CORREL_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .sumXY,sizeof( _state.value .value .sumXY),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .sumX,sizeof( _state.value .value .sumX),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .sumY,sizeof( _state.value .value .sumY),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .sumX2,sizeof( _state.value .value .sumX2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .sumY2,sizeof( _state.value .value .sumY2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode correl( int startIdx,
      int endIdx,
      float inReal0[],
      float inReal1[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double sumXY, sumX, sumY, sumX2, sumY2, x, y, trailingX, trailingY;
      double tempReal;
      int lookbackTotal, today, trailingIdx, outIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = optInTimePeriod-1;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingIdx = startIdx - lookbackTotal;
      sumXY = sumX = sumY = sumX2 = sumY2 = 0.0;
      for( today=trailingIdx; today <= startIdx; today++ )
      {
         x = inReal0[today];
         sumX += x;
         sumX2 += x*x;
         y = inReal1[today];
         sumXY += x*y;
         sumY += y;
         sumY2 += y*y;
      }
      trailingX = inReal0[trailingIdx];
      trailingY = inReal1[trailingIdx++];
      tempReal = (sumX2-((sumX*sumX)/optInTimePeriod)) * (sumY2-((sumY*sumY)/optInTimePeriod));
      if( ! (tempReal< (0.00000000000001) ) )
         outReal[0] = (sumXY-((sumX*sumY)/optInTimePeriod)) / Math.sqrt (tempReal);
      else
         outReal[0] = 0.0;
      outIdx = 1;
      while( today <= endIdx )
      {
         sumX -= trailingX;
         sumX2 -= trailingX*trailingX;
         sumXY -= trailingX*trailingY;
         sumY -= trailingY;
         sumY2 -= trailingY*trailingY;
         x = inReal0[today];
         sumX += x;
         sumX2 += x*x;
         y = inReal1[today++];
         sumXY += x*y;
         sumY += y;
         sumY2 += y*y;
         trailingX = inReal0[trailingIdx];
         trailingY = inReal1[trailingIdx++];
         tempReal = (sumX2-((sumX*sumX)/optInTimePeriod)) * (sumY2-((sumY*sumY)/optInTimePeriod));
         if( ! (tempReal< (0.00000000000001) ) )
            outReal[outIdx++] = (sumXY-((sumX*sumY)/optInTimePeriod)) / Math.sqrt (tempReal);
         else
            outReal[outIdx++] = 0.0;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cosLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode cos( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.cos (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode cosStateInit( struct TA_cos_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cos ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cosLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_COS_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode cosState( struct TA_cos_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.cos (inReal);
      return RetCode.Success ;
   }
   public RetCode cosStateFree( struct TA_cos_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cosStateSave( struct TA_cos_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_COS_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode cosStateLoad( struct TA_cos_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cos ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_COS_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_COS_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode cos( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.cos (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int coshLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode cosh( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.cosh (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode coshStateInit( struct TA_cosh_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cosh ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = coshLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_COSH_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode coshState( struct TA_cosh_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.cosh (inReal);
      return RetCode.Success ;
   }
   public RetCode coshStateFree( struct TA_cosh_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode coshStateSave( struct TA_cosh_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_COSH_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode coshStateLoad( struct TA_cosh_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cosh ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_COSH_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_COSH_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode cosh( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.cosh (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int demaLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return emaLookback ( optInTimePeriod ) * 2;
   }
   public RetCode dema( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double []firstEMA ;
      double []secondEMA ;
      double k;
      MInteger firstEMABegIdx = new MInteger() ;
      MInteger firstEMANbElement = new MInteger() ;
      MInteger secondEMABegIdx = new MInteger() ;
      MInteger secondEMANbElement = new MInteger() ;
      int tempInt, outIdx, firstEMAIdx, lookbackTotal, lookbackEMA;
      RetCode retCode;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      outNBElement.value = 0 ;
      outBegIdx.value = 0 ;
      lookbackEMA = emaLookback ( optInTimePeriod );
      lookbackTotal = lookbackEMA * 2;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
         return RetCode.Success ;
      if( inReal == outReal )
         firstEMA = outReal;
      else
      {
         tempInt = lookbackTotal+(endIdx-startIdx)+1;
         firstEMA = new double[tempInt] ;
      }
      k = ((double)2.0 / ((double)(optInTimePeriod + 1))) ;
      retCode = TA_INT_EMA ( startIdx-lookbackEMA, endIdx, inReal,
         optInTimePeriod, k,
         firstEMABegIdx , firstEMANbElement ,
         firstEMA );
      if( (retCode != RetCode.Success ) || ( firstEMANbElement.value == 0) )
      {
         return retCode;
      }
      secondEMA = new double[firstEMANbElement.value ] ;
      retCode = TA_INT_EMA ( 0, firstEMANbElement.value -1, firstEMA,
         optInTimePeriod, k,
         secondEMABegIdx , secondEMANbElement ,
         secondEMA );
      if( (retCode != RetCode.Success ) || ( secondEMANbElement.value == 0) )
      {
         return retCode;
      }
      firstEMAIdx = secondEMABegIdx.value ;
      outIdx = 0;
      while( outIdx < secondEMANbElement.value )
      {
         outReal[outIdx] = (2.0*firstEMA[firstEMAIdx++]) - secondEMA[outIdx];
         outIdx++;
      }
      outBegIdx.value = firstEMABegIdx.value + secondEMABegIdx.value ;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode demaStateInit( struct TA_dema_State** _state,
      int optInTimePeriod )
   {
      int res;
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct dema ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = demaLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      res = ema ((struct ema **)& _state.value .value .state_EMA, optInTimePeriod);
      if (res == RetCode.Success )
      {
         res = ema ((struct ema **)& _state.value .value .state_EMA2, optInTimePeriod);
      }
      return res;
   }
   public RetCode demaState( struct TA_dema_State* _state,
      double inReal,
      double *outReal )
   {
      double ema, ema2;
      int retCode;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      retCode = ema ( _state.value .state_EMA, inReal, &ema );
      if( retCode != RetCode.Success )
         return retCode;
      retCode = ema ( _state.value .state_EMA2, ema, &ema2 );
      if( retCode != RetCode.Success )
         return retCode;
      outReal.value = (2.0*ema) - ema2;
      return RetCode.Success ;
   }
   public RetCode demaStateFree( struct TA_dema_State** _state )
   {
      int res = ema ((struct ema **)& _state.value .value .state_EMA);
      if (res == RetCode.Success )
      {
         res = ema ((struct ema **)& _state.value .value .state_EMA2);
      }
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return res;
   }
   public RetCode demaStateSave( struct TA_dema_State* _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_DEMA_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_EMA_StateSave ( (struct ema *) _state.value .state_EMA, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_EMA_StateSave ( (struct ema *) _state.value .state_EMA2, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode demaStateLoad( struct TA_dema_State** _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct dema ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_DEMA_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_DEMA_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_EMA_StateLoad ( (struct ema **) & _state.value .value .state_EMA, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_EMA_StateLoad ( (struct ema **) & _state.value .value .state_EMA2, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode dema( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double []firstEMA ;
      double []secondEMA ;
      double k;
      MInteger firstEMABegIdx = new MInteger() ;
      MInteger firstEMANbElement = new MInteger() ;
      MInteger secondEMABegIdx = new MInteger() ;
      MInteger secondEMANbElement = new MInteger() ;
      int tempInt, outIdx, firstEMAIdx, lookbackTotal, lookbackEMA;
      RetCode retCode;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      outNBElement.value = 0 ;
      outBegIdx.value = 0 ;
      lookbackEMA = emaLookback ( optInTimePeriod );
      lookbackTotal = lookbackEMA * 2;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
         return RetCode.Success ;
      tempInt = lookbackTotal+(endIdx-startIdx)+1;
      firstEMA = new double[tempInt] ;
      k = ((double)2.0 / ((double)(optInTimePeriod + 1))) ;
      retCode = TA_INT_EMA ( startIdx-lookbackEMA, endIdx, inReal,
         optInTimePeriod, k,
         firstEMABegIdx , firstEMANbElement ,
         firstEMA );
      if( (retCode != RetCode.Success ) || ( firstEMANbElement.value == 0) )
      {
         return retCode;
      }
      secondEMA = new double[firstEMANbElement.value ] ;
      retCode = TA_INT_EMA ( 0, firstEMANbElement.value -1, firstEMA,
         optInTimePeriod, k,
         secondEMABegIdx , secondEMANbElement ,
         secondEMA );
      if( (retCode != RetCode.Success ) || ( secondEMANbElement.value == 0) )
      {
         return retCode;
      }
      firstEMAIdx = secondEMABegIdx.value ;
      outIdx = 0;
      while( outIdx < secondEMANbElement.value )
      {
         outReal[outIdx] = (2.0*firstEMA[firstEMAIdx++]) - secondEMA[outIdx];
         outIdx++;
      }
      outBegIdx.value = firstEMABegIdx.value + secondEMABegIdx.value ;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int divLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode div( int startIdx,
      int endIdx,
      double inReal0[],
      double inReal1[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = inReal0[i]/inReal1[i];
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode divStateInit( struct TA_div_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct div ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = divLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_DIV_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode divState( struct TA_div_State* _state,
      double inReal0,
      double inReal1,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal0 = inReal0 ;
         ( _state.value .memory+_cur_idx).value .inReal1 = inReal1 ;
         return RetCode.NeedMoreData ; }
      outReal.value = inReal0 / inReal1;
      return RetCode.Success ;
   }
   public RetCode divStateFree( struct TA_div_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode divStateSave( struct TA_div_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_DIV_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode divStateLoad( struct TA_div_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct div ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_DIV_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_DIV_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode div( int startIdx,
      int endIdx,
      float inReal0[],
      float inReal1[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = inReal0[i]/inReal1[i];
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int dxLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      if( optInTimePeriod > 1 )
         return optInTimePeriod + (this.unstablePeriod[FuncUnstId.Dx.ordinal()]) ;
      else
         return 2;
   }
   public RetCode dx( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, lookbackTotal, outIdx;
      double prevHigh, prevLow, prevClose;
      double prevMinusDM, prevPlusDM, prevTR;
      double tempReal, tempReal2, diffP, diffM;
      double minusDI, plusDI;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInTimePeriod > 1 )
         lookbackTotal = optInTimePeriod + (this.unstablePeriod[FuncUnstId.Dx.ordinal()]) ;
      else
         lookbackTotal = 2;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      outBegIdx.value = today = startIdx;
      prevMinusDM = 0.0;
      prevPlusDM = 0.0;
      prevTR = 0.0;
      today = startIdx - lookbackTotal;
      prevHigh = inHigh[today];
      prevLow = inLow[today];
      prevClose = inClose[today];
      i = optInTimePeriod-1;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         else if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR += tempReal;
         prevClose = inClose[today];
      }
      i = (this.unstablePeriod[FuncUnstId.Dx.ordinal()]) + 1;
      while( i-- != 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         prevMinusDM -= prevMinusDM/optInTimePeriod;
         prevPlusDM -= prevPlusDM/optInTimePeriod;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         else if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
      }
      if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
      {
         minusDI = (100.0*(prevMinusDM/prevTR)) ;
         plusDI = (100.0*(prevPlusDM/prevTR)) ;
         tempReal = minusDI+plusDI;
         if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
            outReal[0] = (100.0 * ( Math.abs (minusDI-plusDI)/tempReal)) ;
         else
            outReal[0] = 0.0;
      }
      else
         outReal[0] = 0.0;
      outIdx = 1;
      while( today < endIdx )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         prevMinusDM -= prevMinusDM/optInTimePeriod;
         prevPlusDM -= prevPlusDM/optInTimePeriod;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         else if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
         if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
         {
            minusDI = (100.0*(prevMinusDM/prevTR)) ;
            plusDI = (100.0*(prevPlusDM/prevTR)) ;
            tempReal = minusDI+plusDI;
            if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
               outReal[outIdx] = (100.0 * ( Math.abs (minusDI-plusDI)/tempReal)) ;
            else
               outReal[outIdx] = outReal[outIdx-1];
         }
         else
            outReal[outIdx] = outReal[outIdx-1];
         outIdx++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode dxStateInit( struct TA_dx_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct dx ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = dxLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode dxState( struct TA_dx_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      double tempReal, tempReal2, diffP, diffM;
      double minusDI, plusDI;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .prevMinusDM = 0.0;
         _state.value .prevPlusDM = 0.0;
         _state.value .prevTR = 0.0;
         _state.value .prevOutReal = 0.0;
         _state.value .prevHigh = inHigh;
         _state.value .prevLow = inLow;
         _state.value .prevClose = inClose;
         return RetCode.NeedMoreData ;
      }
      diffP = inHigh- _state.value .prevHigh;
      _state.value .prevHigh = inHigh;
      diffM = _state.value .prevLow-inLow;
      _state.value .prevLow = inLow;
      if ((int) _state.value .mem_index > _state.value .optInTimePeriod )
      {
         _state.value .prevMinusDM -= _state.value .prevMinusDM/ _state.value .optInTimePeriod;
         _state.value .prevPlusDM -= _state.value .prevPlusDM/ _state.value .optInTimePeriod;
      }
      if( (diffM > 0) && (diffP < diffM) )
      {
         _state.value .prevMinusDM += diffM;
      }
      else if( (diffP > 0) && (diffP > diffM) )
      {
         _state.value .prevPlusDM += diffP;
      }
      { tempReal = _state.value .prevHigh- _state.value .prevLow; tempReal2 = Math.abs ( _state.value .prevHigh- _state.value .prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs ( _state.value .prevLow- _state.value .prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
      if ((int) _state.value .mem_index < _state.value .optInTimePeriod )
         _state.value .prevTR += tempReal;
      else
         _state.value .prevTR = _state.value .prevTR - ( _state.value .prevTR/ _state.value .optInTimePeriod) + tempReal;
      _state.value .prevClose = inClose;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      if( ! (((- (0.00000000000001) )< _state.value .prevTR)&&( _state.value .prevTR< (0.00000000000001) )) )
      {
         minusDI = (100.0*( _state.value .prevMinusDM/ _state.value .prevTR)) ;
         plusDI = (100.0*( _state.value .prevPlusDM/ _state.value .prevTR)) ;
         tempReal = minusDI+plusDI;
         if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
            _state.value .prevOutReal = (100.0 * ( Math.abs (minusDI-plusDI)/tempReal)) ;
         outReal.value = _state.value .prevOutReal;
      }
      else
         outReal.value = _state.value .prevOutReal;
      return RetCode.Success ;
   }
   public RetCode dxStateFree( struct TA_dx_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode dxStateSave( struct TA_dx_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_DX_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevHigh,sizeof( _state.value .prevHigh),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevLow,sizeof( _state.value .prevLow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevClose,sizeof( _state.value .prevClose),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevMinusDM,sizeof( _state.value .prevMinusDM),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevPlusDM,sizeof( _state.value .prevPlusDM),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevTR,sizeof( _state.value .prevTR),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevOutReal,sizeof( _state.value .prevOutReal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode dxStateLoad( struct TA_dx_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct dx ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_DX_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_DX_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevHigh,sizeof( _state.value .value .prevHigh),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevLow,sizeof( _state.value .value .prevLow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevClose,sizeof( _state.value .value .prevClose),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevMinusDM,sizeof( _state.value .value .prevMinusDM),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevPlusDM,sizeof( _state.value .value .prevPlusDM),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevTR,sizeof( _state.value .value .prevTR),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevOutReal,sizeof( _state.value .value .prevOutReal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode dx( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, lookbackTotal, outIdx;
      double prevHigh, prevLow, prevClose;
      double prevMinusDM, prevPlusDM, prevTR;
      double tempReal, tempReal2, diffP, diffM;
      double minusDI, plusDI;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInTimePeriod > 1 )
         lookbackTotal = optInTimePeriod + (this.unstablePeriod[FuncUnstId.Dx.ordinal()]) ;
      else
         lookbackTotal = 2;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      outBegIdx.value = today = startIdx;
      prevMinusDM = 0.0;
      prevPlusDM = 0.0;
      prevTR = 0.0;
      today = startIdx - lookbackTotal;
      prevHigh = inHigh[today];
      prevLow = inLow[today];
      prevClose = inClose[today];
      i = optInTimePeriod-1;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         else if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR += tempReal;
         prevClose = inClose[today];
      }
      i = (this.unstablePeriod[FuncUnstId.Dx.ordinal()]) + 1;
      while( i-- != 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         prevMinusDM -= prevMinusDM/optInTimePeriod;
         prevPlusDM -= prevPlusDM/optInTimePeriod;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         else if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
      }
      if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
      {
         minusDI = (100.0*(prevMinusDM/prevTR)) ;
         plusDI = (100.0*(prevPlusDM/prevTR)) ;
         tempReal = minusDI+plusDI;
         if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
            outReal[0] = (100.0 * ( Math.abs (minusDI-plusDI)/tempReal)) ;
         else
            outReal[0] = 0.0;
      }
      else
         outReal[0] = 0.0;
      outIdx = 1;
      while( today < endIdx )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         prevMinusDM -= prevMinusDM/optInTimePeriod;
         prevPlusDM -= prevPlusDM/optInTimePeriod;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         else if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
         if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
         {
            minusDI = (100.0*(prevMinusDM/prevTR)) ;
            plusDI = (100.0*(prevPlusDM/prevTR)) ;
            tempReal = minusDI+plusDI;
            if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
               outReal[outIdx] = (100.0 * ( Math.abs (minusDI-plusDI)/tempReal)) ;
            else
               outReal[outIdx] = outReal[outIdx-1];
         }
         else
            outReal[outIdx] = outReal[outIdx-1];
         outIdx++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int emaLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod - 1 + (this.unstablePeriod[FuncUnstId.Ema.ordinal()]) ;
   }
   public RetCode ema( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      return TA_INT_EMA ( startIdx, endIdx, inReal,
         optInTimePeriod,
         ((double)2.0 / ((double)(optInTimePeriod + 1))) ,
         outBegIdx, outNBElement, outReal );
   }
   public RetCode TA_INT_EMA( int startIdx,
      int endIdx,
      double []inReal,
      int optInTimePeriod,
      double optInK_1,
      MInteger outBegIdx,
      MInteger outNBElement,
      double []outReal )
   {
      double tempReal, prevMA;
      int i, today, outIdx, lookbackTotal;
      lookbackTotal = emaLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      if( (this.compatibility) == Compatibility.Default )
      {
         today = startIdx-lookbackTotal;
         i = optInTimePeriod;
         tempReal = 0.0;
         while( i-- > 0 )
            tempReal += inReal[today++];
         prevMA = tempReal / optInTimePeriod;
      }
      else
      {
         prevMA = inReal[0];
         today = 1;
      }
      while( today <= startIdx )
         prevMA = ((inReal[today++]-prevMA)*optInK_1) + prevMA;
      outReal[0] = prevMA;
      outIdx = 1;
      while( today <= endIdx )
      {
         prevMA = ((inReal[today++]-prevMA)*optInK_1) + prevMA;
         outReal[outIdx++] = prevMA;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode emaStateInit( struct TA_ema_State** _state,
      int optInTimePeriod )
   {
      return TA_INT_EMA_StateInit(_state, optInTimePeriod, ((double)2.0 / ((double)(optInTimePeriod + 1))) );
   }
   public int TA_INT_EMA_StateInit( struct TA_ema_State** _state,
      int optInTimePeriod,
      double optInK_1)
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct ema ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .optInK_1 = optInK_1;
      _state.value .value .mem_size = emaLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode emaState( struct TA_ema_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .prevMA = 0.;
         _state.value .tempSum = 0.;
      }
      if( (this.compatibility) == Compatibility.Default )
      {
         if ((int) _state.value .mem_index-1 < _state.value .optInTimePeriod)
         {
            _state.value .tempSum += inReal;
            if ((int) _state.value .mem_index == _state.value .optInTimePeriod)
            {
               _state.value .prevMA = _state.value .tempSum / _state.value .optInTimePeriod;
               if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
               {
                  outReal.value = _state.value .prevMA;
                  return RetCode.Success ;
               }
            } else
               return RetCode.NeedMoreData ;
         }
      }
      else {
         if ( ( _state.value .mem_index == 1) )
         {
            _state.value .prevMA = inReal;
            return RetCode.NeedMoreData ;
         }
      }
      _state.value .prevMA = ((inReal- _state.value .prevMA) * _state.value .optInK_1 ) + _state.value .prevMA;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      outReal.value = _state.value .prevMA;
      return RetCode.Success ;
   }
   public RetCode emaStateFree( struct TA_ema_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode emaStateSave( struct TA_ema_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_EMA_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevMA,sizeof( _state.value .prevMA),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .tempSum,sizeof( _state.value .tempSum),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .preprRes,sizeof( _state.value .preprRes),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInK_1,sizeof( _state.value .optInK_1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode emaStateLoad( struct TA_ema_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct ema ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_EMA_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_EMA_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevMA,sizeof( _state.value .value .prevMA),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .tempSum,sizeof( _state.value .value .tempSum),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .preprRes,sizeof( _state.value .value .preprRes),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInK_1,sizeof( _state.value .value .optInK_1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode ema( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      return TA_INT_EMA ( startIdx, endIdx, inReal,
         optInTimePeriod,
         ((double)2.0 / ((double)(optInTimePeriod + 1))) ,
         outBegIdx, outNBElement, outReal );
   }
   public RetCode TA_INT_EMA( int startIdx,
      int endIdx,
      float []inReal,
      int optInTimePeriod,
      double optInK_1,
      MInteger outBegIdx,
      MInteger outNBElement,
      double []outReal )
   {
      double tempReal, prevMA;
      int i, today, outIdx, lookbackTotal;
      lookbackTotal = emaLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      if( (this.compatibility) == Compatibility.Default )
      {
         today = startIdx-lookbackTotal;
         i = optInTimePeriod;
         tempReal = 0.0;
         while( i-- > 0 )
            tempReal += inReal[today++];
         prevMA = tempReal / optInTimePeriod;
      }
      else
      {
         prevMA = inReal[0];
         today = 1;
      }
      while( today <= startIdx )
         prevMA = ((inReal[today++]-prevMA)*optInK_1) + prevMA;
      outReal[0] = prevMA;
      outIdx = 1;
      while( today <= endIdx )
      {
         prevMA = ((inReal[today++]-prevMA)*optInK_1) + prevMA;
         outReal[outIdx++] = prevMA;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int expLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode exp( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.exp (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode expStateInit( struct TA_exp_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct exp ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = expLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_EXP_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode expState( struct TA_exp_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.exp (inReal);
      return RetCode.Success ;
   }
   public RetCode expStateFree( struct TA_exp_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode expStateSave( struct TA_exp_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_EXP_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode expStateLoad( struct TA_exp_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct exp ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_EXP_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_EXP_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode exp( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.exp (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int floorLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode floor( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.floor (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode floorStateInit( struct TA_floor_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct floor ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = floorLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_FLOOR_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode floorState( struct TA_floor_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.floor (inReal);
      return RetCode.Success ;
   }
   public RetCode floorStateFree( struct TA_floor_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode floorStateSave( struct TA_floor_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_FLOOR_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode floorStateLoad( struct TA_floor_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct floor ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_FLOOR_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_FLOOR_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode floor( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.floor (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int htDcPeriodLookback( )
   {
      return 32 + (this.unstablePeriod[FuncUnstId.HtDcPeriod.ordinal()]) ;
   }
   public RetCode htDcPeriod( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      int lookbackTotal, today;
      double tempReal, tempReal2;
      double adjustedPrevPeriod, period;
      int trailingWMAIdx;
      double periodWMASum, periodWMASub, trailingWMAValue;
      double smoothedValue;
      final double a = 0.0962;
      final double b = 0.5769;
      double hilbertTempReal;
      int hilbertIdx;
      double []detrender_Odd = new double[3] ; double []detrender_Even = new double[3] ; double detrender; double prev_detrender_Odd ; double prev_detrender_Even ; double prev_detrender_input_Odd ; double prev_detrender_input_Even ;
      double []Q1_Odd = new double[3] ; double []Q1_Even = new double[3] ; double Q1; double prev_Q1_Odd ; double prev_Q1_Even ; double prev_Q1_input_Odd ; double prev_Q1_input_Even ;
      double []jI_Odd = new double[3] ; double []jI_Even = new double[3] ; double jI; double prev_jI_Odd ; double prev_jI_Even ; double prev_jI_input_Odd ; double prev_jI_input_Even ;
      double []jQ_Odd = new double[3] ; double []jQ_Even = new double[3] ; double jQ; double prev_jQ_Odd ; double prev_jQ_Even ; double prev_jQ_input_Odd ; double prev_jQ_input_Even ;
      double Q2, I2, prevQ2, prevI2, Re, Im;
      double I1ForOddPrev2, I1ForOddPrev3;
      double I1ForEvenPrev2, I1ForEvenPrev3;
      double rad2Deg;
      double todayValue, smoothPeriod;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      rad2Deg = 180.0 / (4.0 * Math.atan (1));
      lookbackTotal = 32 + (this.unstablePeriod[FuncUnstId.HtDcPeriod.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingWMAIdx = startIdx - lookbackTotal;
      today = trailingWMAIdx;
      tempReal = inReal[today++];
      periodWMASub = tempReal;
      periodWMASum = tempReal;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*2.0;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*3.0;
      trailingWMAValue = 0.0;
      i = 9;
      do
      {
         tempReal = inReal[today++];
         { periodWMASub += tempReal; periodWMASub -= trailingWMAValue; periodWMASum += tempReal*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
      } while( --i != 0);
      hilbertIdx = 0;
      { detrender_Odd [0] = 0.0; detrender_Odd [1] = 0.0; detrender_Odd [2] = 0.0; detrender_Even [0] = 0.0; detrender_Even [1] = 0.0; detrender_Even [2] = 0.0; detrender = 0.0; prev_detrender_Odd = 0.0; prev_detrender_Even = 0.0; prev_detrender_input_Odd = 0.0; prev_detrender_input_Even = 0.0; } ;
      { Q1_Odd [0] = 0.0; Q1_Odd [1] = 0.0; Q1_Odd [2] = 0.0; Q1_Even [0] = 0.0; Q1_Even [1] = 0.0; Q1_Even [2] = 0.0; Q1 = 0.0; prev_Q1_Odd = 0.0; prev_Q1_Even = 0.0; prev_Q1_input_Odd = 0.0; prev_Q1_input_Even = 0.0; } ;
      { jI_Odd [0] = 0.0; jI_Odd [1] = 0.0; jI_Odd [2] = 0.0; jI_Even [0] = 0.0; jI_Even [1] = 0.0; jI_Even [2] = 0.0; jI = 0.0; prev_jI_Odd = 0.0; prev_jI_Even = 0.0; prev_jI_input_Odd = 0.0; prev_jI_input_Even = 0.0; } ;
      { jQ_Odd [0] = 0.0; jQ_Odd [1] = 0.0; jQ_Odd [2] = 0.0; jQ_Even [0] = 0.0; jQ_Even [1] = 0.0; jQ_Even [2] = 0.0; jQ = 0.0; prev_jQ_Odd = 0.0; prev_jQ_Even = 0.0; prev_jQ_input_Odd = 0.0; prev_jQ_input_Even = 0.0; } ;
      period = 0.0;
      outIdx = 0;
      prevI2 = prevQ2 = 0.0;
      Re = Im = 0.0;
      I1ForOddPrev3 = I1ForEvenPrev3 = 0.0;
      I1ForOddPrev2 = I1ForEvenPrev2 = 0.0;
      smoothPeriod = 0.0;
      while( today <= endIdx )
      {
         adjustedPrevPeriod = (0.075*period)+0.54;
         todayValue = inReal[today];
         { periodWMASub += todayValue; periodWMASub -= trailingWMAValue; periodWMASum += todayValue*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
         if( (today%2) == 0 )
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Even [hilbertIdx]; detrender_Even [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Even ; prev_detrender_Even = b * prev_detrender_input_Even ; detrender += prev_detrender_Even ; prev_detrender_input_Even = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Even [hilbertIdx]; Q1_Even [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Even ; prev_Q1_Even = b * prev_Q1_input_Even ; Q1 += prev_Q1_Even ; prev_Q1_input_Even = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForEvenPrev3; jI = -jI_Even [hilbertIdx]; jI_Even [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Even ; prev_jI_Even = b * prev_jI_input_Even ; jI += prev_jI_Even ; prev_jI_input_Even = I1ForEvenPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Even [hilbertIdx]; jQ_Even [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Even ; prev_jQ_Even = b * prev_jQ_input_Even ; jQ += prev_jQ_Even ; prev_jQ_input_Even = Q1; jQ *= adjustedPrevPeriod; } ;
            if( ++hilbertIdx == 3 )
               hilbertIdx = 0;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForEvenPrev3 - jQ)) + (0.8*prevI2);
            I1ForOddPrev3 = I1ForOddPrev2;
            I1ForOddPrev2 = detrender;
         }
         else
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Odd [hilbertIdx]; detrender_Odd [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Odd ; prev_detrender_Odd = b * prev_detrender_input_Odd ; detrender += prev_detrender_Odd ; prev_detrender_input_Odd = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Odd [hilbertIdx]; Q1_Odd [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Odd ; prev_Q1_Odd = b * prev_Q1_input_Odd ; Q1 += prev_Q1_Odd ; prev_Q1_input_Odd = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForOddPrev3; jI = -jI_Odd [hilbertIdx]; jI_Odd [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Odd ; prev_jI_Odd = b * prev_jI_input_Odd ; jI += prev_jI_Odd ; prev_jI_input_Odd = I1ForOddPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Odd [hilbertIdx]; jQ_Odd [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Odd ; prev_jQ_Odd = b * prev_jQ_input_Odd ; jQ += prev_jQ_Odd ; prev_jQ_input_Odd = Q1; jQ *= adjustedPrevPeriod; } ;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForOddPrev3 - jQ)) + (0.8*prevI2);
            I1ForEvenPrev3 = I1ForEvenPrev2;
            I1ForEvenPrev2 = detrender;
         }
         Re = (0.2*((I2*prevI2)+(Q2*prevQ2)))+(0.8*Re);
         Im = (0.2*((I2*prevQ2)-(Q2*prevI2)))+(0.8*Im);
         prevQ2 = Q2;
         prevI2 = I2;
         tempReal = period;
         if( (Im != 0.0) && (Re != 0.0) )
            period = 360.0 / ( Math.atan (Im/Re)*rad2Deg);
         tempReal2 = 1.5*tempReal;
         if( period > tempReal2)
            period = tempReal2;
         tempReal2 = 0.67*tempReal;
         if( period < tempReal2 )
            period = tempReal2;
         if( period < 6 )
            period = 6;
         else if( period > 50 )
            period = 50;
         period = (0.2*period) + (0.8 * tempReal);
         smoothPeriod = (0.33*period)+(0.67*smoothPeriod);
         if( today >= startIdx )
         {
            outReal[outIdx++] = smoothPeriod;
         }
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   struct TA_HT_DCPERIOD_HILBERT_STRUCT { double []_Odd = new double[3] ; double []_Even = new double[3] ; double var; double prev_Odd; double prev_Even; double prev_input_Odd; double prev_input_Even; };
   public RetCode htDcPeriodStateInit( struct TA_htDcPeriod_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct htDcPeriod ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = htDcPeriodLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_HT_DCPERIOD_Data));
      else
         _state.value .value .memory = NULL;
      { _state.value .value .detrender = calloc(1, sizeof(struct TA_HT_DCPERIOD_HILBERT_STRUCT )); if ( _state.value .value .detrender == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .Q1 = calloc(1, sizeof(struct TA_HT_DCPERIOD_HILBERT_STRUCT )); if ( _state.value .value .Q1 == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .jI = calloc(1, sizeof(struct TA_HT_DCPERIOD_HILBERT_STRUCT )); if ( _state.value .value .jI == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .jQ = calloc(1, sizeof(struct TA_HT_DCPERIOD_HILBERT_STRUCT )); if ( _state.value .value .jQ == NULL) return RetCode.AllocErr ; } ;
      return RetCode.Success ;
   }
   public RetCode htDcPeriodState( struct TA_htDcPeriod_State* _state,
      double inReal,
      double *outReal )
   {
      double hilbertTempReal, smoothedValue;
      double adjustedPrevPeriod;
      double Q2, I2;
      double tempReal, tempReal2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .periodWMASub = 0.;
         _state.value .periodWMASum = 0.;
         _state.value .hilbertIdx = 0;
         _state.value .period = 0;
         _state.value .prevI2 = 0.;
         _state.value .prevQ2 = 0.;
         _state.value .I1ForOddPrev2 = 0;
         _state.value .I1ForEvenPrev2 = 0;
         _state.value .I1ForOddPrev3 = 0;
         _state.value .I1ForEvenPrev3 = 0;
         _state.value .smoothPeriod = 0.0;
         _state.value .Im = 0.;
         _state.value .Re = 0.;
         _state.value .trailingWMAValue = 0.;
         _state.value .rad2Deg = 180.0 / (4.0 * Math.atan (1));
         _state.value .a = 0.0962;
         _state.value .b = 0.5769;
         { struct TA_HT_DCPERIOD_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .detrender; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_HT_DCPERIOD_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .Q1; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_HT_DCPERIOD_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .jI; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_HT_DCPERIOD_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .jQ; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
      }
      if ( _state.value .mem_index < 4)
      {
         _state.value .periodWMASub += inReal;
         _state.value .periodWMASum += _state.value .mem_index*inReal;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      } else
         if ( _state.value .mem_index <= 12)
      {
         { _state.value .periodWMASub += inReal; _state.value .periodWMASub -= _state.value .trailingWMAValue; _state.value .periodWMASum += inReal*4.0; _state.value .trailingWMAValue = ( _state.value .memory+(( _state.value .mem_index-1+-3)% _state.value .mem_size ) ).value .inReal ; smoothedValue = _state.value .periodWMASum*0.1; _state.value .periodWMASum -= _state.value .periodWMASub; } ;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      }
      adjustedPrevPeriod = (0.075* _state.value .period)+0.54;
      { _state.value .periodWMASub += inReal; _state.value .periodWMASub -= _state.value .trailingWMAValue; _state.value .periodWMASum += inReal*4.0; _state.value .trailingWMAValue = ( _state.value .memory+(( _state.value .mem_index-1+-3)% _state.value .mem_size ) ).value .inReal ; smoothedValue = _state.value .periodWMASum*0.1; _state.value .periodWMASum -= _state.value .periodWMASub; } ;
      if( (( _state.value .mem_index+1)%2) == 0 )
      {
         { struct TA_HT_DCPERIOD_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .detrender; hilbertTempReal = _state.value .a * smoothedValue; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = smoothedValue; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_DCPERIOD_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .Q1; hilbertTempReal = _state.value .a * (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_DCPERIOD_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .jI; hilbertTempReal = _state.value .a * _state.value .I1ForEvenPrev3; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = _state.value .I1ForEvenPrev3; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_DCPERIOD_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .jQ; hilbertTempReal = _state.value .a * (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         if( ++ _state.value .hilbertIdx == 3 )
            _state.value .hilbertIdx = 0;
         Q2 = (0.2*( (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .Q1.value .var + (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .jI.value .var )) + (0.8* _state.value .prevQ2);
         I2 = (0.2*( _state.value .I1ForEvenPrev3 - (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .jQ.value .var )) + (0.8* _state.value .prevI2);
         _state.value .I1ForOddPrev3 = _state.value .I1ForOddPrev2;
         _state.value .I1ForOddPrev2 = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .detrender.value .var ;
      } else {
         { struct TA_HT_DCPERIOD_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .detrender; hilbertTempReal = _state.value .a * smoothedValue; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = smoothedValue; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_DCPERIOD_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .Q1; hilbertTempReal = _state.value .a * (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_DCPERIOD_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .jI; hilbertTempReal = _state.value .a * _state.value .I1ForOddPrev3; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = _state.value .I1ForOddPrev3; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_DCPERIOD_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .jQ; hilbertTempReal = _state.value .a * (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         Q2 = (0.2*( (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .Q1.value .var + (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .jI.value .var )) + (0.8* _state.value .prevQ2);
         I2 = (0.2*( _state.value .I1ForOddPrev3 - (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .jQ.value .var )) + (0.8* _state.value .prevI2);
         _state.value .I1ForEvenPrev3 = _state.value .I1ForEvenPrev2;
         _state.value .I1ForEvenPrev2 = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .detrender.value .var ;
      }
      _state.value .Re = (0.2*((I2* _state.value .prevI2)+(Q2* _state.value .prevQ2)))+(0.8* _state.value .Re);
      _state.value .Im = (0.2*((I2* _state.value .prevQ2)-(Q2* _state.value .prevI2)))+(0.8* _state.value .Im);
      _state.value .prevQ2 = Q2;
      _state.value .prevI2 = I2;
      tempReal = _state.value .period;
      if( ( _state.value .Im != 0.0) && ( _state.value .Re != 0.0) )
         _state.value .period = 360.0 / ( Math.atan ( _state.value .Im/ _state.value .Re)* _state.value .rad2Deg);
      tempReal2 = 1.5*tempReal;
      if( _state.value .period > tempReal2)
         _state.value .period = tempReal2;
      tempReal2 = 0.67*tempReal;
      if( _state.value .period < tempReal2 )
         _state.value .period = tempReal2;
      if( _state.value .period < 6 )
         _state.value .period = 6;
      else if( _state.value .period > 50 )
         _state.value .period = 50;
      _state.value .period = (0.2* _state.value .period) + (0.8 * tempReal);
      _state.value .smoothPeriod = (0.33* _state.value .period)+(0.67* _state.value .smoothPeriod);
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      else {
         outReal.value = _state.value .smoothPeriod;
         return RetCode.Success ;
      }
   }
   public RetCode htDcPeriodStateFree( struct TA_htDcPeriod_State** _state )
   {
      { if ( _state.value .value .detrender != NULL) { free ( _state.value .value .detrender); _state.value .value .detrender = NULL; } } ;
      { if ( _state.value .value .Q1 != NULL) { free ( _state.value .value .Q1); _state.value .value .Q1 = NULL; } } ;
      { if ( _state.value .value .jI != NULL) { free ( _state.value .value .jI); _state.value .value .jI = NULL; } } ;
      { if ( _state.value .value .jQ != NULL) { free ( _state.value .value .jQ); _state.value .value .jQ = NULL; } } ;
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode htDcPeriodStateSave( struct TA_htDcPeriod_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_HT_DCPERIOD_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .hilbertIdx,sizeof( _state.value .hilbertIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodWMASub,sizeof( _state.value .periodWMASub),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodWMASum,sizeof( _state.value .periodWMASum),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .period,sizeof( _state.value .period),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .I1ForOddPrev2,sizeof( _state.value .I1ForOddPrev2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .I1ForEvenPrev2,sizeof( _state.value .I1ForEvenPrev2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .I1ForOddPrev3,sizeof( _state.value .I1ForOddPrev3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .I1ForEvenPrev3,sizeof( _state.value .I1ForEvenPrev3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevI2,sizeof( _state.value .prevI2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevQ2,sizeof( _state.value .prevQ2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .smoothPeriod,sizeof( _state.value .smoothPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .Im,sizeof( _state.value .Im),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .Re,sizeof( _state.value .Re),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .trailingWMAValue,sizeof( _state.value .trailingWMAValue),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .rad2Deg,sizeof( _state.value .rad2Deg),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .a,sizeof( _state.value .a),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .b,sizeof( _state.value .b),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      { if ( _state.value .detrender == NULL) return RetCode.BadParam ; if (fwrite( _state.value .detrender,sizeof(struct TA_HT_DCPERIOD_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .Q1 == NULL) return RetCode.BadParam ; if (fwrite( _state.value .Q1,sizeof(struct TA_HT_DCPERIOD_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .jI == NULL) return RetCode.BadParam ; if (fwrite( _state.value .jI,sizeof(struct TA_HT_DCPERIOD_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .jQ == NULL) return RetCode.BadParam ; if (fwrite( _state.value .jQ,sizeof(struct TA_HT_DCPERIOD_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode htDcPeriodStateLoad( struct TA_htDcPeriod_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct htDcPeriod ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_HT_DCPERIOD_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_HT_DCPERIOD_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .hilbertIdx,sizeof( _state.value .value .hilbertIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodWMASub,sizeof( _state.value .value .periodWMASub),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodWMASum,sizeof( _state.value .value .periodWMASum),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .period,sizeof( _state.value .value .period),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .I1ForOddPrev2,sizeof( _state.value .value .I1ForOddPrev2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .I1ForEvenPrev2,sizeof( _state.value .value .I1ForEvenPrev2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .I1ForOddPrev3,sizeof( _state.value .value .I1ForOddPrev3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .I1ForEvenPrev3,sizeof( _state.value .value .I1ForEvenPrev3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevI2,sizeof( _state.value .value .prevI2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevQ2,sizeof( _state.value .value .prevQ2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .smoothPeriod,sizeof( _state.value .value .smoothPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .Im,sizeof( _state.value .value .Im),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .Re,sizeof( _state.value .value .Re),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .trailingWMAValue,sizeof( _state.value .value .trailingWMAValue),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .rad2Deg,sizeof( _state.value .value .rad2Deg),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .a,sizeof( _state.value .value .a),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .b,sizeof( _state.value .value .b),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      { if ( _state.value .value .detrender != NULL) return RetCode.BadParam ; { _state.value .value .detrender = calloc(1, sizeof(struct TA_HT_DCPERIOD_HILBERT_STRUCT )); if ( _state.value .value .detrender == NULL) return RetCode.AllocErr ; } if (fread( _state.value .value .detrender,sizeof(struct TA_HT_DCPERIOD_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .value .Q1 != NULL) return RetCode.BadParam ; { _state.value .value .Q1 = calloc(1, sizeof(struct TA_HT_DCPERIOD_HILBERT_STRUCT )); if ( _state.value .value .Q1 == NULL) return RetCode.AllocErr ; } if (fread( _state.value .value .Q1,sizeof(struct TA_HT_DCPERIOD_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .value .jI != NULL) return RetCode.BadParam ; { _state.value .value .jI = calloc(1, sizeof(struct TA_HT_DCPERIOD_HILBERT_STRUCT )); if ( _state.value .value .jI == NULL) return RetCode.AllocErr ; } if (fread( _state.value .value .jI,sizeof(struct TA_HT_DCPERIOD_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .value .jQ != NULL) return RetCode.BadParam ; { _state.value .value .jQ = calloc(1, sizeof(struct TA_HT_DCPERIOD_HILBERT_STRUCT )); if ( _state.value .value .jQ == NULL) return RetCode.AllocErr ; } if (fread( _state.value .value .jQ,sizeof(struct TA_HT_DCPERIOD_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode htDcPeriod( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      int lookbackTotal, today;
      double tempReal, tempReal2;
      double adjustedPrevPeriod, period;
      int trailingWMAIdx;
      double periodWMASum, periodWMASub, trailingWMAValue;
      double smoothedValue;
      final double a = 0.0962;
      final double b = 0.5769;
      double hilbertTempReal;
      int hilbertIdx;
      double []detrender_Odd = new double[3] ; double []detrender_Even = new double[3] ; double detrender; double prev_detrender_Odd ; double prev_detrender_Even ; double prev_detrender_input_Odd ; double prev_detrender_input_Even ;
      double []Q1_Odd = new double[3] ; double []Q1_Even = new double[3] ; double Q1; double prev_Q1_Odd ; double prev_Q1_Even ; double prev_Q1_input_Odd ; double prev_Q1_input_Even ;
      double []jI_Odd = new double[3] ; double []jI_Even = new double[3] ; double jI; double prev_jI_Odd ; double prev_jI_Even ; double prev_jI_input_Odd ; double prev_jI_input_Even ;
      double []jQ_Odd = new double[3] ; double []jQ_Even = new double[3] ; double jQ; double prev_jQ_Odd ; double prev_jQ_Even ; double prev_jQ_input_Odd ; double prev_jQ_input_Even ;
      double Q2, I2, prevQ2, prevI2, Re, Im;
      double I1ForOddPrev2, I1ForOddPrev3;
      double I1ForEvenPrev2, I1ForEvenPrev3;
      double rad2Deg;
      double todayValue, smoothPeriod;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      rad2Deg = 180.0 / (4.0 * Math.atan (1));
      lookbackTotal = 32 + (this.unstablePeriod[FuncUnstId.HtDcPeriod.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingWMAIdx = startIdx - lookbackTotal;
      today = trailingWMAIdx;
      tempReal = inReal[today++];
      periodWMASub = tempReal;
      periodWMASum = tempReal;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*2.0;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*3.0;
      trailingWMAValue = 0.0;
      i = 9;
      do
      {
         tempReal = inReal[today++];
         { periodWMASub += tempReal; periodWMASub -= trailingWMAValue; periodWMASum += tempReal*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
      } while( --i != 0);
      hilbertIdx = 0;
      { detrender_Odd [0] = 0.0; detrender_Odd [1] = 0.0; detrender_Odd [2] = 0.0; detrender_Even [0] = 0.0; detrender_Even [1] = 0.0; detrender_Even [2] = 0.0; detrender = 0.0; prev_detrender_Odd = 0.0; prev_detrender_Even = 0.0; prev_detrender_input_Odd = 0.0; prev_detrender_input_Even = 0.0; } ;
      { Q1_Odd [0] = 0.0; Q1_Odd [1] = 0.0; Q1_Odd [2] = 0.0; Q1_Even [0] = 0.0; Q1_Even [1] = 0.0; Q1_Even [2] = 0.0; Q1 = 0.0; prev_Q1_Odd = 0.0; prev_Q1_Even = 0.0; prev_Q1_input_Odd = 0.0; prev_Q1_input_Even = 0.0; } ;
      { jI_Odd [0] = 0.0; jI_Odd [1] = 0.0; jI_Odd [2] = 0.0; jI_Even [0] = 0.0; jI_Even [1] = 0.0; jI_Even [2] = 0.0; jI = 0.0; prev_jI_Odd = 0.0; prev_jI_Even = 0.0; prev_jI_input_Odd = 0.0; prev_jI_input_Even = 0.0; } ;
      { jQ_Odd [0] = 0.0; jQ_Odd [1] = 0.0; jQ_Odd [2] = 0.0; jQ_Even [0] = 0.0; jQ_Even [1] = 0.0; jQ_Even [2] = 0.0; jQ = 0.0; prev_jQ_Odd = 0.0; prev_jQ_Even = 0.0; prev_jQ_input_Odd = 0.0; prev_jQ_input_Even = 0.0; } ;
      period = 0.0;
      outIdx = 0;
      prevI2 = prevQ2 = 0.0;
      Re = Im = 0.0;
      I1ForOddPrev3 = I1ForEvenPrev3 = 0.0;
      I1ForOddPrev2 = I1ForEvenPrev2 = 0.0;
      smoothPeriod = 0.0;
      while( today <= endIdx )
      {
         adjustedPrevPeriod = (0.075*period)+0.54;
         todayValue = inReal[today];
         { periodWMASub += todayValue; periodWMASub -= trailingWMAValue; periodWMASum += todayValue*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
         if( (today%2) == 0 )
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Even [hilbertIdx]; detrender_Even [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Even ; prev_detrender_Even = b * prev_detrender_input_Even ; detrender += prev_detrender_Even ; prev_detrender_input_Even = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Even [hilbertIdx]; Q1_Even [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Even ; prev_Q1_Even = b * prev_Q1_input_Even ; Q1 += prev_Q1_Even ; prev_Q1_input_Even = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForEvenPrev3; jI = -jI_Even [hilbertIdx]; jI_Even [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Even ; prev_jI_Even = b * prev_jI_input_Even ; jI += prev_jI_Even ; prev_jI_input_Even = I1ForEvenPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Even [hilbertIdx]; jQ_Even [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Even ; prev_jQ_Even = b * prev_jQ_input_Even ; jQ += prev_jQ_Even ; prev_jQ_input_Even = Q1; jQ *= adjustedPrevPeriod; } ;
            if( ++hilbertIdx == 3 )
               hilbertIdx = 0;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForEvenPrev3 - jQ)) + (0.8*prevI2);
            I1ForOddPrev3 = I1ForOddPrev2;
            I1ForOddPrev2 = detrender;
         }
         else
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Odd [hilbertIdx]; detrender_Odd [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Odd ; prev_detrender_Odd = b * prev_detrender_input_Odd ; detrender += prev_detrender_Odd ; prev_detrender_input_Odd = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Odd [hilbertIdx]; Q1_Odd [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Odd ; prev_Q1_Odd = b * prev_Q1_input_Odd ; Q1 += prev_Q1_Odd ; prev_Q1_input_Odd = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForOddPrev3; jI = -jI_Odd [hilbertIdx]; jI_Odd [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Odd ; prev_jI_Odd = b * prev_jI_input_Odd ; jI += prev_jI_Odd ; prev_jI_input_Odd = I1ForOddPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Odd [hilbertIdx]; jQ_Odd [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Odd ; prev_jQ_Odd = b * prev_jQ_input_Odd ; jQ += prev_jQ_Odd ; prev_jQ_input_Odd = Q1; jQ *= adjustedPrevPeriod; } ;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForOddPrev3 - jQ)) + (0.8*prevI2);
            I1ForEvenPrev3 = I1ForEvenPrev2;
            I1ForEvenPrev2 = detrender;
         }
         Re = (0.2*((I2*prevI2)+(Q2*prevQ2)))+(0.8*Re);
         Im = (0.2*((I2*prevQ2)-(Q2*prevI2)))+(0.8*Im);
         prevQ2 = Q2;
         prevI2 = I2;
         tempReal = period;
         if( (Im != 0.0) && (Re != 0.0) )
            period = 360.0 / ( Math.atan (Im/Re)*rad2Deg);
         tempReal2 = 1.5*tempReal;
         if( period > tempReal2)
            period = tempReal2;
         tempReal2 = 0.67*tempReal;
         if( period < tempReal2 )
            period = tempReal2;
         if( period < 6 )
            period = 6;
         else if( period > 50 )
            period = 50;
         period = (0.2*period) + (0.8 * tempReal);
         smoothPeriod = (0.33*period)+(0.67*smoothPeriod);
         if( today >= startIdx )
         {
            outReal[outIdx++] = smoothPeriod;
         }
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int htDcPhaseLookback( )
   {
      return 63 + (this.unstablePeriod[FuncUnstId.HtDcPhase.ordinal()]) ;
   }
   public RetCode htDcPhase( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      int lookbackTotal, today;
      double tempReal, tempReal2;
      double adjustedPrevPeriod, period;
      int trailingWMAIdx;
      double periodWMASum, periodWMASub, trailingWMAValue;
      double smoothedValue;
      final double a = 0.0962;
      final double b = 0.5769;
      double hilbertTempReal;
      int hilbertIdx;
      double []detrender_Odd = new double[3] ; double []detrender_Even = new double[3] ; double detrender; double prev_detrender_Odd ; double prev_detrender_Even ; double prev_detrender_input_Odd ; double prev_detrender_input_Even ;
      double []Q1_Odd = new double[3] ; double []Q1_Even = new double[3] ; double Q1; double prev_Q1_Odd ; double prev_Q1_Even ; double prev_Q1_input_Odd ; double prev_Q1_input_Even ;
      double []jI_Odd = new double[3] ; double []jI_Even = new double[3] ; double jI; double prev_jI_Odd ; double prev_jI_Even ; double prev_jI_input_Odd ; double prev_jI_input_Even ;
      double []jQ_Odd = new double[3] ; double []jQ_Even = new double[3] ; double jQ; double prev_jQ_Odd ; double prev_jQ_Even ; double prev_jQ_input_Odd ; double prev_jQ_input_Even ;
      double Q2, I2, prevQ2, prevI2, Re, Im;
      double I1ForOddPrev2, I1ForOddPrev3;
      double I1ForEvenPrev2, I1ForEvenPrev3;
      double rad2Deg, constDeg2RadBy360;
      double todayValue, smoothPeriod;
      int smoothPrice_Idx = 0; double []smoothPrice; int maxIdx_smoothPrice = ( 50 -1) ;
      int idx;
      int DCPeriodInt;
      double DCPhase, DCPeriod, imagPart, realPart;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      { smoothPrice = new double[maxIdx_smoothPrice +1]; } ;
      tempReal = Math.atan (1);
      rad2Deg = 45.0/tempReal;
      constDeg2RadBy360 = tempReal*8.0;
      lookbackTotal = 63 + (this.unstablePeriod[FuncUnstId.HtDcPhase.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingWMAIdx = startIdx - lookbackTotal;
      today = trailingWMAIdx;
      tempReal = inReal[today++];
      periodWMASub = tempReal;
      periodWMASum = tempReal;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*2.0;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*3.0;
      trailingWMAValue = 0.0;
      i = 34;
      do
      {
         tempReal = inReal[today++];
         { periodWMASub += tempReal; periodWMASub -= trailingWMAValue; periodWMASum += tempReal*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
      } while( --i != 0);
      hilbertIdx = 0;
      { detrender_Odd [0] = 0.0; detrender_Odd [1] = 0.0; detrender_Odd [2] = 0.0; detrender_Even [0] = 0.0; detrender_Even [1] = 0.0; detrender_Even [2] = 0.0; detrender = 0.0; prev_detrender_Odd = 0.0; prev_detrender_Even = 0.0; prev_detrender_input_Odd = 0.0; prev_detrender_input_Even = 0.0; } ;
      { Q1_Odd [0] = 0.0; Q1_Odd [1] = 0.0; Q1_Odd [2] = 0.0; Q1_Even [0] = 0.0; Q1_Even [1] = 0.0; Q1_Even [2] = 0.0; Q1 = 0.0; prev_Q1_Odd = 0.0; prev_Q1_Even = 0.0; prev_Q1_input_Odd = 0.0; prev_Q1_input_Even = 0.0; } ;
      { jI_Odd [0] = 0.0; jI_Odd [1] = 0.0; jI_Odd [2] = 0.0; jI_Even [0] = 0.0; jI_Even [1] = 0.0; jI_Even [2] = 0.0; jI = 0.0; prev_jI_Odd = 0.0; prev_jI_Even = 0.0; prev_jI_input_Odd = 0.0; prev_jI_input_Even = 0.0; } ;
      { jQ_Odd [0] = 0.0; jQ_Odd [1] = 0.0; jQ_Odd [2] = 0.0; jQ_Even [0] = 0.0; jQ_Even [1] = 0.0; jQ_Even [2] = 0.0; jQ = 0.0; prev_jQ_Odd = 0.0; prev_jQ_Even = 0.0; prev_jQ_input_Odd = 0.0; prev_jQ_input_Even = 0.0; } ;
      period = 0.0;
      outIdx = 0;
      prevI2 = prevQ2 = 0.0;
      Re = Im = 0.0;
      I1ForOddPrev3 = I1ForEvenPrev3 = 0.0;
      I1ForOddPrev2 = I1ForEvenPrev2 = 0.0;
      smoothPeriod = 0.0;
      for( i=0; i < 50 ; i++ )
         smoothPrice[i] = 0.0;
      DCPhase = 0.0;
      while( today <= endIdx )
      {
         adjustedPrevPeriod = (0.075*period)+0.54;
         todayValue = inReal[today];
         { periodWMASub += todayValue; periodWMASub -= trailingWMAValue; periodWMASum += todayValue*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
         smoothPrice[smoothPrice_Idx] = smoothedValue;
         if( (today%2) == 0 )
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Even [hilbertIdx]; detrender_Even [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Even ; prev_detrender_Even = b * prev_detrender_input_Even ; detrender += prev_detrender_Even ; prev_detrender_input_Even = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Even [hilbertIdx]; Q1_Even [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Even ; prev_Q1_Even = b * prev_Q1_input_Even ; Q1 += prev_Q1_Even ; prev_Q1_input_Even = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForEvenPrev3; jI = -jI_Even [hilbertIdx]; jI_Even [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Even ; prev_jI_Even = b * prev_jI_input_Even ; jI += prev_jI_Even ; prev_jI_input_Even = I1ForEvenPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Even [hilbertIdx]; jQ_Even [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Even ; prev_jQ_Even = b * prev_jQ_input_Even ; jQ += prev_jQ_Even ; prev_jQ_input_Even = Q1; jQ *= adjustedPrevPeriod; } ;
            if( ++hilbertIdx == 3 )
               hilbertIdx = 0;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForEvenPrev3 - jQ)) + (0.8*prevI2);
            I1ForOddPrev3 = I1ForOddPrev2;
            I1ForOddPrev2 = detrender;
         }
         else
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Odd [hilbertIdx]; detrender_Odd [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Odd ; prev_detrender_Odd = b * prev_detrender_input_Odd ; detrender += prev_detrender_Odd ; prev_detrender_input_Odd = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Odd [hilbertIdx]; Q1_Odd [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Odd ; prev_Q1_Odd = b * prev_Q1_input_Odd ; Q1 += prev_Q1_Odd ; prev_Q1_input_Odd = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForOddPrev3; jI = -jI_Odd [hilbertIdx]; jI_Odd [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Odd ; prev_jI_Odd = b * prev_jI_input_Odd ; jI += prev_jI_Odd ; prev_jI_input_Odd = I1ForOddPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Odd [hilbertIdx]; jQ_Odd [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Odd ; prev_jQ_Odd = b * prev_jQ_input_Odd ; jQ += prev_jQ_Odd ; prev_jQ_input_Odd = Q1; jQ *= adjustedPrevPeriod; } ;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForOddPrev3 - jQ)) + (0.8*prevI2);
            I1ForEvenPrev3 = I1ForEvenPrev2;
            I1ForEvenPrev2 = detrender;
         }
         Re = (0.2*((I2*prevI2)+(Q2*prevQ2)))+(0.8*Re);
         Im = (0.2*((I2*prevQ2)-(Q2*prevI2)))+(0.8*Im);
         prevQ2 = Q2;
         prevI2 = I2;
         tempReal = period;
         if( (Im != 0.0) && (Re != 0.0) )
            period = 360.0 / ( Math.atan (Im/Re)*rad2Deg);
         tempReal2 = 1.5*tempReal;
         if( period > tempReal2)
            period = tempReal2;
         tempReal2 = 0.67*tempReal;
         if( period < tempReal2 )
            period = tempReal2;
         if( period < 6 )
            period = 6;
         else if( period > 50 )
            period = 50;
         period = (0.2*period) + (0.8 * tempReal);
         smoothPeriod = (0.33*period)+(0.67*smoothPeriod);
         DCPeriod = smoothPeriod+0.5;
         DCPeriodInt = (int)DCPeriod;
         realPart = 0.0;
         imagPart = 0.0;
         idx = smoothPrice_Idx;
         for( i=0; i < DCPeriodInt; i++ )
         {
            tempReal = ((double)i*constDeg2RadBy360)/(double)DCPeriodInt;
            tempReal2 = smoothPrice[idx];
            realPart += Math.sin (tempReal)*tempReal2;
            imagPart += Math.cos (tempReal)*tempReal2;
            if( idx == 0 )
               idx = 50 -1;
            else
               idx--;
         }
         tempReal = Math.abs (imagPart);
         if( tempReal > 0.0 )
            DCPhase = Math.atan (realPart/imagPart)*rad2Deg;
         else if( tempReal <= 0.01 )
         {
            if( realPart < 0.0 )
               DCPhase -= 90.0;
            else if( realPart > 0.0 )
               DCPhase += 90.0;
         }
         DCPhase += 90.0;
         DCPhase += 360.0 / smoothPeriod;
         if( imagPart < 0.0 )
            DCPhase += 180.0;
         if( DCPhase > 315.0 )
            DCPhase -= 360.0;
         if( today >= startIdx )
         {
            outReal[outIdx++] = DCPhase;
         }
         { smoothPrice_Idx ++; if( smoothPrice_Idx > maxIdx_smoothPrice ) smoothPrice_Idx = 0; } ;
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   struct TA_HT_DCPHASE_STATE_CIRCBUF { int idx; double* circbuf; int size; };
   struct TA_HT_DCPHASE_HILBERT_STRUCT { double []_Odd = new double[3] ; double []_Even = new double[3] ; double var; double prev_Odd; double prev_Even; double prev_input_Odd; double prev_input_Even; };
   public RetCode htDcPhaseStateInit( struct TA_htDcPhase_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct htDcPhase ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = htDcPhaseLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_HT_DCPHASE_Data));
      else
         _state.value .value .memory = NULL;
      { _state.value .value .circBuf = calloc(1, sizeof(struct TA_HT_DCPHASE_STATE_CIRCBUF )); if ( _state.value .value .circBuf == NULL) return RetCode.AllocErr ; struct TA_HT_DCPHASE_STATE_CIRCBUF * buf = (struct TA_HT_DCPHASE_STATE_CIRCBUF *) _state.value .value .circBuf; buf->idx = 0; buf->size = 50; buf->circbuf = calloc(50, sizeof(double)); if (!buf->circbuf) return RetCode.AllocErr ;} ;
      { _state.value .value .detrender = calloc(1, sizeof(struct TA_HT_DCPHASE_HILBERT_STRUCT )); if ( _state.value .value .detrender == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .Q1 = calloc(1, sizeof(struct TA_HT_DCPHASE_HILBERT_STRUCT )); if ( _state.value .value .Q1 == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .jI = calloc(1, sizeof(struct TA_HT_DCPHASE_HILBERT_STRUCT )); if ( _state.value .value .jI == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .jQ = calloc(1, sizeof(struct TA_HT_DCPHASE_HILBERT_STRUCT )); if ( _state.value .value .jQ == NULL) return RetCode.AllocErr ; } ;
      return RetCode.Success ;
   }
   public RetCode htDcPhaseState( struct TA_htDcPhase_State* _state,
      double inReal,
      double *outReal )
   {
      double hilbertTempReal, smoothedValue;
      double adjustedPrevPeriod;
      double Q2, I2;
      double tempReal, tempReal2;
      int DCPeriodInt;
      double DCPeriod, imagPart, realPart;
      int idx, i;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .periodWMASub = 0.;
         _state.value .periodWMASum = 0.;
         _state.value .hilbertIdx = 0;
         _state.value .period = 0;
         _state.value .prevI2 = 0.;
         _state.value .prevQ2 = 0.;
         _state.value .I1ForOddPrev2 = 0;
         _state.value .I1ForEvenPrev2 = 0;
         _state.value .I1ForOddPrev3 = 0;
         _state.value .I1ForEvenPrev3 = 0;
         _state.value .smoothPeriod = 0;
         _state.value .Im = 0.;
         _state.value .Re = 0.;
         _state.value .trailingWMAValue = 0.;
         _state.value .rad2Deg = 180.0 / (4.0 * Math.atan (1));
         _state.value .constDeg2RadBy360 = Math.atan (1)*8.0;
         _state.value .DCPhase = 0;
         _state.value .a = 0.0962;
         _state.value .b = 0.5769;
         { struct TA_HT_DCPHASE_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPHASE_HILBERT_STRUCT *) _state.value .detrender; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_HT_DCPHASE_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPHASE_HILBERT_STRUCT *) _state.value .Q1; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_HT_DCPHASE_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPHASE_HILBERT_STRUCT *) _state.value .jI; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_HT_DCPHASE_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPHASE_HILBERT_STRUCT *) _state.value .jQ; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
      }
      if ( _state.value .mem_index < 4)
      {
         _state.value .periodWMASub += inReal;
         _state.value .periodWMASum += _state.value .mem_index*inReal;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      } else
         if ( _state.value .mem_index <= 37)
      {
         { _state.value .periodWMASub += inReal; _state.value .periodWMASub -= _state.value .trailingWMAValue; _state.value .periodWMASum += inReal*4.0; _state.value .trailingWMAValue = ( _state.value .memory+(( _state.value .mem_index-1+-3)% _state.value .mem_size ) ).value .inReal ; smoothedValue = _state.value .periodWMASum*0.1; _state.value .periodWMASum -= _state.value .periodWMASub; } ;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      }
      adjustedPrevPeriod = (0.075* _state.value .period)+0.54;
      { _state.value .periodWMASub += inReal; _state.value .periodWMASub -= _state.value .trailingWMAValue; _state.value .periodWMASum += inReal*4.0; _state.value .trailingWMAValue = ( _state.value .memory+(( _state.value .mem_index-1+-3)% _state.value .mem_size ) ).value .inReal ; smoothedValue = _state.value .periodWMASum*0.1; _state.value .periodWMASum -= _state.value .periodWMASub; } ;
      (*( ((struct TA_HT_DCPHASE_STATE_CIRCBUF *) _state.value .circBuf)->circbuf + ((struct TA_HT_DCPHASE_STATE_CIRCBUF *) _state.value .circBuf)->idx )) = smoothedValue;
      if( (( _state.value .mem_index+1)%2) == 0 )
      {
         { struct TA_HT_DCPHASE_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPHASE_HILBERT_STRUCT *) _state.value .detrender; hilbertTempReal = _state.value .a * smoothedValue; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = smoothedValue; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_DCPHASE_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPHASE_HILBERT_STRUCT *) _state.value .Q1; hilbertTempReal = _state.value .a * (struct TA_HT_DCPHASE_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = (struct TA_HT_DCPHASE_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_DCPHASE_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPHASE_HILBERT_STRUCT *) _state.value .jI; hilbertTempReal = _state.value .a * _state.value .I1ForEvenPrev3; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = _state.value .I1ForEvenPrev3; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_DCPHASE_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPHASE_HILBERT_STRUCT *) _state.value .jQ; hilbertTempReal = _state.value .a * (struct TA_HT_DCPHASE_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = (struct TA_HT_DCPHASE_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         if( ++ _state.value .hilbertIdx == 3 )
            _state.value .hilbertIdx = 0;
         Q2 = (0.2*( (struct TA_HT_DCPHASE_HILBERT_STRUCT *) _state.value .Q1.value .var + (struct TA_HT_DCPHASE_HILBERT_STRUCT *) _state.value .jI.value .var )) + (0.8* _state.value .prevQ2);
         I2 = (0.2*( _state.value .I1ForEvenPrev3 - (struct TA_HT_DCPHASE_HILBERT_STRUCT *) _state.value .jQ.value .var )) + (0.8* _state.value .prevI2);
         _state.value .I1ForOddPrev3 = _state.value .I1ForOddPrev2;
         _state.value .I1ForOddPrev2 = (struct TA_HT_DCPHASE_HILBERT_STRUCT *) _state.value .detrender.value .var ;
      } else {
         { struct TA_HT_DCPHASE_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPHASE_HILBERT_STRUCT *) _state.value .detrender; hilbertTempReal = _state.value .a * smoothedValue; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = smoothedValue; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_DCPHASE_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPHASE_HILBERT_STRUCT *) _state.value .Q1; hilbertTempReal = _state.value .a * (struct TA_HT_DCPHASE_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = (struct TA_HT_DCPHASE_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_DCPHASE_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPHASE_HILBERT_STRUCT *) _state.value .jI; hilbertTempReal = _state.value .a * _state.value .I1ForOddPrev3; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = _state.value .I1ForOddPrev3; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_DCPHASE_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPHASE_HILBERT_STRUCT *) _state.value .jQ; hilbertTempReal = _state.value .a * (struct TA_HT_DCPHASE_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = (struct TA_HT_DCPHASE_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         Q2 = (0.2*( (struct TA_HT_DCPHASE_HILBERT_STRUCT *) _state.value .Q1.value .var + (struct TA_HT_DCPHASE_HILBERT_STRUCT *) _state.value .jI.value .var )) + (0.8* _state.value .prevQ2);
         I2 = (0.2*( _state.value .I1ForOddPrev3 - (struct TA_HT_DCPHASE_HILBERT_STRUCT *) _state.value .jQ.value .var )) + (0.8* _state.value .prevI2);
         _state.value .I1ForEvenPrev3 = _state.value .I1ForEvenPrev2;
         _state.value .I1ForEvenPrev2 = (struct TA_HT_DCPHASE_HILBERT_STRUCT *) _state.value .detrender.value .var ;
      }
      _state.value .Re = (0.2*((I2* _state.value .prevI2)+(Q2* _state.value .prevQ2)))+(0.8* _state.value .Re);
      _state.value .Im = (0.2*((I2* _state.value .prevQ2)-(Q2* _state.value .prevI2)))+(0.8* _state.value .Im);
      _state.value .prevQ2 = Q2;
      _state.value .prevI2 = I2;
      tempReal = _state.value .period;
      if( ( _state.value .Im != 0.0) && ( _state.value .Re != 0.0) )
         _state.value .period = 360.0 / ( Math.atan ( _state.value .Im/ _state.value .Re)* _state.value .rad2Deg);
      tempReal2 = 1.5*tempReal;
      if( _state.value .period > tempReal2)
         _state.value .period = tempReal2;
      tempReal2 = 0.67*tempReal;
      if( _state.value .period < tempReal2 )
         _state.value .period = tempReal2;
      if( _state.value .period < 6 )
         _state.value .period = 6;
      else if( _state.value .period > 50 )
         _state.value .period = 50;
      _state.value .period = (0.2* _state.value .period) + (0.8 * tempReal);
      _state.value .smoothPeriod = (0.33* _state.value .period)+(0.67* _state.value .smoothPeriod);
      DCPeriod = _state.value .smoothPeriod+0.5;
      DCPeriodInt = (int)DCPeriod;
      realPart = 0.0;
      imagPart = 0.0;
      idx = ((struct TA_HT_DCPHASE_STATE_CIRCBUF *) _state.value .circBuf)->idx ;
      for( i=0; i < DCPeriodInt; i++ )
      {
         tempReal = ((double)i* _state.value .constDeg2RadBy360)/(double)DCPeriodInt;
         tempReal2 = (*( ((struct TA_HT_DCPHASE_STATE_CIRCBUF *) _state.value .circBuf)->circbuf +idx)) ;
         realPart += Math.sin (tempReal)*tempReal2;
         imagPart += Math.cos (tempReal)*tempReal2;
         if( idx == 0 )
            idx = ((struct TA_HT_DCPHASE_STATE_CIRCBUF *) _state.value .circBuf)->size -1;
         else
            idx--;
      }
      tempReal = Math.abs (imagPart);
      if( tempReal > 0.0 )
         _state.value .DCPhase = Math.atan (realPart/imagPart)* _state.value .rad2Deg;
      else if( tempReal <= 0.01 )
      {
         if( realPart < 0.0 )
            _state.value .DCPhase -= 90.0;
         else if( realPart > 0.0 )
            _state.value .DCPhase += 90.0;
      }
      _state.value .DCPhase += 90.0;
      _state.value .DCPhase += 360.0 / _state.value .smoothPeriod;
      if( imagPart < 0.0 )
         _state.value .DCPhase += 180.0;
      if( _state.value .DCPhase > 315.0 )
         _state.value .DCPhase -= 360.0;
      { struct TA_HT_DCPHASE_STATE_CIRCBUF * buf = (struct TA_HT_DCPHASE_STATE_CIRCBUF *) _state.value .circBuf; if(buf->idx < buf->size-1) buf->idx++; else buf->idx = 0;} ;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      else {
         outReal.value = _state.value .DCPhase;
         return RetCode.Success ;
      }
   }
   public RetCode htDcPhaseStateFree( struct TA_htDcPhase_State** _state )
   {
      { if ( _state.value .value .detrender != NULL) { free ( _state.value .value .detrender); _state.value .value .detrender = NULL; } } ;
      { if ( _state.value .value .Q1 != NULL) { free ( _state.value .value .Q1); _state.value .value .Q1 = NULL; } } ;
      { if ( _state.value .value .jI != NULL) { free ( _state.value .value .jI); _state.value .value .jI = NULL; } } ;
      { if ( _state.value .value .jQ != NULL) { free ( _state.value .value .jQ); _state.value .value .jQ = NULL; } } ;
      { struct TA_HT_DCPHASE_STATE_CIRCBUF * buf = (struct TA_HT_DCPHASE_STATE_CIRCBUF *) _state.value .value .circBuf; if (buf != NULL) { if (buf->circbuf != NULL) free(buf->circbuf); free (buf); _state.value .value .circBuf = NULL; } } ;
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode htDcPhaseStateSave( struct TA_htDcPhase_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_HT_DCPHASE_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .hilbertIdx,sizeof( _state.value .hilbertIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodWMASub,sizeof( _state.value .periodWMASub),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodWMASum,sizeof( _state.value .periodWMASum),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .period,sizeof( _state.value .period),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .I1ForOddPrev2,sizeof( _state.value .I1ForOddPrev2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .I1ForEvenPrev2,sizeof( _state.value .I1ForEvenPrev2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .I1ForOddPrev3,sizeof( _state.value .I1ForOddPrev3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .I1ForEvenPrev3,sizeof( _state.value .I1ForEvenPrev3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevI2,sizeof( _state.value .prevI2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevQ2,sizeof( _state.value .prevQ2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .smoothPeriod,sizeof( _state.value .smoothPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .DCPhase,sizeof( _state.value .DCPhase),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .Im,sizeof( _state.value .Im),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .Re,sizeof( _state.value .Re),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .trailingWMAValue,sizeof( _state.value .trailingWMAValue),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .rad2Deg,sizeof( _state.value .rad2Deg),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .a,sizeof( _state.value .a),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .b,sizeof( _state.value .b),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .constDeg2RadBy360,sizeof( _state.value .constDeg2RadBy360),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      { if ( _state.value .detrender == NULL) return RetCode.BadParam ; if (fwrite( _state.value .detrender,sizeof(struct TA_HT_DCPHASE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .Q1 == NULL) return RetCode.BadParam ; if (fwrite( _state.value .Q1,sizeof(struct TA_HT_DCPHASE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .jI == NULL) return RetCode.BadParam ; if (fwrite( _state.value .jI,sizeof(struct TA_HT_DCPHASE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .jQ == NULL) return RetCode.BadParam ; if (fwrite( _state.value .jQ,sizeof(struct TA_HT_DCPHASE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { int io_circbuf_res; struct TA_HT_DCPHASE_STATE_CIRCBUF * str_circbuf = _state.value .circBuf; io_circbuf_res = fwrite(&str_circbuf->idx,sizeof(str_circbuf->idx),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; io_circbuf_res = fwrite(&str_circbuf->size,sizeof(str_circbuf->size),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; if (str_circbuf->size > 0) { io_circbuf_res = fwrite(str_circbuf->circbuf,sizeof(str_circbuf->circbuf),str_circbuf->size,_file); if (io_circbuf_res < str_circbuf->size) return RetCode.IOFailed ; } }
      return 0;
   }
   public RetCode htDcPhaseStateLoad( struct TA_htDcPhase_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct htDcPhase ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_HT_DCPHASE_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_HT_DCPHASE_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .hilbertIdx,sizeof( _state.value .value .hilbertIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodWMASub,sizeof( _state.value .value .periodWMASub),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodWMASum,sizeof( _state.value .value .periodWMASum),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .period,sizeof( _state.value .value .period),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .I1ForOddPrev2,sizeof( _state.value .value .I1ForOddPrev2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .I1ForEvenPrev2,sizeof( _state.value .value .I1ForEvenPrev2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .I1ForOddPrev3,sizeof( _state.value .value .I1ForOddPrev3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .I1ForEvenPrev3,sizeof( _state.value .value .I1ForEvenPrev3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevI2,sizeof( _state.value .value .prevI2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevQ2,sizeof( _state.value .value .prevQ2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .smoothPeriod,sizeof( _state.value .value .smoothPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .DCPhase,sizeof( _state.value .value .DCPhase),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .Im,sizeof( _state.value .value .Im),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .Re,sizeof( _state.value .value .Re),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .trailingWMAValue,sizeof( _state.value .value .trailingWMAValue),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .rad2Deg,sizeof( _state.value .value .rad2Deg),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .a,sizeof( _state.value .value .a),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .b,sizeof( _state.value .value .b),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .constDeg2RadBy360,sizeof( _state.value .value .constDeg2RadBy360),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      { if ( _state.value .value .detrender != NULL) return RetCode.BadParam ; { _state.value .value .detrender = calloc(1, sizeof(struct TA_HT_DCPHASE_HILBERT_STRUCT )); if ( _state.value .value .detrender == NULL) return RetCode.AllocErr ; } if (fread( _state.value .value .detrender,sizeof(struct TA_HT_DCPHASE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .value .Q1 != NULL) return RetCode.BadParam ; { _state.value .value .Q1 = calloc(1, sizeof(struct TA_HT_DCPHASE_HILBERT_STRUCT )); if ( _state.value .value .Q1 == NULL) return RetCode.AllocErr ; } if (fread( _state.value .value .Q1,sizeof(struct TA_HT_DCPHASE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .value .jI != NULL) return RetCode.BadParam ; { _state.value .value .jI = calloc(1, sizeof(struct TA_HT_DCPHASE_HILBERT_STRUCT )); if ( _state.value .value .jI == NULL) return RetCode.AllocErr ; } if (fread( _state.value .value .jI,sizeof(struct TA_HT_DCPHASE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .value .jQ != NULL) return RetCode.BadParam ; { _state.value .value .jQ = calloc(1, sizeof(struct TA_HT_DCPHASE_HILBERT_STRUCT )); if ( _state.value .value .jQ == NULL) return RetCode.AllocErr ; } if (fread( _state.value .value .jQ,sizeof(struct TA_HT_DCPHASE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { int io_circbuf_res; int circbuf_idx; int circbuf_size; if ( _state.value .value .circBuf != NULL) return RetCode.BadParam ; io_circbuf_res = fread(&circbuf_idx,sizeof(circbuf_idx),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; io_circbuf_res = fread(&circbuf_size,sizeof(circbuf_size),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; { _state.value .value .circBuf = calloc(1, sizeof(struct TA_HT_DCPHASE_STATE_CIRCBUF )); if ( _state.value .value .circBuf == NULL) return RetCode.AllocErr ; struct TA_HT_DCPHASE_STATE_CIRCBUF * buf = (struct TA_HT_DCPHASE_STATE_CIRCBUF *) _state.value .value .circBuf; buf->idx = 0; buf->size = circbuf_size; buf->circbuf = calloc(circbuf_size, sizeof(double)); if (!buf->circbuf) return RetCode.AllocErr ;} struct TA_HT_DCPHASE_STATE_CIRCBUF * str_circbuf = _state.value .value .circBuf; str_circbuf->idx = circbuf_idx; if (str_circbuf->size > 0) { io_circbuf_res = fread(str_circbuf->circbuf,sizeof(str_circbuf->circbuf),str_circbuf->size,_file); if (io_circbuf_res < str_circbuf->size) return RetCode.IOFailed ; } }
      return 0;
   }
   public RetCode htDcPhase( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      int lookbackTotal, today;
      double tempReal, tempReal2;
      double adjustedPrevPeriod, period;
      int trailingWMAIdx;
      double periodWMASum, periodWMASub, trailingWMAValue;
      double smoothedValue;
      final double a = 0.0962;
      final double b = 0.5769;
      double hilbertTempReal;
      int hilbertIdx;
      double []detrender_Odd = new double[3] ; double []detrender_Even = new double[3] ; double detrender; double prev_detrender_Odd ; double prev_detrender_Even ; double prev_detrender_input_Odd ; double prev_detrender_input_Even ;
      double []Q1_Odd = new double[3] ; double []Q1_Even = new double[3] ; double Q1; double prev_Q1_Odd ; double prev_Q1_Even ; double prev_Q1_input_Odd ; double prev_Q1_input_Even ;
      double []jI_Odd = new double[3] ; double []jI_Even = new double[3] ; double jI; double prev_jI_Odd ; double prev_jI_Even ; double prev_jI_input_Odd ; double prev_jI_input_Even ;
      double []jQ_Odd = new double[3] ; double []jQ_Even = new double[3] ; double jQ; double prev_jQ_Odd ; double prev_jQ_Even ; double prev_jQ_input_Odd ; double prev_jQ_input_Even ;
      double Q2, I2, prevQ2, prevI2, Re, Im;
      double I1ForOddPrev2, I1ForOddPrev3;
      double I1ForEvenPrev2, I1ForEvenPrev3;
      double rad2Deg, constDeg2RadBy360;
      double todayValue, smoothPeriod;
      int smoothPrice_Idx = 0; double []smoothPrice; int maxIdx_smoothPrice = ( 50 -1) ;
      int idx;
      int DCPeriodInt;
      double DCPhase, DCPeriod, imagPart, realPart;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      { smoothPrice = new double[maxIdx_smoothPrice +1]; } ;
      tempReal = Math.atan (1);
      rad2Deg = 45.0/tempReal;
      constDeg2RadBy360 = tempReal*8.0;
      lookbackTotal = 63 + (this.unstablePeriod[FuncUnstId.HtDcPhase.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingWMAIdx = startIdx - lookbackTotal;
      today = trailingWMAIdx;
      tempReal = inReal[today++];
      periodWMASub = tempReal;
      periodWMASum = tempReal;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*2.0;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*3.0;
      trailingWMAValue = 0.0;
      i = 34;
      do
      {
         tempReal = inReal[today++];
         { periodWMASub += tempReal; periodWMASub -= trailingWMAValue; periodWMASum += tempReal*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
      } while( --i != 0);
      hilbertIdx = 0;
      { detrender_Odd [0] = 0.0; detrender_Odd [1] = 0.0; detrender_Odd [2] = 0.0; detrender_Even [0] = 0.0; detrender_Even [1] = 0.0; detrender_Even [2] = 0.0; detrender = 0.0; prev_detrender_Odd = 0.0; prev_detrender_Even = 0.0; prev_detrender_input_Odd = 0.0; prev_detrender_input_Even = 0.0; } ;
      { Q1_Odd [0] = 0.0; Q1_Odd [1] = 0.0; Q1_Odd [2] = 0.0; Q1_Even [0] = 0.0; Q1_Even [1] = 0.0; Q1_Even [2] = 0.0; Q1 = 0.0; prev_Q1_Odd = 0.0; prev_Q1_Even = 0.0; prev_Q1_input_Odd = 0.0; prev_Q1_input_Even = 0.0; } ;
      { jI_Odd [0] = 0.0; jI_Odd [1] = 0.0; jI_Odd [2] = 0.0; jI_Even [0] = 0.0; jI_Even [1] = 0.0; jI_Even [2] = 0.0; jI = 0.0; prev_jI_Odd = 0.0; prev_jI_Even = 0.0; prev_jI_input_Odd = 0.0; prev_jI_input_Even = 0.0; } ;
      { jQ_Odd [0] = 0.0; jQ_Odd [1] = 0.0; jQ_Odd [2] = 0.0; jQ_Even [0] = 0.0; jQ_Even [1] = 0.0; jQ_Even [2] = 0.0; jQ = 0.0; prev_jQ_Odd = 0.0; prev_jQ_Even = 0.0; prev_jQ_input_Odd = 0.0; prev_jQ_input_Even = 0.0; } ;
      period = 0.0;
      outIdx = 0;
      prevI2 = prevQ2 = 0.0;
      Re = Im = 0.0;
      I1ForOddPrev3 = I1ForEvenPrev3 = 0.0;
      I1ForOddPrev2 = I1ForEvenPrev2 = 0.0;
      smoothPeriod = 0.0;
      for( i=0; i < 50 ; i++ )
         smoothPrice[i] = 0.0;
      DCPhase = 0.0;
      while( today <= endIdx )
      {
         adjustedPrevPeriod = (0.075*period)+0.54;
         todayValue = inReal[today];
         { periodWMASub += todayValue; periodWMASub -= trailingWMAValue; periodWMASum += todayValue*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
         smoothPrice[smoothPrice_Idx] = smoothedValue;
         if( (today%2) == 0 )
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Even [hilbertIdx]; detrender_Even [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Even ; prev_detrender_Even = b * prev_detrender_input_Even ; detrender += prev_detrender_Even ; prev_detrender_input_Even = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Even [hilbertIdx]; Q1_Even [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Even ; prev_Q1_Even = b * prev_Q1_input_Even ; Q1 += prev_Q1_Even ; prev_Q1_input_Even = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForEvenPrev3; jI = -jI_Even [hilbertIdx]; jI_Even [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Even ; prev_jI_Even = b * prev_jI_input_Even ; jI += prev_jI_Even ; prev_jI_input_Even = I1ForEvenPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Even [hilbertIdx]; jQ_Even [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Even ; prev_jQ_Even = b * prev_jQ_input_Even ; jQ += prev_jQ_Even ; prev_jQ_input_Even = Q1; jQ *= adjustedPrevPeriod; } ;
            if( ++hilbertIdx == 3 )
               hilbertIdx = 0;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForEvenPrev3 - jQ)) + (0.8*prevI2);
            I1ForOddPrev3 = I1ForOddPrev2;
            I1ForOddPrev2 = detrender;
         }
         else
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Odd [hilbertIdx]; detrender_Odd [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Odd ; prev_detrender_Odd = b * prev_detrender_input_Odd ; detrender += prev_detrender_Odd ; prev_detrender_input_Odd = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Odd [hilbertIdx]; Q1_Odd [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Odd ; prev_Q1_Odd = b * prev_Q1_input_Odd ; Q1 += prev_Q1_Odd ; prev_Q1_input_Odd = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForOddPrev3; jI = -jI_Odd [hilbertIdx]; jI_Odd [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Odd ; prev_jI_Odd = b * prev_jI_input_Odd ; jI += prev_jI_Odd ; prev_jI_input_Odd = I1ForOddPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Odd [hilbertIdx]; jQ_Odd [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Odd ; prev_jQ_Odd = b * prev_jQ_input_Odd ; jQ += prev_jQ_Odd ; prev_jQ_input_Odd = Q1; jQ *= adjustedPrevPeriod; } ;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForOddPrev3 - jQ)) + (0.8*prevI2);
            I1ForEvenPrev3 = I1ForEvenPrev2;
            I1ForEvenPrev2 = detrender;
         }
         Re = (0.2*((I2*prevI2)+(Q2*prevQ2)))+(0.8*Re);
         Im = (0.2*((I2*prevQ2)-(Q2*prevI2)))+(0.8*Im);
         prevQ2 = Q2;
         prevI2 = I2;
         tempReal = period;
         if( (Im != 0.0) && (Re != 0.0) )
            period = 360.0 / ( Math.atan (Im/Re)*rad2Deg);
         tempReal2 = 1.5*tempReal;
         if( period > tempReal2)
            period = tempReal2;
         tempReal2 = 0.67*tempReal;
         if( period < tempReal2 )
            period = tempReal2;
         if( period < 6 )
            period = 6;
         else if( period > 50 )
            period = 50;
         period = (0.2*period) + (0.8 * tempReal);
         smoothPeriod = (0.33*period)+(0.67*smoothPeriod);
         DCPeriod = smoothPeriod+0.5;
         DCPeriodInt = (int)DCPeriod;
         realPart = 0.0;
         imagPart = 0.0;
         idx = smoothPrice_Idx;
         for( i=0; i < DCPeriodInt; i++ )
         {
            tempReal = ((double)i*constDeg2RadBy360)/(double)DCPeriodInt;
            tempReal2 = smoothPrice[idx];
            realPart += Math.sin (tempReal)*tempReal2;
            imagPart += Math.cos (tempReal)*tempReal2;
            if( idx == 0 )
               idx = 50 -1;
            else
               idx--;
         }
         tempReal = Math.abs (imagPart);
         if( tempReal > 0.0 )
            DCPhase = Math.atan (realPart/imagPart)*rad2Deg;
         else if( tempReal <= 0.01 )
         {
            if( realPart < 0.0 )
               DCPhase -= 90.0;
            else if( realPart > 0.0 )
               DCPhase += 90.0;
         }
         DCPhase += 90.0;
         DCPhase += 360.0 / smoothPeriod;
         if( imagPart < 0.0 )
            DCPhase += 180.0;
         if( DCPhase > 315.0 )
            DCPhase -= 360.0;
         if( today >= startIdx )
         {
            outReal[outIdx++] = DCPhase;
         }
         { smoothPrice_Idx ++; if( smoothPrice_Idx > maxIdx_smoothPrice ) smoothPrice_Idx = 0; } ;
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int htPhasorLookback( )
   {
      return 32 + (this.unstablePeriod[FuncUnstId.HtPhasor.ordinal()]) ;
   }
   public RetCode htPhasor( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outInPhase[],
      double outQuadrature[] )
   {
      int outIdx, i;
      int lookbackTotal, today;
      double tempReal, tempReal2;
      double adjustedPrevPeriod, period;
      int trailingWMAIdx;
      double periodWMASum, periodWMASub, trailingWMAValue;
      double smoothedValue;
      final double a = 0.0962;
      final double b = 0.5769;
      double hilbertTempReal;
      int hilbertIdx;
      double []detrender_Odd = new double[3] ; double []detrender_Even = new double[3] ; double detrender; double prev_detrender_Odd ; double prev_detrender_Even ; double prev_detrender_input_Odd ; double prev_detrender_input_Even ;
      double []Q1_Odd = new double[3] ; double []Q1_Even = new double[3] ; double Q1; double prev_Q1_Odd ; double prev_Q1_Even ; double prev_Q1_input_Odd ; double prev_Q1_input_Even ;
      double []jI_Odd = new double[3] ; double []jI_Even = new double[3] ; double jI; double prev_jI_Odd ; double prev_jI_Even ; double prev_jI_input_Odd ; double prev_jI_input_Even ;
      double []jQ_Odd = new double[3] ; double []jQ_Even = new double[3] ; double jQ; double prev_jQ_Odd ; double prev_jQ_Even ; double prev_jQ_input_Odd ; double prev_jQ_input_Even ;
      double Q2, I2, prevQ2, prevI2, Re, Im;
      double I1ForOddPrev2, I1ForOddPrev3;
      double I1ForEvenPrev2, I1ForEvenPrev3;
      double rad2Deg;
      double todayValue;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      rad2Deg = 180.0 / (4.0 * Math.atan (1));
      lookbackTotal = 32 + (this.unstablePeriod[FuncUnstId.HtPhasor.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingWMAIdx = startIdx - lookbackTotal;
      today = trailingWMAIdx;
      tempReal = inReal[today++];
      periodWMASub = tempReal;
      periodWMASum = tempReal;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*2.0;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*3.0;
      trailingWMAValue = 0.0;
      i = 9;
      do
      {
         tempReal = inReal[today++];
         { periodWMASub += tempReal; periodWMASub -= trailingWMAValue; periodWMASum += tempReal*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
      } while( --i != 0);
      hilbertIdx = 0;
      { detrender_Odd [0] = 0.0; detrender_Odd [1] = 0.0; detrender_Odd [2] = 0.0; detrender_Even [0] = 0.0; detrender_Even [1] = 0.0; detrender_Even [2] = 0.0; detrender = 0.0; prev_detrender_Odd = 0.0; prev_detrender_Even = 0.0; prev_detrender_input_Odd = 0.0; prev_detrender_input_Even = 0.0; } ;
      { Q1_Odd [0] = 0.0; Q1_Odd [1] = 0.0; Q1_Odd [2] = 0.0; Q1_Even [0] = 0.0; Q1_Even [1] = 0.0; Q1_Even [2] = 0.0; Q1 = 0.0; prev_Q1_Odd = 0.0; prev_Q1_Even = 0.0; prev_Q1_input_Odd = 0.0; prev_Q1_input_Even = 0.0; } ;
      { jI_Odd [0] = 0.0; jI_Odd [1] = 0.0; jI_Odd [2] = 0.0; jI_Even [0] = 0.0; jI_Even [1] = 0.0; jI_Even [2] = 0.0; jI = 0.0; prev_jI_Odd = 0.0; prev_jI_Even = 0.0; prev_jI_input_Odd = 0.0; prev_jI_input_Even = 0.0; } ;
      { jQ_Odd [0] = 0.0; jQ_Odd [1] = 0.0; jQ_Odd [2] = 0.0; jQ_Even [0] = 0.0; jQ_Even [1] = 0.0; jQ_Even [2] = 0.0; jQ = 0.0; prev_jQ_Odd = 0.0; prev_jQ_Even = 0.0; prev_jQ_input_Odd = 0.0; prev_jQ_input_Even = 0.0; } ;
      period = 0.0;
      outIdx = 0;
      prevI2 = prevQ2 = 0.0;
      Re = Im = 0.0;
      I1ForOddPrev3 = I1ForEvenPrev3 = 0.0;
      I1ForOddPrev2 = I1ForEvenPrev2 = 0.0;
      while( today <= endIdx )
      {
         adjustedPrevPeriod = (0.075*period)+0.54;
         todayValue = inReal[today];
         { periodWMASub += todayValue; periodWMASub -= trailingWMAValue; periodWMASum += todayValue*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
         if( (today%2) == 0 )
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Even [hilbertIdx]; detrender_Even [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Even ; prev_detrender_Even = b * prev_detrender_input_Even ; detrender += prev_detrender_Even ; prev_detrender_input_Even = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Even [hilbertIdx]; Q1_Even [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Even ; prev_Q1_Even = b * prev_Q1_input_Even ; Q1 += prev_Q1_Even ; prev_Q1_input_Even = detrender; Q1 *= adjustedPrevPeriod; } ;
            if( today >= startIdx )
            {
               outQuadrature[outIdx] = Q1;
               outInPhase[outIdx++] = I1ForEvenPrev3;
            }
            { hilbertTempReal = a * I1ForEvenPrev3; jI = -jI_Even [hilbertIdx]; jI_Even [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Even ; prev_jI_Even = b * prev_jI_input_Even ; jI += prev_jI_Even ; prev_jI_input_Even = I1ForEvenPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Even [hilbertIdx]; jQ_Even [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Even ; prev_jQ_Even = b * prev_jQ_input_Even ; jQ += prev_jQ_Even ; prev_jQ_input_Even = Q1; jQ *= adjustedPrevPeriod; } ;
            if( ++hilbertIdx == 3 )
               hilbertIdx = 0;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForEvenPrev3 - jQ)) + (0.8*prevI2);
            I1ForOddPrev3 = I1ForOddPrev2;
            I1ForOddPrev2 = detrender;
         }
         else
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Odd [hilbertIdx]; detrender_Odd [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Odd ; prev_detrender_Odd = b * prev_detrender_input_Odd ; detrender += prev_detrender_Odd ; prev_detrender_input_Odd = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Odd [hilbertIdx]; Q1_Odd [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Odd ; prev_Q1_Odd = b * prev_Q1_input_Odd ; Q1 += prev_Q1_Odd ; prev_Q1_input_Odd = detrender; Q1 *= adjustedPrevPeriod; } ;
            if( today >= startIdx )
            {
               outQuadrature[outIdx] = Q1;
               outInPhase[outIdx++] = I1ForOddPrev3;
            }
            { hilbertTempReal = a * I1ForOddPrev3; jI = -jI_Odd [hilbertIdx]; jI_Odd [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Odd ; prev_jI_Odd = b * prev_jI_input_Odd ; jI += prev_jI_Odd ; prev_jI_input_Odd = I1ForOddPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Odd [hilbertIdx]; jQ_Odd [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Odd ; prev_jQ_Odd = b * prev_jQ_input_Odd ; jQ += prev_jQ_Odd ; prev_jQ_input_Odd = Q1; jQ *= adjustedPrevPeriod; } ;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForOddPrev3 - jQ)) + (0.8*prevI2);
            I1ForEvenPrev3 = I1ForEvenPrev2;
            I1ForEvenPrev2 = detrender;
         }
         Re = (0.2*((I2*prevI2)+(Q2*prevQ2)))+(0.8*Re);
         Im = (0.2*((I2*prevQ2)-(Q2*prevI2)))+(0.8*Im);
         prevQ2 = Q2;
         prevI2 = I2;
         tempReal = period;
         if( (Im != 0.0) && (Re != 0.0) )
            period = 360.0 / ( Math.atan (Im/Re)*rad2Deg);
         tempReal2 = 1.5*tempReal;
         if( period > tempReal2)
            period = tempReal2;
         tempReal2 = 0.67*tempReal;
         if( period < tempReal2 )
            period = tempReal2;
         if( period < 6 )
            period = 6;
         else if( period > 50 )
            period = 50;
         period = (0.2*period) + (0.8 * tempReal);
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   struct TA_HT_PHASOR_HILBERT_STRUCT { double []_Odd = new double[3] ; double []_Even = new double[3] ; double var; double prev_Odd; double prev_Even; double prev_input_Odd; double prev_input_Even; };
   public RetCode htPhasorStateInit( struct TA_htPhasor_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct htPhasor ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = htPhasorLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_HT_PHASOR_Data));
      else
         _state.value .value .memory = NULL;
      { _state.value .value .detrender = calloc(1, sizeof(struct TA_HT_PHASOR_HILBERT_STRUCT )); if ( _state.value .value .detrender == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .Q1 = calloc(1, sizeof(struct TA_HT_PHASOR_HILBERT_STRUCT )); if ( _state.value .value .Q1 == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .jI = calloc(1, sizeof(struct TA_HT_PHASOR_HILBERT_STRUCT )); if ( _state.value .value .jI == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .jQ = calloc(1, sizeof(struct TA_HT_PHASOR_HILBERT_STRUCT )); if ( _state.value .value .jQ == NULL) return RetCode.AllocErr ; } ;
      return RetCode.Success ;
   }
   public RetCode htPhasorState( struct TA_htPhasor_State* _state,
      double inReal,
      double *outInPhase,
      double *outQuadrature )
   {
      double hilbertTempReal, smoothedValue;
      double adjustedPrevPeriod;
      double Q2, I2;
      double tempReal, tempReal2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .periodWMASub = 0.;
         _state.value .periodWMASum = 0.;
         _state.value .hilbertIdx = 0;
         _state.value .period = 0;
         _state.value .prevI2 = 0.;
         _state.value .prevQ2 = 0.;
         _state.value .I1ForOddPrev2 = 0;
         _state.value .I1ForEvenPrev2 = 0;
         _state.value .I1ForOddPrev3 = 0;
         _state.value .I1ForEvenPrev3 = 0;
         _state.value .Im = 0.;
         _state.value .Re = 0.;
         _state.value .trailingWMAValue = 0.;
         _state.value .rad2Deg = 180.0 / (4.0 * Math.atan (1));
         _state.value .a = 0.0962;
         _state.value .b = 0.5769;
         { struct TA_HT_PHASOR_HILBERT_STRUCT * ref; ref = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .detrender; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_HT_PHASOR_HILBERT_STRUCT * ref; ref = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .Q1; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_HT_PHASOR_HILBERT_STRUCT * ref; ref = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .jI; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_HT_PHASOR_HILBERT_STRUCT * ref; ref = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .jQ; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
      }
      if ( _state.value .mem_index < 4)
      {
         _state.value .periodWMASub += inReal;
         _state.value .periodWMASum += _state.value .mem_index*inReal;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      } else
         if ( _state.value .mem_index <= 12)
      {
         { _state.value .periodWMASub += inReal; _state.value .periodWMASub -= _state.value .trailingWMAValue; _state.value .periodWMASum += inReal*4.0; _state.value .trailingWMAValue = ( _state.value .memory+(( _state.value .mem_index-1+-3)% _state.value .mem_size ) ).value .inReal ; smoothedValue = _state.value .periodWMASum*0.1; _state.value .periodWMASum -= _state.value .periodWMASub; } ;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      }
      adjustedPrevPeriod = (0.075* _state.value .period)+0.54;
      { _state.value .periodWMASub += inReal; _state.value .periodWMASub -= _state.value .trailingWMAValue; _state.value .periodWMASum += inReal*4.0; _state.value .trailingWMAValue = ( _state.value .memory+(( _state.value .mem_index-1+-3)% _state.value .mem_size ) ).value .inReal ; smoothedValue = _state.value .periodWMASum*0.1; _state.value .periodWMASum -= _state.value .periodWMASub; } ;
      if( (( _state.value .mem_index+1)%2) == 0 )
      {
         { struct TA_HT_PHASOR_HILBERT_STRUCT * ref; ref = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .detrender; hilbertTempReal = _state.value .a * smoothedValue; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = smoothedValue; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_PHASOR_HILBERT_STRUCT * ref; ref = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .Q1; hilbertTempReal = _state.value .a * (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
         {
            outQuadrature.value = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .Q1.value .var ;
            outInPhase.value = _state.value .I1ForEvenPrev3;
         }
         { struct TA_HT_PHASOR_HILBERT_STRUCT * ref; ref = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .jI; hilbertTempReal = _state.value .a * _state.value .I1ForEvenPrev3; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = _state.value .I1ForEvenPrev3; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_PHASOR_HILBERT_STRUCT * ref; ref = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .jQ; hilbertTempReal = _state.value .a * (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         if( ++ _state.value .hilbertIdx == 3 )
            _state.value .hilbertIdx = 0;
         Q2 = (0.2*( (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .Q1.value .var + (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .jI.value .var )) + (0.8* _state.value .prevQ2);
         I2 = (0.2*( _state.value .I1ForEvenPrev3 - (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .jQ.value .var )) + (0.8* _state.value .prevI2);
         _state.value .I1ForOddPrev3 = _state.value .I1ForOddPrev2;
         _state.value .I1ForOddPrev2 = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .detrender.value .var ;
      } else {
         { struct TA_HT_PHASOR_HILBERT_STRUCT * ref; ref = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .detrender; hilbertTempReal = _state.value .a * smoothedValue; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = smoothedValue; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_PHASOR_HILBERT_STRUCT * ref; ref = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .Q1; hilbertTempReal = _state.value .a * (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
         {
            outQuadrature.value = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .Q1.value .var ;
            outInPhase.value = _state.value .I1ForOddPrev3;
         }
         { struct TA_HT_PHASOR_HILBERT_STRUCT * ref; ref = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .jI; hilbertTempReal = _state.value .a * _state.value .I1ForOddPrev3; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = _state.value .I1ForOddPrev3; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_PHASOR_HILBERT_STRUCT * ref; ref = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .jQ; hilbertTempReal = _state.value .a * (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         Q2 = (0.2*( (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .Q1.value .var + (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .jI.value .var )) + (0.8* _state.value .prevQ2);
         I2 = (0.2*( _state.value .I1ForOddPrev3 - (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .jQ.value .var )) + (0.8* _state.value .prevI2);
         _state.value .I1ForEvenPrev3 = _state.value .I1ForEvenPrev2;
         _state.value .I1ForEvenPrev2 = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .detrender.value .var ;
      }
      _state.value .Re = (0.2*((I2* _state.value .prevI2)+(Q2* _state.value .prevQ2)))+(0.8* _state.value .Re);
      _state.value .Im = (0.2*((I2* _state.value .prevQ2)-(Q2* _state.value .prevI2)))+(0.8* _state.value .Im);
      _state.value .prevQ2 = Q2;
      _state.value .prevI2 = I2;
      tempReal = _state.value .period;
      if( ( _state.value .Im != 0.0) && ( _state.value .Re != 0.0) )
         _state.value .period = 360.0 / ( Math.atan ( _state.value .Im/ _state.value .Re)* _state.value .rad2Deg);
      tempReal2 = 1.5*tempReal;
      if( _state.value .period > tempReal2)
         _state.value .period = tempReal2;
      tempReal2 = 0.67*tempReal;
      if( _state.value .period < tempReal2 )
         _state.value .period = tempReal2;
      if( _state.value .period < 6 )
         _state.value .period = 6;
      else if( _state.value .period > 50 )
         _state.value .period = 50;
      _state.value .period = (0.2* _state.value .period) + (0.8 * tempReal);
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      else {
         return RetCode.Success ;
      }
   }
   public RetCode htPhasorStateFree( struct TA_htPhasor_State** _state )
   {
      { if ( _state.value .value .detrender != NULL) { free ( _state.value .value .detrender); _state.value .value .detrender = NULL; } } ;
      { if ( _state.value .value .Q1 != NULL) { free ( _state.value .value .Q1); _state.value .value .Q1 = NULL; } } ;
      { if ( _state.value .value .jI != NULL) { free ( _state.value .value .jI); _state.value .value .jI = NULL; } } ;
      { if ( _state.value .value .jQ != NULL) { free ( _state.value .value .jQ); _state.value .value .jQ = NULL; } } ;
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode htPhasorStateSave( struct TA_htPhasor_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_HT_PHASOR_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .hilbertIdx,sizeof( _state.value .hilbertIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodWMASub,sizeof( _state.value .periodWMASub),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodWMASum,sizeof( _state.value .periodWMASum),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .period,sizeof( _state.value .period),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .I1ForOddPrev2,sizeof( _state.value .I1ForOddPrev2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .I1ForEvenPrev2,sizeof( _state.value .I1ForEvenPrev2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .I1ForOddPrev3,sizeof( _state.value .I1ForOddPrev3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .I1ForEvenPrev3,sizeof( _state.value .I1ForEvenPrev3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevI2,sizeof( _state.value .prevI2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevQ2,sizeof( _state.value .prevQ2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .Im,sizeof( _state.value .Im),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .Re,sizeof( _state.value .Re),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .trailingWMAValue,sizeof( _state.value .trailingWMAValue),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .rad2Deg,sizeof( _state.value .rad2Deg),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .a,sizeof( _state.value .a),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .b,sizeof( _state.value .b),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      { if ( _state.value .detrender == NULL) return RetCode.BadParam ; if (fwrite( _state.value .detrender,sizeof(struct TA_HT_PHASOR_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .Q1 == NULL) return RetCode.BadParam ; if (fwrite( _state.value .Q1,sizeof(struct TA_HT_PHASOR_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .jI == NULL) return RetCode.BadParam ; if (fwrite( _state.value .jI,sizeof(struct TA_HT_PHASOR_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .jQ == NULL) return RetCode.BadParam ; if (fwrite( _state.value .jQ,sizeof(struct TA_HT_PHASOR_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode htPhasorStateLoad( struct TA_htPhasor_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct htPhasor ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_HT_PHASOR_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_HT_PHASOR_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .hilbertIdx,sizeof( _state.value .value .hilbertIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodWMASub,sizeof( _state.value .value .periodWMASub),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodWMASum,sizeof( _state.value .value .periodWMASum),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .period,sizeof( _state.value .value .period),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .I1ForOddPrev2,sizeof( _state.value .value .I1ForOddPrev2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .I1ForEvenPrev2,sizeof( _state.value .value .I1ForEvenPrev2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .I1ForOddPrev3,sizeof( _state.value .value .I1ForOddPrev3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .I1ForEvenPrev3,sizeof( _state.value .value .I1ForEvenPrev3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevI2,sizeof( _state.value .value .prevI2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevQ2,sizeof( _state.value .value .prevQ2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .Im,sizeof( _state.value .value .Im),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .Re,sizeof( _state.value .value .Re),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .trailingWMAValue,sizeof( _state.value .value .trailingWMAValue),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .rad2Deg,sizeof( _state.value .value .rad2Deg),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .a,sizeof( _state.value .value .a),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .b,sizeof( _state.value .value .b),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      { if ( _state.value .value .detrender != NULL) return RetCode.BadParam ; { _state.value .value .detrender = calloc(1, sizeof(struct TA_HT_PHASOR_HILBERT_STRUCT )); if ( _state.value .value .detrender == NULL) return RetCode.AllocErr ; } if (fread( _state.value .value .detrender,sizeof(struct TA_HT_PHASOR_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .value .Q1 != NULL) return RetCode.BadParam ; { _state.value .value .Q1 = calloc(1, sizeof(struct TA_HT_PHASOR_HILBERT_STRUCT )); if ( _state.value .value .Q1 == NULL) return RetCode.AllocErr ; } if (fread( _state.value .value .Q1,sizeof(struct TA_HT_PHASOR_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .value .jI != NULL) return RetCode.BadParam ; { _state.value .value .jI = calloc(1, sizeof(struct TA_HT_PHASOR_HILBERT_STRUCT )); if ( _state.value .value .jI == NULL) return RetCode.AllocErr ; } if (fread( _state.value .value .jI,sizeof(struct TA_HT_PHASOR_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .value .jQ != NULL) return RetCode.BadParam ; { _state.value .value .jQ = calloc(1, sizeof(struct TA_HT_PHASOR_HILBERT_STRUCT )); if ( _state.value .value .jQ == NULL) return RetCode.AllocErr ; } if (fread( _state.value .value .jQ,sizeof(struct TA_HT_PHASOR_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode htPhasor( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outInPhase[],
      double outQuadrature[] )
   {
      int outIdx, i;
      int lookbackTotal, today;
      double tempReal, tempReal2;
      double adjustedPrevPeriod, period;
      int trailingWMAIdx;
      double periodWMASum, periodWMASub, trailingWMAValue;
      double smoothedValue;
      final double a = 0.0962;
      final double b = 0.5769;
      double hilbertTempReal;
      int hilbertIdx;
      double []detrender_Odd = new double[3] ; double []detrender_Even = new double[3] ; double detrender; double prev_detrender_Odd ; double prev_detrender_Even ; double prev_detrender_input_Odd ; double prev_detrender_input_Even ;
      double []Q1_Odd = new double[3] ; double []Q1_Even = new double[3] ; double Q1; double prev_Q1_Odd ; double prev_Q1_Even ; double prev_Q1_input_Odd ; double prev_Q1_input_Even ;
      double []jI_Odd = new double[3] ; double []jI_Even = new double[3] ; double jI; double prev_jI_Odd ; double prev_jI_Even ; double prev_jI_input_Odd ; double prev_jI_input_Even ;
      double []jQ_Odd = new double[3] ; double []jQ_Even = new double[3] ; double jQ; double prev_jQ_Odd ; double prev_jQ_Even ; double prev_jQ_input_Odd ; double prev_jQ_input_Even ;
      double Q2, I2, prevQ2, prevI2, Re, Im;
      double I1ForOddPrev2, I1ForOddPrev3;
      double I1ForEvenPrev2, I1ForEvenPrev3;
      double rad2Deg;
      double todayValue;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      rad2Deg = 180.0 / (4.0 * Math.atan (1));
      lookbackTotal = 32 + (this.unstablePeriod[FuncUnstId.HtPhasor.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingWMAIdx = startIdx - lookbackTotal;
      today = trailingWMAIdx;
      tempReal = inReal[today++];
      periodWMASub = tempReal;
      periodWMASum = tempReal;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*2.0;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*3.0;
      trailingWMAValue = 0.0;
      i = 9;
      do
      {
         tempReal = inReal[today++];
         { periodWMASub += tempReal; periodWMASub -= trailingWMAValue; periodWMASum += tempReal*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
      } while( --i != 0);
      hilbertIdx = 0;
      { detrender_Odd [0] = 0.0; detrender_Odd [1] = 0.0; detrender_Odd [2] = 0.0; detrender_Even [0] = 0.0; detrender_Even [1] = 0.0; detrender_Even [2] = 0.0; detrender = 0.0; prev_detrender_Odd = 0.0; prev_detrender_Even = 0.0; prev_detrender_input_Odd = 0.0; prev_detrender_input_Even = 0.0; } ;
      { Q1_Odd [0] = 0.0; Q1_Odd [1] = 0.0; Q1_Odd [2] = 0.0; Q1_Even [0] = 0.0; Q1_Even [1] = 0.0; Q1_Even [2] = 0.0; Q1 = 0.0; prev_Q1_Odd = 0.0; prev_Q1_Even = 0.0; prev_Q1_input_Odd = 0.0; prev_Q1_input_Even = 0.0; } ;
      { jI_Odd [0] = 0.0; jI_Odd [1] = 0.0; jI_Odd [2] = 0.0; jI_Even [0] = 0.0; jI_Even [1] = 0.0; jI_Even [2] = 0.0; jI = 0.0; prev_jI_Odd = 0.0; prev_jI_Even = 0.0; prev_jI_input_Odd = 0.0; prev_jI_input_Even = 0.0; } ;
      { jQ_Odd [0] = 0.0; jQ_Odd [1] = 0.0; jQ_Odd [2] = 0.0; jQ_Even [0] = 0.0; jQ_Even [1] = 0.0; jQ_Even [2] = 0.0; jQ = 0.0; prev_jQ_Odd = 0.0; prev_jQ_Even = 0.0; prev_jQ_input_Odd = 0.0; prev_jQ_input_Even = 0.0; } ;
      period = 0.0;
      outIdx = 0;
      prevI2 = prevQ2 = 0.0;
      Re = Im = 0.0;
      I1ForOddPrev3 = I1ForEvenPrev3 = 0.0;
      I1ForOddPrev2 = I1ForEvenPrev2 = 0.0;
      while( today <= endIdx )
      {
         adjustedPrevPeriod = (0.075*period)+0.54;
         todayValue = inReal[today];
         { periodWMASub += todayValue; periodWMASub -= trailingWMAValue; periodWMASum += todayValue*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
         if( (today%2) == 0 )
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Even [hilbertIdx]; detrender_Even [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Even ; prev_detrender_Even = b * prev_detrender_input_Even ; detrender += prev_detrender_Even ; prev_detrender_input_Even = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Even [hilbertIdx]; Q1_Even [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Even ; prev_Q1_Even = b * prev_Q1_input_Even ; Q1 += prev_Q1_Even ; prev_Q1_input_Even = detrender; Q1 *= adjustedPrevPeriod; } ;
            if( today >= startIdx )
            {
               outQuadrature[outIdx] = Q1;
               outInPhase[outIdx++] = I1ForEvenPrev3;
            }
            { hilbertTempReal = a * I1ForEvenPrev3; jI = -jI_Even [hilbertIdx]; jI_Even [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Even ; prev_jI_Even = b * prev_jI_input_Even ; jI += prev_jI_Even ; prev_jI_input_Even = I1ForEvenPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Even [hilbertIdx]; jQ_Even [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Even ; prev_jQ_Even = b * prev_jQ_input_Even ; jQ += prev_jQ_Even ; prev_jQ_input_Even = Q1; jQ *= adjustedPrevPeriod; } ;
            if( ++hilbertIdx == 3 )
               hilbertIdx = 0;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForEvenPrev3 - jQ)) + (0.8*prevI2);
            I1ForOddPrev3 = I1ForOddPrev2;
            I1ForOddPrev2 = detrender;
         }
         else
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Odd [hilbertIdx]; detrender_Odd [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Odd ; prev_detrender_Odd = b * prev_detrender_input_Odd ; detrender += prev_detrender_Odd ; prev_detrender_input_Odd = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Odd [hilbertIdx]; Q1_Odd [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Odd ; prev_Q1_Odd = b * prev_Q1_input_Odd ; Q1 += prev_Q1_Odd ; prev_Q1_input_Odd = detrender; Q1 *= adjustedPrevPeriod; } ;
            if( today >= startIdx )
            {
               outQuadrature[outIdx] = Q1;
               outInPhase[outIdx++] = I1ForOddPrev3;
            }
            { hilbertTempReal = a * I1ForOddPrev3; jI = -jI_Odd [hilbertIdx]; jI_Odd [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Odd ; prev_jI_Odd = b * prev_jI_input_Odd ; jI += prev_jI_Odd ; prev_jI_input_Odd = I1ForOddPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Odd [hilbertIdx]; jQ_Odd [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Odd ; prev_jQ_Odd = b * prev_jQ_input_Odd ; jQ += prev_jQ_Odd ; prev_jQ_input_Odd = Q1; jQ *= adjustedPrevPeriod; } ;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForOddPrev3 - jQ)) + (0.8*prevI2);
            I1ForEvenPrev3 = I1ForEvenPrev2;
            I1ForEvenPrev2 = detrender;
         }
         Re = (0.2*((I2*prevI2)+(Q2*prevQ2)))+(0.8*Re);
         Im = (0.2*((I2*prevQ2)-(Q2*prevI2)))+(0.8*Im);
         prevQ2 = Q2;
         prevI2 = I2;
         tempReal = period;
         if( (Im != 0.0) && (Re != 0.0) )
            period = 360.0 / ( Math.atan (Im/Re)*rad2Deg);
         tempReal2 = 1.5*tempReal;
         if( period > tempReal2)
            period = tempReal2;
         tempReal2 = 0.67*tempReal;
         if( period < tempReal2 )
            period = tempReal2;
         if( period < 6 )
            period = 6;
         else if( period > 50 )
            period = 50;
         period = (0.2*period) + (0.8 * tempReal);
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int htSineLookback( )
   {
      return 63 + (this.unstablePeriod[FuncUnstId.HtSine.ordinal()]) ;
   }
   public RetCode htSine( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outSine[],
      double outLeadSine[] )
   {
      int outIdx, i;
      int lookbackTotal, today;
      double tempReal, tempReal2;
      double adjustedPrevPeriod, period;
      int trailingWMAIdx;
      double periodWMASum, periodWMASub, trailingWMAValue;
      double smoothedValue;
      final double a = 0.0962;
      final double b = 0.5769;
      double hilbertTempReal;
      int hilbertIdx;
      double []detrender_Odd = new double[3] ; double []detrender_Even = new double[3] ; double detrender; double prev_detrender_Odd ; double prev_detrender_Even ; double prev_detrender_input_Odd ; double prev_detrender_input_Even ;
      double []Q1_Odd = new double[3] ; double []Q1_Even = new double[3] ; double Q1; double prev_Q1_Odd ; double prev_Q1_Even ; double prev_Q1_input_Odd ; double prev_Q1_input_Even ;
      double []jI_Odd = new double[3] ; double []jI_Even = new double[3] ; double jI; double prev_jI_Odd ; double prev_jI_Even ; double prev_jI_input_Odd ; double prev_jI_input_Even ;
      double []jQ_Odd = new double[3] ; double []jQ_Even = new double[3] ; double jQ; double prev_jQ_Odd ; double prev_jQ_Even ; double prev_jQ_input_Odd ; double prev_jQ_input_Even ;
      double Q2, I2, prevQ2, prevI2, Re, Im;
      double I1ForOddPrev2, I1ForOddPrev3;
      double I1ForEvenPrev2, I1ForEvenPrev3;
      double rad2Deg, deg2Rad, constDeg2RadBy360;
      double todayValue, smoothPeriod;
      int smoothPrice_Idx = 0; double []smoothPrice; int maxIdx_smoothPrice = ( 50 -1) ;
      int idx;
      int DCPeriodInt;
      double DCPhase, DCPeriod, imagPart, realPart;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      { smoothPrice = new double[maxIdx_smoothPrice +1]; } ;
      tempReal = Math.atan (1);
      rad2Deg = 45.0/tempReal;
      deg2Rad = 1.0/rad2Deg;
      constDeg2RadBy360 = tempReal*8.0;
      lookbackTotal = 63 + (this.unstablePeriod[FuncUnstId.HtSine.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingWMAIdx = startIdx - lookbackTotal;
      today = trailingWMAIdx;
      tempReal = inReal[today++];
      periodWMASub = tempReal;
      periodWMASum = tempReal;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*2.0;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*3.0;
      trailingWMAValue = 0.0;
      i = 34;
      do
      {
         tempReal = inReal[today++];
         { periodWMASub += tempReal; periodWMASub -= trailingWMAValue; periodWMASum += tempReal*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
      } while( --i != 0);
      hilbertIdx = 0;
      { detrender_Odd [0] = 0.0; detrender_Odd [1] = 0.0; detrender_Odd [2] = 0.0; detrender_Even [0] = 0.0; detrender_Even [1] = 0.0; detrender_Even [2] = 0.0; detrender = 0.0; prev_detrender_Odd = 0.0; prev_detrender_Even = 0.0; prev_detrender_input_Odd = 0.0; prev_detrender_input_Even = 0.0; } ;
      { Q1_Odd [0] = 0.0; Q1_Odd [1] = 0.0; Q1_Odd [2] = 0.0; Q1_Even [0] = 0.0; Q1_Even [1] = 0.0; Q1_Even [2] = 0.0; Q1 = 0.0; prev_Q1_Odd = 0.0; prev_Q1_Even = 0.0; prev_Q1_input_Odd = 0.0; prev_Q1_input_Even = 0.0; } ;
      { jI_Odd [0] = 0.0; jI_Odd [1] = 0.0; jI_Odd [2] = 0.0; jI_Even [0] = 0.0; jI_Even [1] = 0.0; jI_Even [2] = 0.0; jI = 0.0; prev_jI_Odd = 0.0; prev_jI_Even = 0.0; prev_jI_input_Odd = 0.0; prev_jI_input_Even = 0.0; } ;
      { jQ_Odd [0] = 0.0; jQ_Odd [1] = 0.0; jQ_Odd [2] = 0.0; jQ_Even [0] = 0.0; jQ_Even [1] = 0.0; jQ_Even [2] = 0.0; jQ = 0.0; prev_jQ_Odd = 0.0; prev_jQ_Even = 0.0; prev_jQ_input_Odd = 0.0; prev_jQ_input_Even = 0.0; } ;
      period = 0.0;
      outIdx = 0;
      prevI2 = prevQ2 = 0.0;
      Re = Im = 0.0;
      I1ForOddPrev3 = I1ForEvenPrev3 = 0.0;
      I1ForOddPrev2 = I1ForEvenPrev2 = 0.0;
      smoothPeriod = 0.0;
      for( i=0; i < 50 ; i++ )
         smoothPrice[i] = 0.0;
      DCPhase = 0.0;
      while( today <= endIdx )
      {
         adjustedPrevPeriod = (0.075*period)+0.54;
         todayValue = inReal[today];
         { periodWMASub += todayValue; periodWMASub -= trailingWMAValue; periodWMASum += todayValue*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
         smoothPrice[smoothPrice_Idx] = smoothedValue;
         if( (today%2) == 0 )
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Even [hilbertIdx]; detrender_Even [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Even ; prev_detrender_Even = b * prev_detrender_input_Even ; detrender += prev_detrender_Even ; prev_detrender_input_Even = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Even [hilbertIdx]; Q1_Even [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Even ; prev_Q1_Even = b * prev_Q1_input_Even ; Q1 += prev_Q1_Even ; prev_Q1_input_Even = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForEvenPrev3; jI = -jI_Even [hilbertIdx]; jI_Even [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Even ; prev_jI_Even = b * prev_jI_input_Even ; jI += prev_jI_Even ; prev_jI_input_Even = I1ForEvenPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Even [hilbertIdx]; jQ_Even [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Even ; prev_jQ_Even = b * prev_jQ_input_Even ; jQ += prev_jQ_Even ; prev_jQ_input_Even = Q1; jQ *= adjustedPrevPeriod; } ;
            if( ++hilbertIdx == 3 )
               hilbertIdx = 0;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForEvenPrev3 - jQ)) + (0.8*prevI2);
            I1ForOddPrev3 = I1ForOddPrev2;
            I1ForOddPrev2 = detrender;
         }
         else
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Odd [hilbertIdx]; detrender_Odd [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Odd ; prev_detrender_Odd = b * prev_detrender_input_Odd ; detrender += prev_detrender_Odd ; prev_detrender_input_Odd = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Odd [hilbertIdx]; Q1_Odd [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Odd ; prev_Q1_Odd = b * prev_Q1_input_Odd ; Q1 += prev_Q1_Odd ; prev_Q1_input_Odd = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForOddPrev3; jI = -jI_Odd [hilbertIdx]; jI_Odd [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Odd ; prev_jI_Odd = b * prev_jI_input_Odd ; jI += prev_jI_Odd ; prev_jI_input_Odd = I1ForOddPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Odd [hilbertIdx]; jQ_Odd [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Odd ; prev_jQ_Odd = b * prev_jQ_input_Odd ; jQ += prev_jQ_Odd ; prev_jQ_input_Odd = Q1; jQ *= adjustedPrevPeriod; } ;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForOddPrev3 - jQ)) + (0.8*prevI2);
            I1ForEvenPrev3 = I1ForEvenPrev2;
            I1ForEvenPrev2 = detrender;
         }
         Re = (0.2*((I2*prevI2)+(Q2*prevQ2)))+(0.8*Re);
         Im = (0.2*((I2*prevQ2)-(Q2*prevI2)))+(0.8*Im);
         prevQ2 = Q2;
         prevI2 = I2;
         tempReal = period;
         if( (Im != 0.0) && (Re != 0.0) )
            period = 360.0 / ( Math.atan (Im/Re)*rad2Deg);
         tempReal2 = 1.5*tempReal;
         if( period > tempReal2)
            period = tempReal2;
         tempReal2 = 0.67*tempReal;
         if( period < tempReal2 )
            period = tempReal2;
         if( period < 6 )
            period = 6;
         else if( period > 50 )
            period = 50;
         period = (0.2*period) + (0.8 * tempReal);
         smoothPeriod = (0.33*period)+(0.67*smoothPeriod);
         DCPeriod = smoothPeriod+0.5;
         DCPeriodInt = (int)DCPeriod;
         realPart = 0.0;
         imagPart = 0.0;
         idx = smoothPrice_Idx;
         for( i=0; i < DCPeriodInt; i++ )
         {
            tempReal = ((double)i*constDeg2RadBy360)/(double)DCPeriodInt;
            tempReal2 = smoothPrice[idx];
            realPart += Math.sin (tempReal)*tempReal2;
            imagPart += Math.cos (tempReal)*tempReal2;
            if( idx == 0 )
               idx = 50 -1;
            else
               idx--;
         }
         tempReal = Math.abs (imagPart);
         if( tempReal > 0.0 )
            DCPhase = Math.atan (realPart/imagPart)*rad2Deg;
         else if( tempReal <= 0.01 )
         {
            if( realPart < 0.0 )
               DCPhase -= 90.0;
            else if( realPart > 0.0 )
               DCPhase += 90.0;
         }
         DCPhase += 90.0;
         DCPhase += 360.0 / smoothPeriod;
         if( imagPart < 0.0 )
            DCPhase += 180.0;
         if( DCPhase > 315.0 )
            DCPhase -= 360.0;
         if( today >= startIdx )
         {
            outSine[outIdx] = Math.sin (DCPhase*deg2Rad);
            outLeadSine[outIdx++] = Math.sin ((DCPhase+45)*deg2Rad);
         }
         { smoothPrice_Idx ++; if( smoothPrice_Idx > maxIdx_smoothPrice ) smoothPrice_Idx = 0; } ;
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   struct TA_HT_SINE_STATE_CIRCBUF { int idx; double* circbuf; int size; };
   struct TA_HT_SINE_HILBERT_STRUCT { double []_Odd = new double[3] ; double []_Even = new double[3] ; double var; double prev_Odd; double prev_Even; double prev_input_Odd; double prev_input_Even; };
   public RetCode htSineStateInit( struct TA_htSine_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct htSine ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = htSineLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_HT_SINE_Data));
      else
         _state.value .value .memory = NULL;
      { _state.value .value .circBuf = calloc(1, sizeof(struct TA_HT_SINE_STATE_CIRCBUF )); if ( _state.value .value .circBuf == NULL) return RetCode.AllocErr ; struct TA_HT_SINE_STATE_CIRCBUF * buf = (struct TA_HT_SINE_STATE_CIRCBUF *) _state.value .value .circBuf; buf->idx = 0; buf->size = 50; buf->circbuf = calloc(50, sizeof(double)); if (!buf->circbuf) return RetCode.AllocErr ;} ;
      { _state.value .value .detrender = calloc(1, sizeof(struct TA_HT_SINE_HILBERT_STRUCT )); if ( _state.value .value .detrender == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .Q1 = calloc(1, sizeof(struct TA_HT_SINE_HILBERT_STRUCT )); if ( _state.value .value .Q1 == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .jI = calloc(1, sizeof(struct TA_HT_SINE_HILBERT_STRUCT )); if ( _state.value .value .jI == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .jQ = calloc(1, sizeof(struct TA_HT_SINE_HILBERT_STRUCT )); if ( _state.value .value .jQ == NULL) return RetCode.AllocErr ; } ;
      return RetCode.Success ;
   }
   public RetCode htSineState( struct TA_htSine_State* _state,
      double inReal,
      double *outSine,
      double *outLeadSine )
   {
      double hilbertTempReal, smoothedValue;
      double adjustedPrevPeriod;
      double Q2, I2;
      double tempReal, tempReal2;
      int DCPeriodInt;
      double DCPeriod, imagPart, realPart;
      int idx, i;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .periodWMASub = 0.;
         _state.value .periodWMASum = 0.;
         _state.value .hilbertIdx = 0;
         _state.value .period = 0;
         _state.value .prevI2 = 0.;
         _state.value .prevQ2 = 0.;
         _state.value .I1ForOddPrev2 = 0;
         _state.value .I1ForEvenPrev2 = 0;
         _state.value .I1ForOddPrev3 = 0;
         _state.value .I1ForEvenPrev3 = 0;
         _state.value .smoothPeriod = 0;
         _state.value .Im = 0.;
         _state.value .Re = 0.;
         _state.value .trailingWMAValue = 0.;
         _state.value .rad2Deg = 180.0 / (4.0 * Math.atan (1));
         _state.value .deg2Rad = 1.0/ _state.value .rad2Deg;
         _state.value .constDeg2RadBy360 = Math.atan (1)*8.0;
         _state.value .DCPhase = 0;
         _state.value .a = 0.0962;
         _state.value .b = 0.5769;
         { struct TA_HT_SINE_HILBERT_STRUCT * ref; ref = (struct TA_HT_SINE_HILBERT_STRUCT *) _state.value .detrender; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_HT_SINE_HILBERT_STRUCT * ref; ref = (struct TA_HT_SINE_HILBERT_STRUCT *) _state.value .Q1; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_HT_SINE_HILBERT_STRUCT * ref; ref = (struct TA_HT_SINE_HILBERT_STRUCT *) _state.value .jI; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_HT_SINE_HILBERT_STRUCT * ref; ref = (struct TA_HT_SINE_HILBERT_STRUCT *) _state.value .jQ; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
      }
      if ( _state.value .mem_index < 4)
      {
         _state.value .periodWMASub += inReal;
         _state.value .periodWMASum += _state.value .mem_index*inReal;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      } else
         if ( _state.value .mem_index <= 37)
      {
         { _state.value .periodWMASub += inReal; _state.value .periodWMASub -= _state.value .trailingWMAValue; _state.value .periodWMASum += inReal*4.0; _state.value .trailingWMAValue = ( _state.value .memory+(( _state.value .mem_index-1+-3)% _state.value .mem_size ) ).value .inReal ; smoothedValue = _state.value .periodWMASum*0.1; _state.value .periodWMASum -= _state.value .periodWMASub; } ;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      }
      adjustedPrevPeriod = (0.075* _state.value .period)+0.54;
      { _state.value .periodWMASub += inReal; _state.value .periodWMASub -= _state.value .trailingWMAValue; _state.value .periodWMASum += inReal*4.0; _state.value .trailingWMAValue = ( _state.value .memory+(( _state.value .mem_index-1+-3)% _state.value .mem_size ) ).value .inReal ; smoothedValue = _state.value .periodWMASum*0.1; _state.value .periodWMASum -= _state.value .periodWMASub; } ;
      (*( ((struct TA_HT_SINE_STATE_CIRCBUF *) _state.value .circBuf)->circbuf + ((struct TA_HT_SINE_STATE_CIRCBUF *) _state.value .circBuf)->idx )) = smoothedValue;
      if( (( _state.value .mem_index+1)%2) == 0 )
      {
         { struct TA_HT_SINE_HILBERT_STRUCT * ref; ref = (struct TA_HT_SINE_HILBERT_STRUCT *) _state.value .detrender; hilbertTempReal = _state.value .a * smoothedValue; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = smoothedValue; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_SINE_HILBERT_STRUCT * ref; ref = (struct TA_HT_SINE_HILBERT_STRUCT *) _state.value .Q1; hilbertTempReal = _state.value .a * (struct TA_HT_SINE_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = (struct TA_HT_SINE_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_SINE_HILBERT_STRUCT * ref; ref = (struct TA_HT_SINE_HILBERT_STRUCT *) _state.value .jI; hilbertTempReal = _state.value .a * _state.value .I1ForEvenPrev3; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = _state.value .I1ForEvenPrev3; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_SINE_HILBERT_STRUCT * ref; ref = (struct TA_HT_SINE_HILBERT_STRUCT *) _state.value .jQ; hilbertTempReal = _state.value .a * (struct TA_HT_SINE_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = (struct TA_HT_SINE_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         if( ++ _state.value .hilbertIdx == 3 )
            _state.value .hilbertIdx = 0;
         Q2 = (0.2*( (struct TA_HT_SINE_HILBERT_STRUCT *) _state.value .Q1.value .var + (struct TA_HT_SINE_HILBERT_STRUCT *) _state.value .jI.value .var )) + (0.8* _state.value .prevQ2);
         I2 = (0.2*( _state.value .I1ForEvenPrev3 - (struct TA_HT_SINE_HILBERT_STRUCT *) _state.value .jQ.value .var )) + (0.8* _state.value .prevI2);
         _state.value .I1ForOddPrev3 = _state.value .I1ForOddPrev2;
         _state.value .I1ForOddPrev2 = (struct TA_HT_SINE_HILBERT_STRUCT *) _state.value .detrender.value .var ;
      } else {
         { struct TA_HT_SINE_HILBERT_STRUCT * ref; ref = (struct TA_HT_SINE_HILBERT_STRUCT *) _state.value .detrender; hilbertTempReal = _state.value .a * smoothedValue; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = smoothedValue; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_SINE_HILBERT_STRUCT * ref; ref = (struct TA_HT_SINE_HILBERT_STRUCT *) _state.value .Q1; hilbertTempReal = _state.value .a * (struct TA_HT_SINE_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = (struct TA_HT_SINE_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_SINE_HILBERT_STRUCT * ref; ref = (struct TA_HT_SINE_HILBERT_STRUCT *) _state.value .jI; hilbertTempReal = _state.value .a * _state.value .I1ForOddPrev3; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = _state.value .I1ForOddPrev3; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_SINE_HILBERT_STRUCT * ref; ref = (struct TA_HT_SINE_HILBERT_STRUCT *) _state.value .jQ; hilbertTempReal = _state.value .a * (struct TA_HT_SINE_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = (struct TA_HT_SINE_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         Q2 = (0.2*( (struct TA_HT_SINE_HILBERT_STRUCT *) _state.value .Q1.value .var + (struct TA_HT_SINE_HILBERT_STRUCT *) _state.value .jI.value .var )) + (0.8* _state.value .prevQ2);
         I2 = (0.2*( _state.value .I1ForOddPrev3 - (struct TA_HT_SINE_HILBERT_STRUCT *) _state.value .jQ.value .var )) + (0.8* _state.value .prevI2);
         _state.value .I1ForEvenPrev3 = _state.value .I1ForEvenPrev2;
         _state.value .I1ForEvenPrev2 = (struct TA_HT_SINE_HILBERT_STRUCT *) _state.value .detrender.value .var ;
      }
      _state.value .Re = (0.2*((I2* _state.value .prevI2)+(Q2* _state.value .prevQ2)))+(0.8* _state.value .Re);
      _state.value .Im = (0.2*((I2* _state.value .prevQ2)-(Q2* _state.value .prevI2)))+(0.8* _state.value .Im);
      _state.value .prevQ2 = Q2;
      _state.value .prevI2 = I2;
      tempReal = _state.value .period;
      if( ( _state.value .Im != 0.0) && ( _state.value .Re != 0.0) )
         _state.value .period = 360.0 / ( Math.atan ( _state.value .Im/ _state.value .Re)* _state.value .rad2Deg);
      tempReal2 = 1.5*tempReal;
      if( _state.value .period > tempReal2)
         _state.value .period = tempReal2;
      tempReal2 = 0.67*tempReal;
      if( _state.value .period < tempReal2 )
         _state.value .period = tempReal2;
      if( _state.value .period < 6 )
         _state.value .period = 6;
      else if( _state.value .period > 50 )
         _state.value .period = 50;
      _state.value .period = (0.2* _state.value .period) + (0.8 * tempReal);
      _state.value .smoothPeriod = (0.33* _state.value .period)+(0.67* _state.value .smoothPeriod);
      DCPeriod = _state.value .smoothPeriod+0.5;
      DCPeriodInt = (int)DCPeriod;
      realPart = 0.0;
      imagPart = 0.0;
      idx = ((struct TA_HT_SINE_STATE_CIRCBUF *) _state.value .circBuf)->idx ;
      for( i=0; i < DCPeriodInt; i++ )
      {
         tempReal = ((double)i* _state.value .constDeg2RadBy360)/(double)DCPeriodInt;
         tempReal2 = (*( ((struct TA_HT_SINE_STATE_CIRCBUF *) _state.value .circBuf)->circbuf +idx)) ;
         realPart += Math.sin (tempReal)*tempReal2;
         imagPart += Math.cos (tempReal)*tempReal2;
         if( idx == 0 )
            idx = ((struct TA_HT_SINE_STATE_CIRCBUF *) _state.value .circBuf)->size -1;
         else
            idx--;
      }
      tempReal = Math.abs (imagPart);
      if( tempReal > 0.0 )
         _state.value .DCPhase = Math.atan (realPart/imagPart)* _state.value .rad2Deg;
      else if( tempReal <= 0.01 )
      {
         if( realPart < 0.0 )
            _state.value .DCPhase -= 90.0;
         else if( realPart > 0.0 )
            _state.value .DCPhase += 90.0;
      }
      _state.value .DCPhase += 90.0;
      _state.value .DCPhase += 360.0 / _state.value .smoothPeriod;
      if( imagPart < 0.0 )
         _state.value .DCPhase += 180.0;
      if( _state.value .DCPhase > 315.0 )
         _state.value .DCPhase -= 360.0;
      { struct TA_HT_SINE_STATE_CIRCBUF * buf = (struct TA_HT_SINE_STATE_CIRCBUF *) _state.value .circBuf; if(buf->idx < buf->size-1) buf->idx++; else buf->idx = 0;} ;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      else {
         outSine.value = Math.sin ( _state.value .DCPhase* _state.value .deg2Rad);
         outLeadSine.value = Math.sin (( _state.value .DCPhase+45)* _state.value .deg2Rad);
         return RetCode.Success ;
      }
      return RetCode.Success ;
   }
   public RetCode htSineStateFree( struct TA_htSine_State** _state )
   {
      { if ( _state.value .value .detrender != NULL) { free ( _state.value .value .detrender); _state.value .value .detrender = NULL; } } ;
      { if ( _state.value .value .Q1 != NULL) { free ( _state.value .value .Q1); _state.value .value .Q1 = NULL; } } ;
      { if ( _state.value .value .jI != NULL) { free ( _state.value .value .jI); _state.value .value .jI = NULL; } } ;
      { if ( _state.value .value .jQ != NULL) { free ( _state.value .value .jQ); _state.value .value .jQ = NULL; } } ;
      { struct TA_HT_SINE_STATE_CIRCBUF * buf = (struct TA_HT_SINE_STATE_CIRCBUF *) _state.value .value .circBuf; if (buf != NULL) { if (buf->circbuf != NULL) free(buf->circbuf); free (buf); _state.value .value .circBuf = NULL; } } ;
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode htSineStateSave( struct TA_htSine_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_HT_SINE_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .hilbertIdx,sizeof( _state.value .hilbertIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodWMASub,sizeof( _state.value .periodWMASub),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodWMASum,sizeof( _state.value .periodWMASum),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .period,sizeof( _state.value .period),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .I1ForOddPrev2,sizeof( _state.value .I1ForOddPrev2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .I1ForEvenPrev2,sizeof( _state.value .I1ForEvenPrev2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .I1ForOddPrev3,sizeof( _state.value .I1ForOddPrev3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .I1ForEvenPrev3,sizeof( _state.value .I1ForEvenPrev3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevI2,sizeof( _state.value .prevI2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevQ2,sizeof( _state.value .prevQ2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .smoothPeriod,sizeof( _state.value .smoothPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .DCPhase,sizeof( _state.value .DCPhase),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .Im,sizeof( _state.value .Im),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .Re,sizeof( _state.value .Re),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .trailingWMAValue,sizeof( _state.value .trailingWMAValue),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .rad2Deg,sizeof( _state.value .rad2Deg),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .a,sizeof( _state.value .a),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .b,sizeof( _state.value .b),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .constDeg2RadBy360,sizeof( _state.value .constDeg2RadBy360),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .deg2Rad,sizeof( _state.value .deg2Rad),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      { if ( _state.value .detrender == NULL) return RetCode.BadParam ; if (fwrite( _state.value .detrender,sizeof(struct TA_HT_SINE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .Q1 == NULL) return RetCode.BadParam ; if (fwrite( _state.value .Q1,sizeof(struct TA_HT_SINE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .jI == NULL) return RetCode.BadParam ; if (fwrite( _state.value .jI,sizeof(struct TA_HT_SINE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .jQ == NULL) return RetCode.BadParam ; if (fwrite( _state.value .jQ,sizeof(struct TA_HT_SINE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { int io_circbuf_res; struct TA_HT_SINE_STATE_CIRCBUF * str_circbuf = _state.value .circBuf; io_circbuf_res = fwrite(&str_circbuf->idx,sizeof(str_circbuf->idx),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; io_circbuf_res = fwrite(&str_circbuf->size,sizeof(str_circbuf->size),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; if (str_circbuf->size > 0) { io_circbuf_res = fwrite(str_circbuf->circbuf,sizeof(str_circbuf->circbuf),str_circbuf->size,_file); if (io_circbuf_res < str_circbuf->size) return RetCode.IOFailed ; } }
      return 0;
   }
   public RetCode htSineStateLoad( struct TA_htSine_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct htSine ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_HT_SINE_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_HT_SINE_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .hilbertIdx,sizeof( _state.value .value .hilbertIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodWMASub,sizeof( _state.value .value .periodWMASub),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodWMASum,sizeof( _state.value .value .periodWMASum),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .period,sizeof( _state.value .value .period),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .I1ForOddPrev2,sizeof( _state.value .value .I1ForOddPrev2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .I1ForEvenPrev2,sizeof( _state.value .value .I1ForEvenPrev2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .I1ForOddPrev3,sizeof( _state.value .value .I1ForOddPrev3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .I1ForEvenPrev3,sizeof( _state.value .value .I1ForEvenPrev3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevI2,sizeof( _state.value .value .prevI2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevQ2,sizeof( _state.value .value .prevQ2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .smoothPeriod,sizeof( _state.value .value .smoothPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .DCPhase,sizeof( _state.value .value .DCPhase),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .Im,sizeof( _state.value .value .Im),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .Re,sizeof( _state.value .value .Re),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .trailingWMAValue,sizeof( _state.value .value .trailingWMAValue),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .rad2Deg,sizeof( _state.value .value .rad2Deg),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .a,sizeof( _state.value .value .a),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .b,sizeof( _state.value .value .b),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .constDeg2RadBy360,sizeof( _state.value .value .constDeg2RadBy360),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .deg2Rad,sizeof( _state.value .value .deg2Rad),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      { if ( _state.value .value .detrender != NULL) return RetCode.BadParam ; { _state.value .value .detrender = calloc(1, sizeof(struct TA_HT_SINE_HILBERT_STRUCT )); if ( _state.value .value .detrender == NULL) return RetCode.AllocErr ; } if (fread( _state.value .value .detrender,sizeof(struct TA_HT_SINE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .value .Q1 != NULL) return RetCode.BadParam ; { _state.value .value .Q1 = calloc(1, sizeof(struct TA_HT_SINE_HILBERT_STRUCT )); if ( _state.value .value .Q1 == NULL) return RetCode.AllocErr ; } if (fread( _state.value .value .Q1,sizeof(struct TA_HT_SINE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .value .jI != NULL) return RetCode.BadParam ; { _state.value .value .jI = calloc(1, sizeof(struct TA_HT_SINE_HILBERT_STRUCT )); if ( _state.value .value .jI == NULL) return RetCode.AllocErr ; } if (fread( _state.value .value .jI,sizeof(struct TA_HT_SINE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .value .jQ != NULL) return RetCode.BadParam ; { _state.value .value .jQ = calloc(1, sizeof(struct TA_HT_SINE_HILBERT_STRUCT )); if ( _state.value .value .jQ == NULL) return RetCode.AllocErr ; } if (fread( _state.value .value .jQ,sizeof(struct TA_HT_SINE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { int io_circbuf_res; int circbuf_idx; int circbuf_size; if ( _state.value .value .circBuf != NULL) return RetCode.BadParam ; io_circbuf_res = fread(&circbuf_idx,sizeof(circbuf_idx),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; io_circbuf_res = fread(&circbuf_size,sizeof(circbuf_size),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; { _state.value .value .circBuf = calloc(1, sizeof(struct TA_HT_SINE_STATE_CIRCBUF )); if ( _state.value .value .circBuf == NULL) return RetCode.AllocErr ; struct TA_HT_SINE_STATE_CIRCBUF * buf = (struct TA_HT_SINE_STATE_CIRCBUF *) _state.value .value .circBuf; buf->idx = 0; buf->size = circbuf_size; buf->circbuf = calloc(circbuf_size, sizeof(double)); if (!buf->circbuf) return RetCode.AllocErr ;} struct TA_HT_SINE_STATE_CIRCBUF * str_circbuf = _state.value .value .circBuf; str_circbuf->idx = circbuf_idx; if (str_circbuf->size > 0) { io_circbuf_res = fread(str_circbuf->circbuf,sizeof(str_circbuf->circbuf),str_circbuf->size,_file); if (io_circbuf_res < str_circbuf->size) return RetCode.IOFailed ; } }
      return 0;
   }
   public RetCode htSine( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outSine[],
      double outLeadSine[] )
   {
      int outIdx, i;
      int lookbackTotal, today;
      double tempReal, tempReal2;
      double adjustedPrevPeriod, period;
      int trailingWMAIdx;
      double periodWMASum, periodWMASub, trailingWMAValue;
      double smoothedValue;
      final double a = 0.0962;
      final double b = 0.5769;
      double hilbertTempReal;
      int hilbertIdx;
      double []detrender_Odd = new double[3] ; double []detrender_Even = new double[3] ; double detrender; double prev_detrender_Odd ; double prev_detrender_Even ; double prev_detrender_input_Odd ; double prev_detrender_input_Even ;
      double []Q1_Odd = new double[3] ; double []Q1_Even = new double[3] ; double Q1; double prev_Q1_Odd ; double prev_Q1_Even ; double prev_Q1_input_Odd ; double prev_Q1_input_Even ;
      double []jI_Odd = new double[3] ; double []jI_Even = new double[3] ; double jI; double prev_jI_Odd ; double prev_jI_Even ; double prev_jI_input_Odd ; double prev_jI_input_Even ;
      double []jQ_Odd = new double[3] ; double []jQ_Even = new double[3] ; double jQ; double prev_jQ_Odd ; double prev_jQ_Even ; double prev_jQ_input_Odd ; double prev_jQ_input_Even ;
      double Q2, I2, prevQ2, prevI2, Re, Im;
      double I1ForOddPrev2, I1ForOddPrev3;
      double I1ForEvenPrev2, I1ForEvenPrev3;
      double rad2Deg, deg2Rad, constDeg2RadBy360;
      double todayValue, smoothPeriod;
      int smoothPrice_Idx = 0; double []smoothPrice; int maxIdx_smoothPrice = ( 50 -1) ;
      int idx;
      int DCPeriodInt;
      double DCPhase, DCPeriod, imagPart, realPart;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      { smoothPrice = new double[maxIdx_smoothPrice +1]; } ;
      tempReal = Math.atan (1);
      rad2Deg = 45.0/tempReal;
      deg2Rad = 1.0/rad2Deg;
      constDeg2RadBy360 = tempReal*8.0;
      lookbackTotal = 63 + (this.unstablePeriod[FuncUnstId.HtSine.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingWMAIdx = startIdx - lookbackTotal;
      today = trailingWMAIdx;
      tempReal = inReal[today++];
      periodWMASub = tempReal;
      periodWMASum = tempReal;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*2.0;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*3.0;
      trailingWMAValue = 0.0;
      i = 34;
      do
      {
         tempReal = inReal[today++];
         { periodWMASub += tempReal; periodWMASub -= trailingWMAValue; periodWMASum += tempReal*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
      } while( --i != 0);
      hilbertIdx = 0;
      { detrender_Odd [0] = 0.0; detrender_Odd [1] = 0.0; detrender_Odd [2] = 0.0; detrender_Even [0] = 0.0; detrender_Even [1] = 0.0; detrender_Even [2] = 0.0; detrender = 0.0; prev_detrender_Odd = 0.0; prev_detrender_Even = 0.0; prev_detrender_input_Odd = 0.0; prev_detrender_input_Even = 0.0; } ;
      { Q1_Odd [0] = 0.0; Q1_Odd [1] = 0.0; Q1_Odd [2] = 0.0; Q1_Even [0] = 0.0; Q1_Even [1] = 0.0; Q1_Even [2] = 0.0; Q1 = 0.0; prev_Q1_Odd = 0.0; prev_Q1_Even = 0.0; prev_Q1_input_Odd = 0.0; prev_Q1_input_Even = 0.0; } ;
      { jI_Odd [0] = 0.0; jI_Odd [1] = 0.0; jI_Odd [2] = 0.0; jI_Even [0] = 0.0; jI_Even [1] = 0.0; jI_Even [2] = 0.0; jI = 0.0; prev_jI_Odd = 0.0; prev_jI_Even = 0.0; prev_jI_input_Odd = 0.0; prev_jI_input_Even = 0.0; } ;
      { jQ_Odd [0] = 0.0; jQ_Odd [1] = 0.0; jQ_Odd [2] = 0.0; jQ_Even [0] = 0.0; jQ_Even [1] = 0.0; jQ_Even [2] = 0.0; jQ = 0.0; prev_jQ_Odd = 0.0; prev_jQ_Even = 0.0; prev_jQ_input_Odd = 0.0; prev_jQ_input_Even = 0.0; } ;
      period = 0.0;
      outIdx = 0;
      prevI2 = prevQ2 = 0.0;
      Re = Im = 0.0;
      I1ForOddPrev3 = I1ForEvenPrev3 = 0.0;
      I1ForOddPrev2 = I1ForEvenPrev2 = 0.0;
      smoothPeriod = 0.0;
      for( i=0; i < 50 ; i++ )
         smoothPrice[i] = 0.0;
      DCPhase = 0.0;
      while( today <= endIdx )
      {
         adjustedPrevPeriod = (0.075*period)+0.54;
         todayValue = inReal[today];
         { periodWMASub += todayValue; periodWMASub -= trailingWMAValue; periodWMASum += todayValue*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
         smoothPrice[smoothPrice_Idx] = smoothedValue;
         if( (today%2) == 0 )
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Even [hilbertIdx]; detrender_Even [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Even ; prev_detrender_Even = b * prev_detrender_input_Even ; detrender += prev_detrender_Even ; prev_detrender_input_Even = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Even [hilbertIdx]; Q1_Even [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Even ; prev_Q1_Even = b * prev_Q1_input_Even ; Q1 += prev_Q1_Even ; prev_Q1_input_Even = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForEvenPrev3; jI = -jI_Even [hilbertIdx]; jI_Even [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Even ; prev_jI_Even = b * prev_jI_input_Even ; jI += prev_jI_Even ; prev_jI_input_Even = I1ForEvenPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Even [hilbertIdx]; jQ_Even [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Even ; prev_jQ_Even = b * prev_jQ_input_Even ; jQ += prev_jQ_Even ; prev_jQ_input_Even = Q1; jQ *= adjustedPrevPeriod; } ;
            if( ++hilbertIdx == 3 )
               hilbertIdx = 0;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForEvenPrev3 - jQ)) + (0.8*prevI2);
            I1ForOddPrev3 = I1ForOddPrev2;
            I1ForOddPrev2 = detrender;
         }
         else
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Odd [hilbertIdx]; detrender_Odd [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Odd ; prev_detrender_Odd = b * prev_detrender_input_Odd ; detrender += prev_detrender_Odd ; prev_detrender_input_Odd = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Odd [hilbertIdx]; Q1_Odd [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Odd ; prev_Q1_Odd = b * prev_Q1_input_Odd ; Q1 += prev_Q1_Odd ; prev_Q1_input_Odd = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForOddPrev3; jI = -jI_Odd [hilbertIdx]; jI_Odd [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Odd ; prev_jI_Odd = b * prev_jI_input_Odd ; jI += prev_jI_Odd ; prev_jI_input_Odd = I1ForOddPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Odd [hilbertIdx]; jQ_Odd [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Odd ; prev_jQ_Odd = b * prev_jQ_input_Odd ; jQ += prev_jQ_Odd ; prev_jQ_input_Odd = Q1; jQ *= adjustedPrevPeriod; } ;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForOddPrev3 - jQ)) + (0.8*prevI2);
            I1ForEvenPrev3 = I1ForEvenPrev2;
            I1ForEvenPrev2 = detrender;
         }
         Re = (0.2*((I2*prevI2)+(Q2*prevQ2)))+(0.8*Re);
         Im = (0.2*((I2*prevQ2)-(Q2*prevI2)))+(0.8*Im);
         prevQ2 = Q2;
         prevI2 = I2;
         tempReal = period;
         if( (Im != 0.0) && (Re != 0.0) )
            period = 360.0 / ( Math.atan (Im/Re)*rad2Deg);
         tempReal2 = 1.5*tempReal;
         if( period > tempReal2)
            period = tempReal2;
         tempReal2 = 0.67*tempReal;
         if( period < tempReal2 )
            period = tempReal2;
         if( period < 6 )
            period = 6;
         else if( period > 50 )
            period = 50;
         period = (0.2*period) + (0.8 * tempReal);
         smoothPeriod = (0.33*period)+(0.67*smoothPeriod);
         DCPeriod = smoothPeriod+0.5;
         DCPeriodInt = (int)DCPeriod;
         realPart = 0.0;
         imagPart = 0.0;
         idx = smoothPrice_Idx;
         for( i=0; i < DCPeriodInt; i++ )
         {
            tempReal = ((double)i*constDeg2RadBy360)/(double)DCPeriodInt;
            tempReal2 = smoothPrice[idx];
            realPart += Math.sin (tempReal)*tempReal2;
            imagPart += Math.cos (tempReal)*tempReal2;
            if( idx == 0 )
               idx = 50 -1;
            else
               idx--;
         }
         tempReal = Math.abs (imagPart);
         if( tempReal > 0.0 )
            DCPhase = Math.atan (realPart/imagPart)*rad2Deg;
         else if( tempReal <= 0.01 )
         {
            if( realPart < 0.0 )
               DCPhase -= 90.0;
            else if( realPart > 0.0 )
               DCPhase += 90.0;
         }
         DCPhase += 90.0;
         DCPhase += 360.0 / smoothPeriod;
         if( imagPart < 0.0 )
            DCPhase += 180.0;
         if( DCPhase > 315.0 )
            DCPhase -= 360.0;
         if( today >= startIdx )
         {
            outSine[outIdx] = Math.sin (DCPhase*deg2Rad);
            outLeadSine[outIdx++] = Math.sin ((DCPhase+45)*deg2Rad);
         }
         { smoothPrice_Idx ++; if( smoothPrice_Idx > maxIdx_smoothPrice ) smoothPrice_Idx = 0; } ;
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int htTrendlineLookback( )
   {
      return 63 + (this.unstablePeriod[FuncUnstId.HtTrendline.ordinal()]) ;
   }
   public RetCode htTrendline( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      int lookbackTotal, today;
      double tempReal, tempReal2;
      double adjustedPrevPeriod, period;
      int trailingWMAIdx;
      double periodWMASum, periodWMASub, trailingWMAValue;
      double smoothedValue;
      double iTrend1, iTrend2, iTrend3;
      final double a = 0.0962;
      final double b = 0.5769;
      double hilbertTempReal;
      int hilbertIdx;
      double []detrender_Odd = new double[3] ; double []detrender_Even = new double[3] ; double detrender; double prev_detrender_Odd ; double prev_detrender_Even ; double prev_detrender_input_Odd ; double prev_detrender_input_Even ;
      double []Q1_Odd = new double[3] ; double []Q1_Even = new double[3] ; double Q1; double prev_Q1_Odd ; double prev_Q1_Even ; double prev_Q1_input_Odd ; double prev_Q1_input_Even ;
      double []jI_Odd = new double[3] ; double []jI_Even = new double[3] ; double jI; double prev_jI_Odd ; double prev_jI_Even ; double prev_jI_input_Odd ; double prev_jI_input_Even ;
      double []jQ_Odd = new double[3] ; double []jQ_Even = new double[3] ; double jQ; double prev_jQ_Odd ; double prev_jQ_Even ; double prev_jQ_input_Odd ; double prev_jQ_input_Even ;
      double Q2, I2, prevQ2, prevI2, Re, Im;
      double I1ForOddPrev2, I1ForOddPrev3;
      double I1ForEvenPrev2, I1ForEvenPrev3;
      double rad2Deg;
      double todayValue, smoothPeriod;
      int smoothPrice_Idx = 0; double []smoothPrice; int maxIdx_smoothPrice = ( 50 -1) ;
      int idx;
      int DCPeriodInt;
      double DCPeriod;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      { smoothPrice = new double[maxIdx_smoothPrice +1]; } ;
      iTrend1 = iTrend2 = iTrend3 = 0.0;
      tempReal = Math.atan (1);
      rad2Deg = 45.0/tempReal;
      lookbackTotal = 63 + (this.unstablePeriod[FuncUnstId.HtTrendline.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingWMAIdx = startIdx - lookbackTotal;
      today = trailingWMAIdx;
      tempReal = inReal[today++];
      periodWMASub = tempReal;
      periodWMASum = tempReal;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*2.0;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*3.0;
      trailingWMAValue = 0.0;
      i = 34;
      do
      {
         tempReal = inReal[today++];
         { periodWMASub += tempReal; periodWMASub -= trailingWMAValue; periodWMASum += tempReal*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
      } while( --i != 0);
      hilbertIdx = 0;
      { detrender_Odd [0] = 0.0; detrender_Odd [1] = 0.0; detrender_Odd [2] = 0.0; detrender_Even [0] = 0.0; detrender_Even [1] = 0.0; detrender_Even [2] = 0.0; detrender = 0.0; prev_detrender_Odd = 0.0; prev_detrender_Even = 0.0; prev_detrender_input_Odd = 0.0; prev_detrender_input_Even = 0.0; } ;
      { Q1_Odd [0] = 0.0; Q1_Odd [1] = 0.0; Q1_Odd [2] = 0.0; Q1_Even [0] = 0.0; Q1_Even [1] = 0.0; Q1_Even [2] = 0.0; Q1 = 0.0; prev_Q1_Odd = 0.0; prev_Q1_Even = 0.0; prev_Q1_input_Odd = 0.0; prev_Q1_input_Even = 0.0; } ;
      { jI_Odd [0] = 0.0; jI_Odd [1] = 0.0; jI_Odd [2] = 0.0; jI_Even [0] = 0.0; jI_Even [1] = 0.0; jI_Even [2] = 0.0; jI = 0.0; prev_jI_Odd = 0.0; prev_jI_Even = 0.0; prev_jI_input_Odd = 0.0; prev_jI_input_Even = 0.0; } ;
      { jQ_Odd [0] = 0.0; jQ_Odd [1] = 0.0; jQ_Odd [2] = 0.0; jQ_Even [0] = 0.0; jQ_Even [1] = 0.0; jQ_Even [2] = 0.0; jQ = 0.0; prev_jQ_Odd = 0.0; prev_jQ_Even = 0.0; prev_jQ_input_Odd = 0.0; prev_jQ_input_Even = 0.0; } ;
      period = 0.0;
      outIdx = 0;
      prevI2 = prevQ2 = 0.0;
      Re = Im = 0.0;
      I1ForOddPrev3 = I1ForEvenPrev3 = 0.0;
      I1ForOddPrev2 = I1ForEvenPrev2 = 0.0;
      smoothPeriod = 0.0;
      for( i=0; i < 50 ; i++ )
         smoothPrice[i] = 0.0;
      while( today <= endIdx )
      {
         adjustedPrevPeriod = (0.075*period)+0.54;
         todayValue = inReal[today];
         { periodWMASub += todayValue; periodWMASub -= trailingWMAValue; periodWMASum += todayValue*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
         smoothPrice[smoothPrice_Idx] = smoothedValue;
         if( (today%2) == 0 )
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Even [hilbertIdx]; detrender_Even [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Even ; prev_detrender_Even = b * prev_detrender_input_Even ; detrender += prev_detrender_Even ; prev_detrender_input_Even = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Even [hilbertIdx]; Q1_Even [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Even ; prev_Q1_Even = b * prev_Q1_input_Even ; Q1 += prev_Q1_Even ; prev_Q1_input_Even = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForEvenPrev3; jI = -jI_Even [hilbertIdx]; jI_Even [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Even ; prev_jI_Even = b * prev_jI_input_Even ; jI += prev_jI_Even ; prev_jI_input_Even = I1ForEvenPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Even [hilbertIdx]; jQ_Even [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Even ; prev_jQ_Even = b * prev_jQ_input_Even ; jQ += prev_jQ_Even ; prev_jQ_input_Even = Q1; jQ *= adjustedPrevPeriod; } ;
            if( ++hilbertIdx == 3 )
               hilbertIdx = 0;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForEvenPrev3 - jQ)) + (0.8*prevI2);
            I1ForOddPrev3 = I1ForOddPrev2;
            I1ForOddPrev2 = detrender;
         }
         else
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Odd [hilbertIdx]; detrender_Odd [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Odd ; prev_detrender_Odd = b * prev_detrender_input_Odd ; detrender += prev_detrender_Odd ; prev_detrender_input_Odd = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Odd [hilbertIdx]; Q1_Odd [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Odd ; prev_Q1_Odd = b * prev_Q1_input_Odd ; Q1 += prev_Q1_Odd ; prev_Q1_input_Odd = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForOddPrev3; jI = -jI_Odd [hilbertIdx]; jI_Odd [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Odd ; prev_jI_Odd = b * prev_jI_input_Odd ; jI += prev_jI_Odd ; prev_jI_input_Odd = I1ForOddPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Odd [hilbertIdx]; jQ_Odd [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Odd ; prev_jQ_Odd = b * prev_jQ_input_Odd ; jQ += prev_jQ_Odd ; prev_jQ_input_Odd = Q1; jQ *= adjustedPrevPeriod; } ;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForOddPrev3 - jQ)) + (0.8*prevI2);
            I1ForEvenPrev3 = I1ForEvenPrev2;
            I1ForEvenPrev2 = detrender;
         }
         Re = (0.2*((I2*prevI2)+(Q2*prevQ2)))+(0.8*Re);
         Im = (0.2*((I2*prevQ2)-(Q2*prevI2)))+(0.8*Im);
         prevQ2 = Q2;
         prevI2 = I2;
         tempReal = period;
         if( (Im != 0.0) && (Re != 0.0) )
            period = 360.0 / ( Math.atan (Im/Re)*rad2Deg);
         tempReal2 = 1.5*tempReal;
         if( period > tempReal2)
            period = tempReal2;
         tempReal2 = 0.67*tempReal;
         if( period < tempReal2 )
            period = tempReal2;
         if( period < 6 )
            period = 6;
         else if( period > 50 )
            period = 50;
         period = (0.2*period) + (0.8 * tempReal);
         smoothPeriod = (0.33*period)+(0.67*smoothPeriod);
         DCPeriod = smoothPeriod+0.5;
         DCPeriodInt = (int)DCPeriod;
         idx = today;
         tempReal = 0.0;
         for( i=0; i < DCPeriodInt; i++ )
            tempReal += inReal[idx--];
         if( DCPeriodInt > 0 )
            tempReal = tempReal/(double)DCPeriodInt;
         tempReal2 = (4.0*tempReal + 3.0*iTrend1 + 2.0*iTrend2 + iTrend3) / 10.0;
         iTrend3 = iTrend2;
         iTrend2 = iTrend1;
         iTrend1 = tempReal;
         if( today >= startIdx )
         {
            outReal[outIdx++] = tempReal2;
         }
         { smoothPrice_Idx ++; if( smoothPrice_Idx > maxIdx_smoothPrice ) smoothPrice_Idx = 0; } ;
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   struct TA_HT_TRENDLINE_STATE_CIRCBUF { int idx; double* circbuf; int size; };
   struct TA_HT_TRENDLINE_HILBERT_STRUCT { double []_Odd = new double[3] ; double []_Even = new double[3] ; double var; double prev_Odd; double prev_Even; double prev_input_Odd; double prev_input_Even; };
   public RetCode htTrendlineStateInit( struct TA_htTrendline_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct htTrendline ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = htTrendlineLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_HT_TRENDLINE_Data));
      else
         _state.value .value .memory = NULL;
      { _state.value .value .circBuf = calloc(1, sizeof(struct TA_HT_TRENDLINE_STATE_CIRCBUF )); if ( _state.value .value .circBuf == NULL) return RetCode.AllocErr ; struct TA_HT_TRENDLINE_STATE_CIRCBUF * buf = (struct TA_HT_TRENDLINE_STATE_CIRCBUF *) _state.value .value .circBuf; buf->idx = 0; buf->size = 50; buf->circbuf = calloc(50, sizeof(double)); if (!buf->circbuf) return RetCode.AllocErr ;} ;
      { _state.value .value .detrender = calloc(1, sizeof(struct TA_HT_TRENDLINE_HILBERT_STRUCT )); if ( _state.value .value .detrender == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .Q1 = calloc(1, sizeof(struct TA_HT_TRENDLINE_HILBERT_STRUCT )); if ( _state.value .value .Q1 == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .jI = calloc(1, sizeof(struct TA_HT_TRENDLINE_HILBERT_STRUCT )); if ( _state.value .value .jI == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .jQ = calloc(1, sizeof(struct TA_HT_TRENDLINE_HILBERT_STRUCT )); if ( _state.value .value .jQ == NULL) return RetCode.AllocErr ; } ;
      return RetCode.Success ;
   }
   public RetCode htTrendlineState( struct TA_htTrendline_State* _state,
      double inReal,
      double *outReal )
   {
      double hilbertTempReal, smoothedValue;
      double adjustedPrevPeriod;
      double Q2, I2;
      double tempReal, tempReal2;
      int DCPeriodInt;
      double DCPeriod;
      int idx, i;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .periodWMASub = 0.;
         _state.value .periodWMASum = 0.;
         _state.value .hilbertIdx = 0;
         _state.value .period = 0;
         _state.value .prevI2 = 0.;
         _state.value .prevQ2 = 0.;
         _state.value .I1ForOddPrev2 = 0;
         _state.value .I1ForEvenPrev2 = 0;
         _state.value .I1ForOddPrev3 = 0;
         _state.value .I1ForEvenPrev3 = 0;
         _state.value .smoothPeriod = 0;
         _state.value .Im = 0.;
         _state.value .Re = 0.;
         _state.value .trailingWMAValue = 0.;
         _state.value .rad2Deg = 180.0 / (4.0 * Math.atan (1));
         _state.value .iTrend1 = 0;
         _state.value .iTrend2 = 0;
         _state.value .iTrend3 = 0;
         _state.value .a = 0.0962;
         _state.value .b = 0.5769;
         { struct TA_HT_TRENDLINE_HILBERT_STRUCT * ref; ref = (struct TA_HT_TRENDLINE_HILBERT_STRUCT *) _state.value .detrender; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_HT_TRENDLINE_HILBERT_STRUCT * ref; ref = (struct TA_HT_TRENDLINE_HILBERT_STRUCT *) _state.value .Q1; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_HT_TRENDLINE_HILBERT_STRUCT * ref; ref = (struct TA_HT_TRENDLINE_HILBERT_STRUCT *) _state.value .jI; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_HT_TRENDLINE_HILBERT_STRUCT * ref; ref = (struct TA_HT_TRENDLINE_HILBERT_STRUCT *) _state.value .jQ; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
      }
      if ( _state.value .mem_index < 4)
      {
         _state.value .periodWMASub += inReal;
         _state.value .periodWMASum += _state.value .mem_index*inReal;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      } else
         if ( _state.value .mem_index <= 37)
      {
         { _state.value .periodWMASub += inReal; _state.value .periodWMASub -= _state.value .trailingWMAValue; _state.value .periodWMASum += inReal*4.0; _state.value .trailingWMAValue = ( _state.value .memory+(( _state.value .mem_index-1+-3)% _state.value .mem_size ) ).value .inReal ; smoothedValue = _state.value .periodWMASum*0.1; _state.value .periodWMASum -= _state.value .periodWMASub; } ;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      }
      adjustedPrevPeriod = (0.075* _state.value .period)+0.54;
      { _state.value .periodWMASub += inReal; _state.value .periodWMASub -= _state.value .trailingWMAValue; _state.value .periodWMASum += inReal*4.0; _state.value .trailingWMAValue = ( _state.value .memory+(( _state.value .mem_index-1+-3)% _state.value .mem_size ) ).value .inReal ; smoothedValue = _state.value .periodWMASum*0.1; _state.value .periodWMASum -= _state.value .periodWMASub; } ;
      (*( ((struct TA_HT_TRENDLINE_STATE_CIRCBUF *) _state.value .circBuf)->circbuf + ((struct TA_HT_TRENDLINE_STATE_CIRCBUF *) _state.value .circBuf)->idx )) = smoothedValue;
      if( (( _state.value .mem_index+1)%2) == 0 )
      {
         { struct TA_HT_TRENDLINE_HILBERT_STRUCT * ref; ref = (struct TA_HT_TRENDLINE_HILBERT_STRUCT *) _state.value .detrender; hilbertTempReal = _state.value .a * smoothedValue; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = smoothedValue; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_TRENDLINE_HILBERT_STRUCT * ref; ref = (struct TA_HT_TRENDLINE_HILBERT_STRUCT *) _state.value .Q1; hilbertTempReal = _state.value .a * (struct TA_HT_TRENDLINE_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = (struct TA_HT_TRENDLINE_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_TRENDLINE_HILBERT_STRUCT * ref; ref = (struct TA_HT_TRENDLINE_HILBERT_STRUCT *) _state.value .jI; hilbertTempReal = _state.value .a * _state.value .I1ForEvenPrev3; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = _state.value .I1ForEvenPrev3; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_TRENDLINE_HILBERT_STRUCT * ref; ref = (struct TA_HT_TRENDLINE_HILBERT_STRUCT *) _state.value .jQ; hilbertTempReal = _state.value .a * (struct TA_HT_TRENDLINE_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = (struct TA_HT_TRENDLINE_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         if( ++ _state.value .hilbertIdx == 3 )
            _state.value .hilbertIdx = 0;
         Q2 = (0.2*( (struct TA_HT_TRENDLINE_HILBERT_STRUCT *) _state.value .Q1.value .var + (struct TA_HT_TRENDLINE_HILBERT_STRUCT *) _state.value .jI.value .var )) + (0.8* _state.value .prevQ2);
         I2 = (0.2*( _state.value .I1ForEvenPrev3 - (struct TA_HT_TRENDLINE_HILBERT_STRUCT *) _state.value .jQ.value .var )) + (0.8* _state.value .prevI2);
         _state.value .I1ForOddPrev3 = _state.value .I1ForOddPrev2;
         _state.value .I1ForOddPrev2 = (struct TA_HT_TRENDLINE_HILBERT_STRUCT *) _state.value .detrender.value .var ;
      } else {
         { struct TA_HT_TRENDLINE_HILBERT_STRUCT * ref; ref = (struct TA_HT_TRENDLINE_HILBERT_STRUCT *) _state.value .detrender; hilbertTempReal = _state.value .a * smoothedValue; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = smoothedValue; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_TRENDLINE_HILBERT_STRUCT * ref; ref = (struct TA_HT_TRENDLINE_HILBERT_STRUCT *) _state.value .Q1; hilbertTempReal = _state.value .a * (struct TA_HT_TRENDLINE_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = (struct TA_HT_TRENDLINE_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_TRENDLINE_HILBERT_STRUCT * ref; ref = (struct TA_HT_TRENDLINE_HILBERT_STRUCT *) _state.value .jI; hilbertTempReal = _state.value .a * _state.value .I1ForOddPrev3; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = _state.value .I1ForOddPrev3; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_TRENDLINE_HILBERT_STRUCT * ref; ref = (struct TA_HT_TRENDLINE_HILBERT_STRUCT *) _state.value .jQ; hilbertTempReal = _state.value .a * (struct TA_HT_TRENDLINE_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = (struct TA_HT_TRENDLINE_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         Q2 = (0.2*( (struct TA_HT_TRENDLINE_HILBERT_STRUCT *) _state.value .Q1.value .var + (struct TA_HT_TRENDLINE_HILBERT_STRUCT *) _state.value .jI.value .var )) + (0.8* _state.value .prevQ2);
         I2 = (0.2*( _state.value .I1ForOddPrev3 - (struct TA_HT_TRENDLINE_HILBERT_STRUCT *) _state.value .jQ.value .var )) + (0.8* _state.value .prevI2);
         _state.value .I1ForEvenPrev3 = _state.value .I1ForEvenPrev2;
         _state.value .I1ForEvenPrev2 = (struct TA_HT_TRENDLINE_HILBERT_STRUCT *) _state.value .detrender.value .var ;
      }
      _state.value .Re = (0.2*((I2* _state.value .prevI2)+(Q2* _state.value .prevQ2)))+(0.8* _state.value .Re);
      _state.value .Im = (0.2*((I2* _state.value .prevQ2)-(Q2* _state.value .prevI2)))+(0.8* _state.value .Im);
      _state.value .prevQ2 = Q2;
      _state.value .prevI2 = I2;
      tempReal = _state.value .period;
      if( ( _state.value .Im != 0.0) && ( _state.value .Re != 0.0) )
         _state.value .period = 360.0 / ( Math.atan ( _state.value .Im/ _state.value .Re)* _state.value .rad2Deg);
      tempReal2 = 1.5*tempReal;
      if( _state.value .period > tempReal2)
         _state.value .period = tempReal2;
      tempReal2 = 0.67*tempReal;
      if( _state.value .period < tempReal2 )
         _state.value .period = tempReal2;
      if( _state.value .period < 6 )
         _state.value .period = 6;
      else if( _state.value .period > 50 )
         _state.value .period = 50;
      _state.value .period = (0.2* _state.value .period) + (0.8 * tempReal);
      _state.value .smoothPeriod = (0.33* _state.value .period)+(0.67* _state.value .smoothPeriod);
      DCPeriod = _state.value .smoothPeriod+0.5;
      DCPeriodInt = (int)DCPeriod;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      tempReal = 0.0;
      idx = _state.value .mem_index-1;
      for( i=0; i < DCPeriodInt; i++ )
         tempReal += ( _state.value .memory+idx-- % _state.value .mem_size ).value .inReal ;
      if( DCPeriodInt > 0 )
         tempReal = tempReal/(double)DCPeriodInt;
      tempReal2 = (4.0*tempReal + 3.0* _state.value .iTrend1 + 2.0* _state.value .iTrend2 + _state.value .iTrend3) / 10.0;
      _state.value .iTrend3 = _state.value .iTrend2;
      _state.value .iTrend2 = _state.value .iTrend1;
      _state.value .iTrend1 = tempReal;
      { struct TA_HT_TRENDLINE_STATE_CIRCBUF * buf = (struct TA_HT_TRENDLINE_STATE_CIRCBUF *) _state.value .circBuf; if(buf->idx < buf->size-1) buf->idx++; else buf->idx = 0;} ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      else {
         outReal.value = tempReal2;
         return RetCode.Success ;
      }
      return RetCode.Success ;
   }
   public RetCode htTrendlineStateFree( struct TA_htTrendline_State** _state )
   {
      { if ( _state.value .value .detrender != NULL) { free ( _state.value .value .detrender); _state.value .value .detrender = NULL; } } ;
      { if ( _state.value .value .Q1 != NULL) { free ( _state.value .value .Q1); _state.value .value .Q1 = NULL; } } ;
      { if ( _state.value .value .jI != NULL) { free ( _state.value .value .jI); _state.value .value .jI = NULL; } } ;
      { if ( _state.value .value .jQ != NULL) { free ( _state.value .value .jQ); _state.value .value .jQ = NULL; } } ;
      { struct TA_HT_TRENDLINE_STATE_CIRCBUF * buf = (struct TA_HT_TRENDLINE_STATE_CIRCBUF *) _state.value .value .circBuf; if (buf != NULL) { if (buf->circbuf != NULL) free(buf->circbuf); free (buf); _state.value .value .circBuf = NULL; } } ;
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode htTrendlineStateSave( struct TA_htTrendline_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_HT_TRENDLINE_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .hilbertIdx,sizeof( _state.value .hilbertIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodWMASub,sizeof( _state.value .periodWMASub),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodWMASum,sizeof( _state.value .periodWMASum),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .period,sizeof( _state.value .period),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .I1ForOddPrev2,sizeof( _state.value .I1ForOddPrev2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .I1ForEvenPrev2,sizeof( _state.value .I1ForEvenPrev2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .I1ForOddPrev3,sizeof( _state.value .I1ForOddPrev3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .I1ForEvenPrev3,sizeof( _state.value .I1ForEvenPrev3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevI2,sizeof( _state.value .prevI2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevQ2,sizeof( _state.value .prevQ2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .smoothPeriod,sizeof( _state.value .smoothPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .Im,sizeof( _state.value .Im),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .Re,sizeof( _state.value .Re),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .trailingWMAValue,sizeof( _state.value .trailingWMAValue),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .rad2Deg,sizeof( _state.value .rad2Deg),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .a,sizeof( _state.value .a),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .b,sizeof( _state.value .b),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .iTrend1,sizeof( _state.value .iTrend1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .iTrend2,sizeof( _state.value .iTrend2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .iTrend3,sizeof( _state.value .iTrend3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      { if ( _state.value .detrender == NULL) return RetCode.BadParam ; if (fwrite( _state.value .detrender,sizeof(struct TA_HT_TRENDLINE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .Q1 == NULL) return RetCode.BadParam ; if (fwrite( _state.value .Q1,sizeof(struct TA_HT_TRENDLINE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .jI == NULL) return RetCode.BadParam ; if (fwrite( _state.value .jI,sizeof(struct TA_HT_TRENDLINE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .jQ == NULL) return RetCode.BadParam ; if (fwrite( _state.value .jQ,sizeof(struct TA_HT_TRENDLINE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { int io_circbuf_res; struct TA_HT_TRENDLINE_STATE_CIRCBUF * str_circbuf = _state.value .circBuf; io_circbuf_res = fwrite(&str_circbuf->idx,sizeof(str_circbuf->idx),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; io_circbuf_res = fwrite(&str_circbuf->size,sizeof(str_circbuf->size),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; if (str_circbuf->size > 0) { io_circbuf_res = fwrite(str_circbuf->circbuf,sizeof(str_circbuf->circbuf),str_circbuf->size,_file); if (io_circbuf_res < str_circbuf->size) return RetCode.IOFailed ; } }
      return 0;
   }
   public RetCode htTrendlineStateLoad( struct TA_htTrendline_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct htTrendline ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_HT_TRENDLINE_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_HT_TRENDLINE_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .hilbertIdx,sizeof( _state.value .value .hilbertIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodWMASub,sizeof( _state.value .value .periodWMASub),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodWMASum,sizeof( _state.value .value .periodWMASum),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .period,sizeof( _state.value .value .period),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .I1ForOddPrev2,sizeof( _state.value .value .I1ForOddPrev2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .I1ForEvenPrev2,sizeof( _state.value .value .I1ForEvenPrev2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .I1ForOddPrev3,sizeof( _state.value .value .I1ForOddPrev3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .I1ForEvenPrev3,sizeof( _state.value .value .I1ForEvenPrev3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevI2,sizeof( _state.value .value .prevI2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevQ2,sizeof( _state.value .value .prevQ2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .smoothPeriod,sizeof( _state.value .value .smoothPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .Im,sizeof( _state.value .value .Im),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .Re,sizeof( _state.value .value .Re),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .trailingWMAValue,sizeof( _state.value .value .trailingWMAValue),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .rad2Deg,sizeof( _state.value .value .rad2Deg),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .a,sizeof( _state.value .value .a),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .b,sizeof( _state.value .value .b),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .iTrend1,sizeof( _state.value .value .iTrend1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .iTrend2,sizeof( _state.value .value .iTrend2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .iTrend3,sizeof( _state.value .value .iTrend3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      { if ( _state.value .value .detrender != NULL) return RetCode.BadParam ; { _state.value .value .detrender = calloc(1, sizeof(struct TA_HT_TRENDLINE_HILBERT_STRUCT )); if ( _state.value .value .detrender == NULL) return RetCode.AllocErr ; } if (fread( _state.value .value .detrender,sizeof(struct TA_HT_TRENDLINE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .value .Q1 != NULL) return RetCode.BadParam ; { _state.value .value .Q1 = calloc(1, sizeof(struct TA_HT_TRENDLINE_HILBERT_STRUCT )); if ( _state.value .value .Q1 == NULL) return RetCode.AllocErr ; } if (fread( _state.value .value .Q1,sizeof(struct TA_HT_TRENDLINE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .value .jI != NULL) return RetCode.BadParam ; { _state.value .value .jI = calloc(1, sizeof(struct TA_HT_TRENDLINE_HILBERT_STRUCT )); if ( _state.value .value .jI == NULL) return RetCode.AllocErr ; } if (fread( _state.value .value .jI,sizeof(struct TA_HT_TRENDLINE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .value .jQ != NULL) return RetCode.BadParam ; { _state.value .value .jQ = calloc(1, sizeof(struct TA_HT_TRENDLINE_HILBERT_STRUCT )); if ( _state.value .value .jQ == NULL) return RetCode.AllocErr ; } if (fread( _state.value .value .jQ,sizeof(struct TA_HT_TRENDLINE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { int io_circbuf_res; int circbuf_idx; int circbuf_size; if ( _state.value .value .circBuf != NULL) return RetCode.BadParam ; io_circbuf_res = fread(&circbuf_idx,sizeof(circbuf_idx),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; io_circbuf_res = fread(&circbuf_size,sizeof(circbuf_size),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; { _state.value .value .circBuf = calloc(1, sizeof(struct TA_HT_TRENDLINE_STATE_CIRCBUF )); if ( _state.value .value .circBuf == NULL) return RetCode.AllocErr ; struct TA_HT_TRENDLINE_STATE_CIRCBUF * buf = (struct TA_HT_TRENDLINE_STATE_CIRCBUF *) _state.value .value .circBuf; buf->idx = 0; buf->size = circbuf_size; buf->circbuf = calloc(circbuf_size, sizeof(double)); if (!buf->circbuf) return RetCode.AllocErr ;} struct TA_HT_TRENDLINE_STATE_CIRCBUF * str_circbuf = _state.value .value .circBuf; str_circbuf->idx = circbuf_idx; if (str_circbuf->size > 0) { io_circbuf_res = fread(str_circbuf->circbuf,sizeof(str_circbuf->circbuf),str_circbuf->size,_file); if (io_circbuf_res < str_circbuf->size) return RetCode.IOFailed ; } }
      return 0;
   }
   public RetCode htTrendline( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      int lookbackTotal, today;
      double tempReal, tempReal2;
      double adjustedPrevPeriod, period;
      int trailingWMAIdx;
      double periodWMASum, periodWMASub, trailingWMAValue;
      double smoothedValue;
      double iTrend1, iTrend2, iTrend3;
      final double a = 0.0962;
      final double b = 0.5769;
      double hilbertTempReal;
      int hilbertIdx;
      double []detrender_Odd = new double[3] ; double []detrender_Even = new double[3] ; double detrender; double prev_detrender_Odd ; double prev_detrender_Even ; double prev_detrender_input_Odd ; double prev_detrender_input_Even ;
      double []Q1_Odd = new double[3] ; double []Q1_Even = new double[3] ; double Q1; double prev_Q1_Odd ; double prev_Q1_Even ; double prev_Q1_input_Odd ; double prev_Q1_input_Even ;
      double []jI_Odd = new double[3] ; double []jI_Even = new double[3] ; double jI; double prev_jI_Odd ; double prev_jI_Even ; double prev_jI_input_Odd ; double prev_jI_input_Even ;
      double []jQ_Odd = new double[3] ; double []jQ_Even = new double[3] ; double jQ; double prev_jQ_Odd ; double prev_jQ_Even ; double prev_jQ_input_Odd ; double prev_jQ_input_Even ;
      double Q2, I2, prevQ2, prevI2, Re, Im;
      double I1ForOddPrev2, I1ForOddPrev3;
      double I1ForEvenPrev2, I1ForEvenPrev3;
      double rad2Deg;
      double todayValue, smoothPeriod;
      int smoothPrice_Idx = 0; double []smoothPrice; int maxIdx_smoothPrice = ( 50 -1) ;
      int idx;
      int DCPeriodInt;
      double DCPeriod;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      { smoothPrice = new double[maxIdx_smoothPrice +1]; } ;
      iTrend1 = iTrend2 = iTrend3 = 0.0;
      tempReal = Math.atan (1);
      rad2Deg = 45.0/tempReal;
      lookbackTotal = 63 + (this.unstablePeriod[FuncUnstId.HtTrendline.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingWMAIdx = startIdx - lookbackTotal;
      today = trailingWMAIdx;
      tempReal = inReal[today++];
      periodWMASub = tempReal;
      periodWMASum = tempReal;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*2.0;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*3.0;
      trailingWMAValue = 0.0;
      i = 34;
      do
      {
         tempReal = inReal[today++];
         { periodWMASub += tempReal; periodWMASub -= trailingWMAValue; periodWMASum += tempReal*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
      } while( --i != 0);
      hilbertIdx = 0;
      { detrender_Odd [0] = 0.0; detrender_Odd [1] = 0.0; detrender_Odd [2] = 0.0; detrender_Even [0] = 0.0; detrender_Even [1] = 0.0; detrender_Even [2] = 0.0; detrender = 0.0; prev_detrender_Odd = 0.0; prev_detrender_Even = 0.0; prev_detrender_input_Odd = 0.0; prev_detrender_input_Even = 0.0; } ;
      { Q1_Odd [0] = 0.0; Q1_Odd [1] = 0.0; Q1_Odd [2] = 0.0; Q1_Even [0] = 0.0; Q1_Even [1] = 0.0; Q1_Even [2] = 0.0; Q1 = 0.0; prev_Q1_Odd = 0.0; prev_Q1_Even = 0.0; prev_Q1_input_Odd = 0.0; prev_Q1_input_Even = 0.0; } ;
      { jI_Odd [0] = 0.0; jI_Odd [1] = 0.0; jI_Odd [2] = 0.0; jI_Even [0] = 0.0; jI_Even [1] = 0.0; jI_Even [2] = 0.0; jI = 0.0; prev_jI_Odd = 0.0; prev_jI_Even = 0.0; prev_jI_input_Odd = 0.0; prev_jI_input_Even = 0.0; } ;
      { jQ_Odd [0] = 0.0; jQ_Odd [1] = 0.0; jQ_Odd [2] = 0.0; jQ_Even [0] = 0.0; jQ_Even [1] = 0.0; jQ_Even [2] = 0.0; jQ = 0.0; prev_jQ_Odd = 0.0; prev_jQ_Even = 0.0; prev_jQ_input_Odd = 0.0; prev_jQ_input_Even = 0.0; } ;
      period = 0.0;
      outIdx = 0;
      prevI2 = prevQ2 = 0.0;
      Re = Im = 0.0;
      I1ForOddPrev3 = I1ForEvenPrev3 = 0.0;
      I1ForOddPrev2 = I1ForEvenPrev2 = 0.0;
      smoothPeriod = 0.0;
      for( i=0; i < 50 ; i++ )
         smoothPrice[i] = 0.0;
      while( today <= endIdx )
      {
         adjustedPrevPeriod = (0.075*period)+0.54;
         todayValue = inReal[today];
         { periodWMASub += todayValue; periodWMASub -= trailingWMAValue; periodWMASum += todayValue*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
         smoothPrice[smoothPrice_Idx] = smoothedValue;
         if( (today%2) == 0 )
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Even [hilbertIdx]; detrender_Even [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Even ; prev_detrender_Even = b * prev_detrender_input_Even ; detrender += prev_detrender_Even ; prev_detrender_input_Even = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Even [hilbertIdx]; Q1_Even [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Even ; prev_Q1_Even = b * prev_Q1_input_Even ; Q1 += prev_Q1_Even ; prev_Q1_input_Even = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForEvenPrev3; jI = -jI_Even [hilbertIdx]; jI_Even [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Even ; prev_jI_Even = b * prev_jI_input_Even ; jI += prev_jI_Even ; prev_jI_input_Even = I1ForEvenPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Even [hilbertIdx]; jQ_Even [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Even ; prev_jQ_Even = b * prev_jQ_input_Even ; jQ += prev_jQ_Even ; prev_jQ_input_Even = Q1; jQ *= adjustedPrevPeriod; } ;
            if( ++hilbertIdx == 3 )
               hilbertIdx = 0;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForEvenPrev3 - jQ)) + (0.8*prevI2);
            I1ForOddPrev3 = I1ForOddPrev2;
            I1ForOddPrev2 = detrender;
         }
         else
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Odd [hilbertIdx]; detrender_Odd [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Odd ; prev_detrender_Odd = b * prev_detrender_input_Odd ; detrender += prev_detrender_Odd ; prev_detrender_input_Odd = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Odd [hilbertIdx]; Q1_Odd [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Odd ; prev_Q1_Odd = b * prev_Q1_input_Odd ; Q1 += prev_Q1_Odd ; prev_Q1_input_Odd = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForOddPrev3; jI = -jI_Odd [hilbertIdx]; jI_Odd [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Odd ; prev_jI_Odd = b * prev_jI_input_Odd ; jI += prev_jI_Odd ; prev_jI_input_Odd = I1ForOddPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Odd [hilbertIdx]; jQ_Odd [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Odd ; prev_jQ_Odd = b * prev_jQ_input_Odd ; jQ += prev_jQ_Odd ; prev_jQ_input_Odd = Q1; jQ *= adjustedPrevPeriod; } ;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForOddPrev3 - jQ)) + (0.8*prevI2);
            I1ForEvenPrev3 = I1ForEvenPrev2;
            I1ForEvenPrev2 = detrender;
         }
         Re = (0.2*((I2*prevI2)+(Q2*prevQ2)))+(0.8*Re);
         Im = (0.2*((I2*prevQ2)-(Q2*prevI2)))+(0.8*Im);
         prevQ2 = Q2;
         prevI2 = I2;
         tempReal = period;
         if( (Im != 0.0) && (Re != 0.0) )
            period = 360.0 / ( Math.atan (Im/Re)*rad2Deg);
         tempReal2 = 1.5*tempReal;
         if( period > tempReal2)
            period = tempReal2;
         tempReal2 = 0.67*tempReal;
         if( period < tempReal2 )
            period = tempReal2;
         if( period < 6 )
            period = 6;
         else if( period > 50 )
            period = 50;
         period = (0.2*period) + (0.8 * tempReal);
         smoothPeriod = (0.33*period)+(0.67*smoothPeriod);
         DCPeriod = smoothPeriod+0.5;
         DCPeriodInt = (int)DCPeriod;
         idx = today;
         tempReal = 0.0;
         for( i=0; i < DCPeriodInt; i++ )
            tempReal += inReal[idx--];
         if( DCPeriodInt > 0 )
            tempReal = tempReal/(double)DCPeriodInt;
         tempReal2 = (4.0*tempReal + 3.0*iTrend1 + 2.0*iTrend2 + iTrend3) / 10.0;
         iTrend3 = iTrend2;
         iTrend2 = iTrend1;
         iTrend1 = tempReal;
         if( today >= startIdx )
         {
            outReal[outIdx++] = tempReal2;
         }
         { smoothPrice_Idx ++; if( smoothPrice_Idx > maxIdx_smoothPrice ) smoothPrice_Idx = 0; } ;
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int htTrendModeLookback( )
   {
      return 63 + (this.unstablePeriod[FuncUnstId.HtTrendMode.ordinal()]) ;
   }
   public RetCode htTrendMode( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      int outIdx, i;
      int lookbackTotal, today;
      double tempReal, tempReal2;
      double adjustedPrevPeriod, period;
      int trailingWMAIdx;
      double periodWMASum, periodWMASub, trailingWMAValue;
      double smoothedValue;
      double iTrend1, iTrend2, iTrend3;
      final double a = 0.0962;
      final double b = 0.5769;
      double hilbertTempReal;
      int hilbertIdx;
      double []detrender_Odd = new double[3] ; double []detrender_Even = new double[3] ; double detrender; double prev_detrender_Odd ; double prev_detrender_Even ; double prev_detrender_input_Odd ; double prev_detrender_input_Even ;
      double []Q1_Odd = new double[3] ; double []Q1_Even = new double[3] ; double Q1; double prev_Q1_Odd ; double prev_Q1_Even ; double prev_Q1_input_Odd ; double prev_Q1_input_Even ;
      double []jI_Odd = new double[3] ; double []jI_Even = new double[3] ; double jI; double prev_jI_Odd ; double prev_jI_Even ; double prev_jI_input_Odd ; double prev_jI_input_Even ;
      double []jQ_Odd = new double[3] ; double []jQ_Even = new double[3] ; double jQ; double prev_jQ_Odd ; double prev_jQ_Even ; double prev_jQ_input_Odd ; double prev_jQ_input_Even ;
      double Q2, I2, prevQ2, prevI2, Re, Im;
      double I1ForOddPrev2, I1ForOddPrev3;
      double I1ForEvenPrev2, I1ForEvenPrev3;
      double rad2Deg, deg2Rad, constDeg2RadBy360;
      double todayValue, smoothPeriod;
      int smoothPrice_Idx = 0; double []smoothPrice; int maxIdx_smoothPrice = ( 50 -1) ;
      int idx;
      int DCPeriodInt;
      double DCPhase, DCPeriod, imagPart, realPart;
      int daysInTrend, trend;
      double prevDCPhase, trendline;
      double prevSine, prevLeadSine, sine, leadSine;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      { smoothPrice = new double[maxIdx_smoothPrice +1]; } ;
      iTrend1 = iTrend2 = iTrend3 = 0.0;
      daysInTrend = 0;
      prevDCPhase = DCPhase = 0.0;
      prevSine = sine = 0.0;
      prevLeadSine = leadSine = 0.0;
      tempReal = Math.atan (1);
      rad2Deg = 45.0/tempReal;
      deg2Rad = 1.0/rad2Deg;
      constDeg2RadBy360 = tempReal*8.0;
      lookbackTotal = 63 + (this.unstablePeriod[FuncUnstId.HtTrendMode.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingWMAIdx = startIdx - lookbackTotal;
      today = trailingWMAIdx;
      tempReal = inReal[today++];
      periodWMASub = tempReal;
      periodWMASum = tempReal;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*2.0;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*3.0;
      trailingWMAValue = 0.0;
      i = 34;
      do
      {
         tempReal = inReal[today++];
         { periodWMASub += tempReal; periodWMASub -= trailingWMAValue; periodWMASum += tempReal*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
      } while( --i != 0);
      hilbertIdx = 0;
      { detrender_Odd [0] = 0.0; detrender_Odd [1] = 0.0; detrender_Odd [2] = 0.0; detrender_Even [0] = 0.0; detrender_Even [1] = 0.0; detrender_Even [2] = 0.0; detrender = 0.0; prev_detrender_Odd = 0.0; prev_detrender_Even = 0.0; prev_detrender_input_Odd = 0.0; prev_detrender_input_Even = 0.0; } ;
      { Q1_Odd [0] = 0.0; Q1_Odd [1] = 0.0; Q1_Odd [2] = 0.0; Q1_Even [0] = 0.0; Q1_Even [1] = 0.0; Q1_Even [2] = 0.0; Q1 = 0.0; prev_Q1_Odd = 0.0; prev_Q1_Even = 0.0; prev_Q1_input_Odd = 0.0; prev_Q1_input_Even = 0.0; } ;
      { jI_Odd [0] = 0.0; jI_Odd [1] = 0.0; jI_Odd [2] = 0.0; jI_Even [0] = 0.0; jI_Even [1] = 0.0; jI_Even [2] = 0.0; jI = 0.0; prev_jI_Odd = 0.0; prev_jI_Even = 0.0; prev_jI_input_Odd = 0.0; prev_jI_input_Even = 0.0; } ;
      { jQ_Odd [0] = 0.0; jQ_Odd [1] = 0.0; jQ_Odd [2] = 0.0; jQ_Even [0] = 0.0; jQ_Even [1] = 0.0; jQ_Even [2] = 0.0; jQ = 0.0; prev_jQ_Odd = 0.0; prev_jQ_Even = 0.0; prev_jQ_input_Odd = 0.0; prev_jQ_input_Even = 0.0; } ;
      period = 0.0;
      outIdx = 0;
      prevI2 = prevQ2 = 0.0;
      Re = Im = 0.0;
      I1ForOddPrev3 = I1ForEvenPrev3 = 0.0;
      I1ForOddPrev2 = I1ForEvenPrev2 = 0.0;
      smoothPeriod = 0.0;
      for( i=0; i < 50 ; i++ )
         smoothPrice[i] = 0.0;
      DCPhase = 0.0;
      while( today <= endIdx )
      {
         adjustedPrevPeriod = (0.075*period)+0.54;
         todayValue = inReal[today];
         { periodWMASub += todayValue; periodWMASub -= trailingWMAValue; periodWMASum += todayValue*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
         smoothPrice[smoothPrice_Idx] = smoothedValue;
         if( (today%2) == 0 )
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Even [hilbertIdx]; detrender_Even [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Even ; prev_detrender_Even = b * prev_detrender_input_Even ; detrender += prev_detrender_Even ; prev_detrender_input_Even = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Even [hilbertIdx]; Q1_Even [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Even ; prev_Q1_Even = b * prev_Q1_input_Even ; Q1 += prev_Q1_Even ; prev_Q1_input_Even = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForEvenPrev3; jI = -jI_Even [hilbertIdx]; jI_Even [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Even ; prev_jI_Even = b * prev_jI_input_Even ; jI += prev_jI_Even ; prev_jI_input_Even = I1ForEvenPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Even [hilbertIdx]; jQ_Even [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Even ; prev_jQ_Even = b * prev_jQ_input_Even ; jQ += prev_jQ_Even ; prev_jQ_input_Even = Q1; jQ *= adjustedPrevPeriod; } ;
            if( ++hilbertIdx == 3 )
               hilbertIdx = 0;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForEvenPrev3 - jQ)) + (0.8*prevI2);
            I1ForOddPrev3 = I1ForOddPrev2;
            I1ForOddPrev2 = detrender;
         }
         else
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Odd [hilbertIdx]; detrender_Odd [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Odd ; prev_detrender_Odd = b * prev_detrender_input_Odd ; detrender += prev_detrender_Odd ; prev_detrender_input_Odd = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Odd [hilbertIdx]; Q1_Odd [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Odd ; prev_Q1_Odd = b * prev_Q1_input_Odd ; Q1 += prev_Q1_Odd ; prev_Q1_input_Odd = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForOddPrev3; jI = -jI_Odd [hilbertIdx]; jI_Odd [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Odd ; prev_jI_Odd = b * prev_jI_input_Odd ; jI += prev_jI_Odd ; prev_jI_input_Odd = I1ForOddPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Odd [hilbertIdx]; jQ_Odd [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Odd ; prev_jQ_Odd = b * prev_jQ_input_Odd ; jQ += prev_jQ_Odd ; prev_jQ_input_Odd = Q1; jQ *= adjustedPrevPeriod; } ;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForOddPrev3 - jQ)) + (0.8*prevI2);
            I1ForEvenPrev3 = I1ForEvenPrev2;
            I1ForEvenPrev2 = detrender;
         }
         Re = (0.2*((I2*prevI2)+(Q2*prevQ2)))+(0.8*Re);
         Im = (0.2*((I2*prevQ2)-(Q2*prevI2)))+(0.8*Im);
         prevQ2 = Q2;
         prevI2 = I2;
         tempReal = period;
         if( (Im != 0.0) && (Re != 0.0) )
            period = 360.0 / ( Math.atan (Im/Re)*rad2Deg);
         tempReal2 = 1.5*tempReal;
         if( period > tempReal2)
            period = tempReal2;
         tempReal2 = 0.67*tempReal;
         if( period < tempReal2 )
            period = tempReal2;
         if( period < 6 )
            period = 6;
         else if( period > 50 )
            period = 50;
         period = (0.2*period) + (0.8 * tempReal);
         smoothPeriod = (0.33*period)+(0.67*smoothPeriod);
         prevDCPhase = DCPhase;
         DCPeriod = smoothPeriod+0.5;
         DCPeriodInt = (int)DCPeriod;
         realPart = 0.0;
         imagPart = 0.0;
         idx = smoothPrice_Idx;
         for( i=0; i < DCPeriodInt; i++ )
         {
            tempReal = ((double)i*constDeg2RadBy360)/(double)DCPeriodInt;
            tempReal2 = smoothPrice[idx];
            realPart += Math.sin (tempReal)*tempReal2;
            imagPart += Math.cos (tempReal)*tempReal2;
            if( idx == 0 )
               idx = 50 -1;
            else
               idx--;
         }
         tempReal = Math.abs (imagPart);
         if( tempReal > 0.0 )
            DCPhase = Math.atan (realPart/imagPart)*rad2Deg;
         else if( tempReal <= 0.01 )
         {
            if( realPart < 0.0 )
               DCPhase -= 90.0;
            else if( realPart > 0.0 )
               DCPhase += 90.0;
         }
         DCPhase += 90.0;
         DCPhase += 360.0 / smoothPeriod;
         if( imagPart < 0.0 )
            DCPhase += 180.0;
         if( DCPhase > 315.0 )
            DCPhase -= 360.0;
         prevSine = sine;
         prevLeadSine = leadSine;
         sine = Math.sin (DCPhase*deg2Rad);
         leadSine = Math.sin ((DCPhase+45)*deg2Rad);
         DCPeriod = smoothPeriod+0.5;
         DCPeriodInt = (int)DCPeriod;
         idx = today;
         tempReal = 0.0;
         for( i=0; i < DCPeriodInt; i++ )
            tempReal += inReal[idx--];
         if( DCPeriodInt > 0 )
            tempReal = tempReal/(double)DCPeriodInt;
         trendline = (4.0*tempReal + 3.0*iTrend1 + 2.0*iTrend2 + iTrend3) / 10.0;
         iTrend3 = iTrend2;
         iTrend2 = iTrend1;
         iTrend1 = tempReal;
         trend = 1;
         if( ((sine > leadSine) && (prevSine <= prevLeadSine)) ||
            ((sine < leadSine) && (prevSine >= prevLeadSine)) )
         {
            daysInTrend = 0;
            trend = 0;
         }
         daysInTrend++;
         if( daysInTrend < (0.5*smoothPeriod) )
            trend = 0;
         tempReal = DCPhase - prevDCPhase;
         if( (smoothPeriod != 0.0) &&
            ((tempReal > (0.67*360.0/smoothPeriod)) && (tempReal < (1.5*360.0/smoothPeriod))) )
         {
            trend = 0;
         }
         tempReal = smoothPrice[smoothPrice_Idx];
         if( (trendline != 0.0) && ( Math.abs ( (tempReal - trendline)/trendline ) >= 0.015) )
            trend = 1;
         if( today >= startIdx )
         {
            outInteger[outIdx++] = trend;
         }
         { smoothPrice_Idx ++; if( smoothPrice_Idx > maxIdx_smoothPrice ) smoothPrice_Idx = 0; } ;
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   struct TA_HT_TRENDMODE_STATE_CIRCBUF { int idx; double* circbuf; int size; };
   struct TA_HT_TRENDMODE_HILBERT_STRUCT { double []_Odd = new double[3] ; double []_Even = new double[3] ; double var; double prev_Odd; double prev_Even; double prev_input_Odd; double prev_input_Even; };
   public RetCode htTrendModeStateInit( struct TA_htTrendMode_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct htTrendMode ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = htTrendModeLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_HT_TRENDMODE_Data));
      else
         _state.value .value .memory = NULL;
      { _state.value .value .circBuf = calloc(1, sizeof(struct TA_HT_TRENDMODE_STATE_CIRCBUF )); if ( _state.value .value .circBuf == NULL) return RetCode.AllocErr ; struct TA_HT_TRENDMODE_STATE_CIRCBUF * buf = (struct TA_HT_TRENDMODE_STATE_CIRCBUF *) _state.value .value .circBuf; buf->idx = 0; buf->size = 50; buf->circbuf = calloc(50, sizeof(double)); if (!buf->circbuf) return RetCode.AllocErr ;} ;
      { _state.value .value .detrender = calloc(1, sizeof(struct TA_HT_TRENDMODE_HILBERT_STRUCT )); if ( _state.value .value .detrender == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .Q1 = calloc(1, sizeof(struct TA_HT_TRENDMODE_HILBERT_STRUCT )); if ( _state.value .value .Q1 == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .jI = calloc(1, sizeof(struct TA_HT_TRENDMODE_HILBERT_STRUCT )); if ( _state.value .value .jI == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .jQ = calloc(1, sizeof(struct TA_HT_TRENDMODE_HILBERT_STRUCT )); if ( _state.value .value .jQ == NULL) return RetCode.AllocErr ; } ;
      return RetCode.Success ;
   }
   public RetCode htTrendModeState( struct TA_htTrendMode_State* _state,
      double inReal,
      int *outInteger )
   {
      double hilbertTempReal, smoothedValue;
      double adjustedPrevPeriod;
      double Q2, I2;
      double tempReal, tempReal2;
      int DCPeriodInt;
      double DCPeriod, imagPart, realPart;
      int idx, i, trend;
      double trendline;
      double sine, leadSine;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .periodWMASub = 0.;
         _state.value .periodWMASum = 0.;
         _state.value .hilbertIdx = 0;
         _state.value .period = 0;
         _state.value .prevI2 = 0.;
         _state.value .prevQ2 = 0.;
         _state.value .I1ForOddPrev2 = 0;
         _state.value .I1ForEvenPrev2 = 0;
         _state.value .I1ForOddPrev3 = 0;
         _state.value .I1ForEvenPrev3 = 0;
         _state.value .smoothPeriod = 0;
         _state.value .Im = 0.;
         _state.value .Re = 0.;
         _state.value .trailingWMAValue = 0.;
         _state.value .rad2Deg = 180.0 / (4.0 * Math.atan (1));
         _state.value .deg2Rad = 1.0/ _state.value .rad2Deg;
         _state.value .constDeg2RadBy360 = Math.atan (1)*8.0;
         _state.value .DCPhase = 0;
         _state.value .prevDCPhase = 0;
         _state.value .iTrend1 = 0;
         _state.value .iTrend2 = 0;
         _state.value .iTrend3 = 0;
         _state.value .prevSine = 0;
         _state.value .prevLeadSine = 0;
         _state.value .a = 0.0962;
         _state.value .b = 0.5769;
         { struct TA_HT_TRENDMODE_HILBERT_STRUCT * ref; ref = (struct TA_HT_TRENDMODE_HILBERT_STRUCT *) _state.value .detrender; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_HT_TRENDMODE_HILBERT_STRUCT * ref; ref = (struct TA_HT_TRENDMODE_HILBERT_STRUCT *) _state.value .Q1; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_HT_TRENDMODE_HILBERT_STRUCT * ref; ref = (struct TA_HT_TRENDMODE_HILBERT_STRUCT *) _state.value .jI; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_HT_TRENDMODE_HILBERT_STRUCT * ref; ref = (struct TA_HT_TRENDMODE_HILBERT_STRUCT *) _state.value .jQ; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
      }
      if ( _state.value .mem_index < 4)
      {
         _state.value .periodWMASub += inReal;
         _state.value .periodWMASum += _state.value .mem_index*inReal;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      } else
         if ( _state.value .mem_index <= 37)
      {
         { _state.value .periodWMASub += inReal; _state.value .periodWMASub -= _state.value .trailingWMAValue; _state.value .periodWMASum += inReal*4.0; _state.value .trailingWMAValue = ( _state.value .memory+(( _state.value .mem_index-1+-3)% _state.value .mem_size ) ).value .inReal ; smoothedValue = _state.value .periodWMASum*0.1; _state.value .periodWMASum -= _state.value .periodWMASub; } ;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      }
      adjustedPrevPeriod = (0.075* _state.value .period)+0.54;
      { _state.value .periodWMASub += inReal; _state.value .periodWMASub -= _state.value .trailingWMAValue; _state.value .periodWMASum += inReal*4.0; _state.value .trailingWMAValue = ( _state.value .memory+(( _state.value .mem_index-1+-3)% _state.value .mem_size ) ).value .inReal ; smoothedValue = _state.value .periodWMASum*0.1; _state.value .periodWMASum -= _state.value .periodWMASub; } ;
      (*( ((struct TA_HT_TRENDMODE_STATE_CIRCBUF *) _state.value .circBuf)->circbuf + ((struct TA_HT_TRENDMODE_STATE_CIRCBUF *) _state.value .circBuf)->idx )) = smoothedValue;
      if( (( _state.value .mem_index+1)%2) == 0 )
      {
         { struct TA_HT_TRENDMODE_HILBERT_STRUCT * ref; ref = (struct TA_HT_TRENDMODE_HILBERT_STRUCT *) _state.value .detrender; hilbertTempReal = _state.value .a * smoothedValue; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = smoothedValue; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_TRENDMODE_HILBERT_STRUCT * ref; ref = (struct TA_HT_TRENDMODE_HILBERT_STRUCT *) _state.value .Q1; hilbertTempReal = _state.value .a * (struct TA_HT_TRENDMODE_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = (struct TA_HT_TRENDMODE_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_TRENDMODE_HILBERT_STRUCT * ref; ref = (struct TA_HT_TRENDMODE_HILBERT_STRUCT *) _state.value .jI; hilbertTempReal = _state.value .a * _state.value .I1ForEvenPrev3; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = _state.value .I1ForEvenPrev3; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_TRENDMODE_HILBERT_STRUCT * ref; ref = (struct TA_HT_TRENDMODE_HILBERT_STRUCT *) _state.value .jQ; hilbertTempReal = _state.value .a * (struct TA_HT_TRENDMODE_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = (struct TA_HT_TRENDMODE_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         if( ++ _state.value .hilbertIdx == 3 )
            _state.value .hilbertIdx = 0;
         Q2 = (0.2*( (struct TA_HT_TRENDMODE_HILBERT_STRUCT *) _state.value .Q1.value .var + (struct TA_HT_TRENDMODE_HILBERT_STRUCT *) _state.value .jI.value .var )) + (0.8* _state.value .prevQ2);
         I2 = (0.2*( _state.value .I1ForEvenPrev3 - (struct TA_HT_TRENDMODE_HILBERT_STRUCT *) _state.value .jQ.value .var )) + (0.8* _state.value .prevI2);
         _state.value .I1ForOddPrev3 = _state.value .I1ForOddPrev2;
         _state.value .I1ForOddPrev2 = (struct TA_HT_TRENDMODE_HILBERT_STRUCT *) _state.value .detrender.value .var ;
      } else {
         { struct TA_HT_TRENDMODE_HILBERT_STRUCT * ref; ref = (struct TA_HT_TRENDMODE_HILBERT_STRUCT *) _state.value .detrender; hilbertTempReal = _state.value .a * smoothedValue; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = smoothedValue; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_TRENDMODE_HILBERT_STRUCT * ref; ref = (struct TA_HT_TRENDMODE_HILBERT_STRUCT *) _state.value .Q1; hilbertTempReal = _state.value .a * (struct TA_HT_TRENDMODE_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = (struct TA_HT_TRENDMODE_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_TRENDMODE_HILBERT_STRUCT * ref; ref = (struct TA_HT_TRENDMODE_HILBERT_STRUCT *) _state.value .jI; hilbertTempReal = _state.value .a * _state.value .I1ForOddPrev3; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = _state.value .I1ForOddPrev3; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_TRENDMODE_HILBERT_STRUCT * ref; ref = (struct TA_HT_TRENDMODE_HILBERT_STRUCT *) _state.value .jQ; hilbertTempReal = _state.value .a * (struct TA_HT_TRENDMODE_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = (struct TA_HT_TRENDMODE_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         Q2 = (0.2*( (struct TA_HT_TRENDMODE_HILBERT_STRUCT *) _state.value .Q1.value .var + (struct TA_HT_TRENDMODE_HILBERT_STRUCT *) _state.value .jI.value .var )) + (0.8* _state.value .prevQ2);
         I2 = (0.2*( _state.value .I1ForOddPrev3 - (struct TA_HT_TRENDMODE_HILBERT_STRUCT *) _state.value .jQ.value .var )) + (0.8* _state.value .prevI2);
         _state.value .I1ForEvenPrev3 = _state.value .I1ForEvenPrev2;
         _state.value .I1ForEvenPrev2 = (struct TA_HT_TRENDMODE_HILBERT_STRUCT *) _state.value .detrender.value .var ;
      }
      _state.value .Re = (0.2*((I2* _state.value .prevI2)+(Q2* _state.value .prevQ2)))+(0.8* _state.value .Re);
      _state.value .Im = (0.2*((I2* _state.value .prevQ2)-(Q2* _state.value .prevI2)))+(0.8* _state.value .Im);
      _state.value .prevQ2 = Q2;
      _state.value .prevI2 = I2;
      tempReal = _state.value .period;
      if( ( _state.value .Im != 0.0) && ( _state.value .Re != 0.0) )
         _state.value .period = 360.0 / ( Math.atan ( _state.value .Im/ _state.value .Re)* _state.value .rad2Deg);
      tempReal2 = 1.5*tempReal;
      if( _state.value .period > tempReal2)
         _state.value .period = tempReal2;
      tempReal2 = 0.67*tempReal;
      if( _state.value .period < tempReal2 )
         _state.value .period = tempReal2;
      if( _state.value .period < 6 )
         _state.value .period = 6;
      else if( _state.value .period > 50 )
         _state.value .period = 50;
      _state.value .period = (0.2* _state.value .period) + (0.8 * tempReal);
      _state.value .smoothPeriod = (0.33* _state.value .period)+(0.67* _state.value .smoothPeriod);
      _state.value .prevDCPhase = _state.value .DCPhase;
      DCPeriod = _state.value .smoothPeriod+0.5;
      DCPeriodInt = (int)DCPeriod;
      realPart = 0.0;
      imagPart = 0.0;
      idx = ((struct TA_HT_TRENDMODE_STATE_CIRCBUF *) _state.value .circBuf)->idx ;
      for( i=0; i < DCPeriodInt; i++ )
      {
         tempReal = ((double)i* _state.value .constDeg2RadBy360)/(double)DCPeriodInt;
         tempReal2 = (*( ((struct TA_HT_TRENDMODE_STATE_CIRCBUF *) _state.value .circBuf)->circbuf +idx)) ;
         realPart += Math.sin (tempReal)*tempReal2;
         imagPart += Math.cos (tempReal)*tempReal2;
         if( idx == 0 )
            idx = ((struct TA_HT_TRENDMODE_STATE_CIRCBUF *) _state.value .circBuf)->size -1;
         else
            idx--;
      }
      tempReal = Math.abs (imagPart);
      if( tempReal > 0.0 )
         _state.value .DCPhase = Math.atan (realPart/imagPart)* _state.value .rad2Deg;
      else if( tempReal <= 0.01 )
      {
         if( realPart < 0.0 )
            _state.value .DCPhase -= 90.0;
         else if( realPart > 0.0 )
            _state.value .DCPhase += 90.0;
      }
      _state.value .DCPhase += 90.0;
      _state.value .DCPhase += 360.0 / _state.value .smoothPeriod;
      if( imagPart < 0.0 )
         _state.value .DCPhase += 180.0;
      if( _state.value .DCPhase > 315.0 )
         _state.value .DCPhase -= 360.0;
      sine = Math.sin ( _state.value .DCPhase* _state.value .deg2Rad);
      leadSine = Math.sin (( _state.value .DCPhase+45)* _state.value .deg2Rad);
      DCPeriod = _state.value .smoothPeriod+0.5;
      DCPeriodInt = (int)DCPeriod;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      tempReal = 0.0;
      idx = _state.value .mem_index-1;
      for( i=0; i < DCPeriodInt; i++ )
         tempReal += ( _state.value .memory+idx-- % _state.value .mem_size ).value .inReal ;
      if( DCPeriodInt > 0 )
         tempReal = tempReal/(double)DCPeriodInt;
      trendline = (4.0*tempReal + 3.0* _state.value .iTrend1 + 2.0* _state.value .iTrend2 + _state.value .iTrend3) / 10.0;
      _state.value .iTrend3 = _state.value .iTrend2;
      _state.value .iTrend2 = _state.value .iTrend1;
      _state.value .iTrend1 = tempReal;
      trend = 1;
      if( ((sine > leadSine) && ( _state.value .prevSine <= _state.value .prevLeadSine)) ||
         ((sine < leadSine) && ( _state.value .prevSine >= _state.value .prevLeadSine)) )
      {
         _state.value .daysInTrend = 0;
         trend = 0;
      }
      _state.value .prevSine = sine;
      _state.value .prevLeadSine = leadSine;
      _state.value .daysInTrend++;
      if( _state.value .daysInTrend < (0.5* _state.value .smoothPeriod) )
         trend = 0;
      tempReal = _state.value .DCPhase - _state.value .prevDCPhase;
      if( ( _state.value .smoothPeriod != 0.0) &&
         ((tempReal > (0.67*360.0/ _state.value .smoothPeriod)) && (tempReal < (1.5*360.0/ _state.value .smoothPeriod))) )
      {
         trend = 0;
      }
      tempReal = (*( ((struct TA_HT_TRENDMODE_STATE_CIRCBUF *) _state.value .circBuf)->circbuf + ((struct TA_HT_TRENDMODE_STATE_CIRCBUF *) _state.value .circBuf)->idx )) ;
      if( (trendline != 0.0) && ( Math.abs ( (tempReal - trendline)/trendline ) >= 0.015) )
         trend = 1;
      { struct TA_HT_TRENDMODE_STATE_CIRCBUF * buf = (struct TA_HT_TRENDMODE_STATE_CIRCBUF *) _state.value .circBuf; if(buf->idx < buf->size-1) buf->idx++; else buf->idx = 0;} ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      else {
         outInteger.value = trend;
         return RetCode.Success ;
      }
      return RetCode.Success ;
   }
   public RetCode htTrendModeStateFree( struct TA_htTrendMode_State** _state )
   {
      { if ( _state.value .value .detrender != NULL) { free ( _state.value .value .detrender); _state.value .value .detrender = NULL; } } ;
      { if ( _state.value .value .Q1 != NULL) { free ( _state.value .value .Q1); _state.value .value .Q1 = NULL; } } ;
      { if ( _state.value .value .jI != NULL) { free ( _state.value .value .jI); _state.value .value .jI = NULL; } } ;
      { if ( _state.value .value .jQ != NULL) { free ( _state.value .value .jQ); _state.value .value .jQ = NULL; } } ;
      { struct TA_HT_TRENDMODE_STATE_CIRCBUF * buf = (struct TA_HT_TRENDMODE_STATE_CIRCBUF *) _state.value .value .circBuf; if (buf != NULL) { if (buf->circbuf != NULL) free(buf->circbuf); free (buf); _state.value .value .circBuf = NULL; } } ;
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode htTrendModeStateSave( struct TA_htTrendMode_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_HT_TRENDMODE_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .hilbertIdx,sizeof( _state.value .hilbertIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodWMASub,sizeof( _state.value .periodWMASub),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodWMASum,sizeof( _state.value .periodWMASum),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .period,sizeof( _state.value .period),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .I1ForOddPrev2,sizeof( _state.value .I1ForOddPrev2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .I1ForEvenPrev2,sizeof( _state.value .I1ForEvenPrev2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .I1ForOddPrev3,sizeof( _state.value .I1ForOddPrev3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .I1ForEvenPrev3,sizeof( _state.value .I1ForEvenPrev3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevI2,sizeof( _state.value .prevI2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevQ2,sizeof( _state.value .prevQ2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .smoothPeriod,sizeof( _state.value .smoothPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .DCPhase,sizeof( _state.value .DCPhase),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .Im,sizeof( _state.value .Im),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .Re,sizeof( _state.value .Re),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .trailingWMAValue,sizeof( _state.value .trailingWMAValue),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .rad2Deg,sizeof( _state.value .rad2Deg),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .a,sizeof( _state.value .a),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .b,sizeof( _state.value .b),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .constDeg2RadBy360,sizeof( _state.value .constDeg2RadBy360),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .deg2Rad,sizeof( _state.value .deg2Rad),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .iTrend1,sizeof( _state.value .iTrend1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .iTrend2,sizeof( _state.value .iTrend2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .iTrend3,sizeof( _state.value .iTrend3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .daysInTrend,sizeof( _state.value .daysInTrend),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevDCPhase,sizeof( _state.value .prevDCPhase),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevSine,sizeof( _state.value .prevSine),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevLeadSine,sizeof( _state.value .prevLeadSine),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      { if ( _state.value .detrender == NULL) return RetCode.BadParam ; if (fwrite( _state.value .detrender,sizeof(struct TA_HT_TRENDMODE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .Q1 == NULL) return RetCode.BadParam ; if (fwrite( _state.value .Q1,sizeof(struct TA_HT_TRENDMODE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .jI == NULL) return RetCode.BadParam ; if (fwrite( _state.value .jI,sizeof(struct TA_HT_TRENDMODE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .jQ == NULL) return RetCode.BadParam ; if (fwrite( _state.value .jQ,sizeof(struct TA_HT_TRENDMODE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { int io_circbuf_res; struct TA_HT_TRENDMODE_STATE_CIRCBUF * str_circbuf = _state.value .circBuf; io_circbuf_res = fwrite(&str_circbuf->idx,sizeof(str_circbuf->idx),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; io_circbuf_res = fwrite(&str_circbuf->size,sizeof(str_circbuf->size),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; if (str_circbuf->size > 0) { io_circbuf_res = fwrite(str_circbuf->circbuf,sizeof(str_circbuf->circbuf),str_circbuf->size,_file); if (io_circbuf_res < str_circbuf->size) return RetCode.IOFailed ; } }
      return 0;
   }
   public RetCode htTrendModeStateLoad( struct TA_htTrendMode_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct htTrendMode ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_HT_TRENDMODE_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_HT_TRENDMODE_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .hilbertIdx,sizeof( _state.value .value .hilbertIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodWMASub,sizeof( _state.value .value .periodWMASub),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodWMASum,sizeof( _state.value .value .periodWMASum),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .period,sizeof( _state.value .value .period),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .I1ForOddPrev2,sizeof( _state.value .value .I1ForOddPrev2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .I1ForEvenPrev2,sizeof( _state.value .value .I1ForEvenPrev2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .I1ForOddPrev3,sizeof( _state.value .value .I1ForOddPrev3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .I1ForEvenPrev3,sizeof( _state.value .value .I1ForEvenPrev3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevI2,sizeof( _state.value .value .prevI2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevQ2,sizeof( _state.value .value .prevQ2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .smoothPeriod,sizeof( _state.value .value .smoothPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .DCPhase,sizeof( _state.value .value .DCPhase),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .Im,sizeof( _state.value .value .Im),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .Re,sizeof( _state.value .value .Re),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .trailingWMAValue,sizeof( _state.value .value .trailingWMAValue),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .rad2Deg,sizeof( _state.value .value .rad2Deg),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .a,sizeof( _state.value .value .a),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .b,sizeof( _state.value .value .b),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .constDeg2RadBy360,sizeof( _state.value .value .constDeg2RadBy360),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .deg2Rad,sizeof( _state.value .value .deg2Rad),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .iTrend1,sizeof( _state.value .value .iTrend1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .iTrend2,sizeof( _state.value .value .iTrend2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .iTrend3,sizeof( _state.value .value .iTrend3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .daysInTrend,sizeof( _state.value .value .daysInTrend),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevDCPhase,sizeof( _state.value .value .prevDCPhase),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevSine,sizeof( _state.value .value .prevSine),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevLeadSine,sizeof( _state.value .value .prevLeadSine),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      { if ( _state.value .value .detrender != NULL) return RetCode.BadParam ; { _state.value .value .detrender = calloc(1, sizeof(struct TA_HT_TRENDMODE_HILBERT_STRUCT )); if ( _state.value .value .detrender == NULL) return RetCode.AllocErr ; } if (fread( _state.value .value .detrender,sizeof(struct TA_HT_TRENDMODE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .value .Q1 != NULL) return RetCode.BadParam ; { _state.value .value .Q1 = calloc(1, sizeof(struct TA_HT_TRENDMODE_HILBERT_STRUCT )); if ( _state.value .value .Q1 == NULL) return RetCode.AllocErr ; } if (fread( _state.value .value .Q1,sizeof(struct TA_HT_TRENDMODE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .value .jI != NULL) return RetCode.BadParam ; { _state.value .value .jI = calloc(1, sizeof(struct TA_HT_TRENDMODE_HILBERT_STRUCT )); if ( _state.value .value .jI == NULL) return RetCode.AllocErr ; } if (fread( _state.value .value .jI,sizeof(struct TA_HT_TRENDMODE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .value .jQ != NULL) return RetCode.BadParam ; { _state.value .value .jQ = calloc(1, sizeof(struct TA_HT_TRENDMODE_HILBERT_STRUCT )); if ( _state.value .value .jQ == NULL) return RetCode.AllocErr ; } if (fread( _state.value .value .jQ,sizeof(struct TA_HT_TRENDMODE_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { int io_circbuf_res; int circbuf_idx; int circbuf_size; if ( _state.value .value .circBuf != NULL) return RetCode.BadParam ; io_circbuf_res = fread(&circbuf_idx,sizeof(circbuf_idx),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; io_circbuf_res = fread(&circbuf_size,sizeof(circbuf_size),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; { _state.value .value .circBuf = calloc(1, sizeof(struct TA_HT_TRENDMODE_STATE_CIRCBUF )); if ( _state.value .value .circBuf == NULL) return RetCode.AllocErr ; struct TA_HT_TRENDMODE_STATE_CIRCBUF * buf = (struct TA_HT_TRENDMODE_STATE_CIRCBUF *) _state.value .value .circBuf; buf->idx = 0; buf->size = circbuf_size; buf->circbuf = calloc(circbuf_size, sizeof(double)); if (!buf->circbuf) return RetCode.AllocErr ;} struct TA_HT_TRENDMODE_STATE_CIRCBUF * str_circbuf = _state.value .value .circBuf; str_circbuf->idx = circbuf_idx; if (str_circbuf->size > 0) { io_circbuf_res = fread(str_circbuf->circbuf,sizeof(str_circbuf->circbuf),str_circbuf->size,_file); if (io_circbuf_res < str_circbuf->size) return RetCode.IOFailed ; } }
      return 0;
   }
   public RetCode htTrendMode( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      int outIdx, i;
      int lookbackTotal, today;
      double tempReal, tempReal2;
      double adjustedPrevPeriod, period;
      int trailingWMAIdx;
      double periodWMASum, periodWMASub, trailingWMAValue;
      double smoothedValue;
      double iTrend1, iTrend2, iTrend3;
      final double a = 0.0962;
      final double b = 0.5769;
      double hilbertTempReal;
      int hilbertIdx;
      double []detrender_Odd = new double[3] ; double []detrender_Even = new double[3] ; double detrender; double prev_detrender_Odd ; double prev_detrender_Even ; double prev_detrender_input_Odd ; double prev_detrender_input_Even ;
      double []Q1_Odd = new double[3] ; double []Q1_Even = new double[3] ; double Q1; double prev_Q1_Odd ; double prev_Q1_Even ; double prev_Q1_input_Odd ; double prev_Q1_input_Even ;
      double []jI_Odd = new double[3] ; double []jI_Even = new double[3] ; double jI; double prev_jI_Odd ; double prev_jI_Even ; double prev_jI_input_Odd ; double prev_jI_input_Even ;
      double []jQ_Odd = new double[3] ; double []jQ_Even = new double[3] ; double jQ; double prev_jQ_Odd ; double prev_jQ_Even ; double prev_jQ_input_Odd ; double prev_jQ_input_Even ;
      double Q2, I2, prevQ2, prevI2, Re, Im;
      double I1ForOddPrev2, I1ForOddPrev3;
      double I1ForEvenPrev2, I1ForEvenPrev3;
      double rad2Deg, deg2Rad, constDeg2RadBy360;
      double todayValue, smoothPeriod;
      int smoothPrice_Idx = 0; double []smoothPrice; int maxIdx_smoothPrice = ( 50 -1) ;
      int idx;
      int DCPeriodInt;
      double DCPhase, DCPeriod, imagPart, realPart;
      int daysInTrend, trend;
      double prevDCPhase, trendline;
      double prevSine, prevLeadSine, sine, leadSine;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      { smoothPrice = new double[maxIdx_smoothPrice +1]; } ;
      iTrend1 = iTrend2 = iTrend3 = 0.0;
      daysInTrend = 0;
      prevDCPhase = DCPhase = 0.0;
      prevSine = sine = 0.0;
      prevLeadSine = leadSine = 0.0;
      tempReal = Math.atan (1);
      rad2Deg = 45.0/tempReal;
      deg2Rad = 1.0/rad2Deg;
      constDeg2RadBy360 = tempReal*8.0;
      lookbackTotal = 63 + (this.unstablePeriod[FuncUnstId.HtTrendMode.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingWMAIdx = startIdx - lookbackTotal;
      today = trailingWMAIdx;
      tempReal = inReal[today++];
      periodWMASub = tempReal;
      periodWMASum = tempReal;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*2.0;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*3.0;
      trailingWMAValue = 0.0;
      i = 34;
      do
      {
         tempReal = inReal[today++];
         { periodWMASub += tempReal; periodWMASub -= trailingWMAValue; periodWMASum += tempReal*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
      } while( --i != 0);
      hilbertIdx = 0;
      { detrender_Odd [0] = 0.0; detrender_Odd [1] = 0.0; detrender_Odd [2] = 0.0; detrender_Even [0] = 0.0; detrender_Even [1] = 0.0; detrender_Even [2] = 0.0; detrender = 0.0; prev_detrender_Odd = 0.0; prev_detrender_Even = 0.0; prev_detrender_input_Odd = 0.0; prev_detrender_input_Even = 0.0; } ;
      { Q1_Odd [0] = 0.0; Q1_Odd [1] = 0.0; Q1_Odd [2] = 0.0; Q1_Even [0] = 0.0; Q1_Even [1] = 0.0; Q1_Even [2] = 0.0; Q1 = 0.0; prev_Q1_Odd = 0.0; prev_Q1_Even = 0.0; prev_Q1_input_Odd = 0.0; prev_Q1_input_Even = 0.0; } ;
      { jI_Odd [0] = 0.0; jI_Odd [1] = 0.0; jI_Odd [2] = 0.0; jI_Even [0] = 0.0; jI_Even [1] = 0.0; jI_Even [2] = 0.0; jI = 0.0; prev_jI_Odd = 0.0; prev_jI_Even = 0.0; prev_jI_input_Odd = 0.0; prev_jI_input_Even = 0.0; } ;
      { jQ_Odd [0] = 0.0; jQ_Odd [1] = 0.0; jQ_Odd [2] = 0.0; jQ_Even [0] = 0.0; jQ_Even [1] = 0.0; jQ_Even [2] = 0.0; jQ = 0.0; prev_jQ_Odd = 0.0; prev_jQ_Even = 0.0; prev_jQ_input_Odd = 0.0; prev_jQ_input_Even = 0.0; } ;
      period = 0.0;
      outIdx = 0;
      prevI2 = prevQ2 = 0.0;
      Re = Im = 0.0;
      I1ForOddPrev3 = I1ForEvenPrev3 = 0.0;
      I1ForOddPrev2 = I1ForEvenPrev2 = 0.0;
      smoothPeriod = 0.0;
      for( i=0; i < 50 ; i++ )
         smoothPrice[i] = 0.0;
      DCPhase = 0.0;
      while( today <= endIdx )
      {
         adjustedPrevPeriod = (0.075*period)+0.54;
         todayValue = inReal[today];
         { periodWMASub += todayValue; periodWMASub -= trailingWMAValue; periodWMASum += todayValue*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
         smoothPrice[smoothPrice_Idx] = smoothedValue;
         if( (today%2) == 0 )
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Even [hilbertIdx]; detrender_Even [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Even ; prev_detrender_Even = b * prev_detrender_input_Even ; detrender += prev_detrender_Even ; prev_detrender_input_Even = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Even [hilbertIdx]; Q1_Even [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Even ; prev_Q1_Even = b * prev_Q1_input_Even ; Q1 += prev_Q1_Even ; prev_Q1_input_Even = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForEvenPrev3; jI = -jI_Even [hilbertIdx]; jI_Even [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Even ; prev_jI_Even = b * prev_jI_input_Even ; jI += prev_jI_Even ; prev_jI_input_Even = I1ForEvenPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Even [hilbertIdx]; jQ_Even [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Even ; prev_jQ_Even = b * prev_jQ_input_Even ; jQ += prev_jQ_Even ; prev_jQ_input_Even = Q1; jQ *= adjustedPrevPeriod; } ;
            if( ++hilbertIdx == 3 )
               hilbertIdx = 0;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForEvenPrev3 - jQ)) + (0.8*prevI2);
            I1ForOddPrev3 = I1ForOddPrev2;
            I1ForOddPrev2 = detrender;
         }
         else
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Odd [hilbertIdx]; detrender_Odd [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Odd ; prev_detrender_Odd = b * prev_detrender_input_Odd ; detrender += prev_detrender_Odd ; prev_detrender_input_Odd = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Odd [hilbertIdx]; Q1_Odd [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Odd ; prev_Q1_Odd = b * prev_Q1_input_Odd ; Q1 += prev_Q1_Odd ; prev_Q1_input_Odd = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForOddPrev3; jI = -jI_Odd [hilbertIdx]; jI_Odd [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Odd ; prev_jI_Odd = b * prev_jI_input_Odd ; jI += prev_jI_Odd ; prev_jI_input_Odd = I1ForOddPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Odd [hilbertIdx]; jQ_Odd [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Odd ; prev_jQ_Odd = b * prev_jQ_input_Odd ; jQ += prev_jQ_Odd ; prev_jQ_input_Odd = Q1; jQ *= adjustedPrevPeriod; } ;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForOddPrev3 - jQ)) + (0.8*prevI2);
            I1ForEvenPrev3 = I1ForEvenPrev2;
            I1ForEvenPrev2 = detrender;
         }
         Re = (0.2*((I2*prevI2)+(Q2*prevQ2)))+(0.8*Re);
         Im = (0.2*((I2*prevQ2)-(Q2*prevI2)))+(0.8*Im);
         prevQ2 = Q2;
         prevI2 = I2;
         tempReal = period;
         if( (Im != 0.0) && (Re != 0.0) )
            period = 360.0 / ( Math.atan (Im/Re)*rad2Deg);
         tempReal2 = 1.5*tempReal;
         if( period > tempReal2)
            period = tempReal2;
         tempReal2 = 0.67*tempReal;
         if( period < tempReal2 )
            period = tempReal2;
         if( period < 6 )
            period = 6;
         else if( period > 50 )
            period = 50;
         period = (0.2*period) + (0.8 * tempReal);
         smoothPeriod = (0.33*period)+(0.67*smoothPeriod);
         prevDCPhase = DCPhase;
         DCPeriod = smoothPeriod+0.5;
         DCPeriodInt = (int)DCPeriod;
         realPart = 0.0;
         imagPart = 0.0;
         idx = smoothPrice_Idx;
         for( i=0; i < DCPeriodInt; i++ )
         {
            tempReal = ((double)i*constDeg2RadBy360)/(double)DCPeriodInt;
            tempReal2 = smoothPrice[idx];
            realPart += Math.sin (tempReal)*tempReal2;
            imagPart += Math.cos (tempReal)*tempReal2;
            if( idx == 0 )
               idx = 50 -1;
            else
               idx--;
         }
         tempReal = Math.abs (imagPart);
         if( tempReal > 0.0 )
            DCPhase = Math.atan (realPart/imagPart)*rad2Deg;
         else if( tempReal <= 0.01 )
         {
            if( realPart < 0.0 )
               DCPhase -= 90.0;
            else if( realPart > 0.0 )
               DCPhase += 90.0;
         }
         DCPhase += 90.0;
         DCPhase += 360.0 / smoothPeriod;
         if( imagPart < 0.0 )
            DCPhase += 180.0;
         if( DCPhase > 315.0 )
            DCPhase -= 360.0;
         prevSine = sine;
         prevLeadSine = leadSine;
         sine = Math.sin (DCPhase*deg2Rad);
         leadSine = Math.sin ((DCPhase+45)*deg2Rad);
         DCPeriod = smoothPeriod+0.5;
         DCPeriodInt = (int)DCPeriod;
         idx = today;
         tempReal = 0.0;
         for( i=0; i < DCPeriodInt; i++ )
            tempReal += inReal[idx--];
         if( DCPeriodInt > 0 )
            tempReal = tempReal/(double)DCPeriodInt;
         trendline = (4.0*tempReal + 3.0*iTrend1 + 2.0*iTrend2 + iTrend3) / 10.0;
         iTrend3 = iTrend2;
         iTrend2 = iTrend1;
         iTrend1 = tempReal;
         trend = 1;
         if( ((sine > leadSine) && (prevSine <= prevLeadSine)) ||
            ((sine < leadSine) && (prevSine >= prevLeadSine)) )
         {
            daysInTrend = 0;
            trend = 0;
         }
         daysInTrend++;
         if( daysInTrend < (0.5*smoothPeriod) )
            trend = 0;
         tempReal = DCPhase - prevDCPhase;
         if( (smoothPeriod != 0.0) &&
            ((tempReal > (0.67*360.0/smoothPeriod)) && (tempReal < (1.5*360.0/smoothPeriod))) )
         {
            trend = 0;
         }
         tempReal = smoothPrice[smoothPrice_Idx];
         if( (trendline != 0.0) && ( Math.abs ( (tempReal - trendline)/trendline ) >= 0.015) )
            trend = 1;
         if( today >= startIdx )
         {
            outInteger[outIdx++] = trend;
         }
         { smoothPrice_Idx ++; if( smoothPrice_Idx > maxIdx_smoothPrice ) smoothPrice_Idx = 0; } ;
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int imiLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod + (this.unstablePeriod[FuncUnstId.Imi.ordinal()]) - 1;
   }
   public RetCode imi( int startIdx,
      int endIdx,
      double inOpen[],
      double inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int lookback, outIdx = 0;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookback = imiLookback ( optInTimePeriod );
      if(startIdx < lookback)
         startIdx = lookback;
      if( startIdx > endIdx ) {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      while (startIdx <= endIdx) {
         double upsum = .0, downsum = .0;
         int i;
         for (i = startIdx - lookback; i <= startIdx; i++) {
            double close = inClose[i];
            double open = inOpen[i];
            if (close > open) {
               upsum += (close - open);
            } else {
               downsum += (open - close);
            }
            outReal[outIdx] = 100.0*(upsum/(upsum + downsum));
         }
         startIdx++;
         outIdx++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode imiStateInit( struct TA_imi_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct imi ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = imiLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_IMI_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode imiState( struct TA_imi_State* _state,
      double inOpen,
      double inClose,
      double *outReal )
   {
      double tempClose, tempOpen;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
      {
         if (inClose > inOpen) {
            _state.value .upsum += (inClose - inOpen);
         } else {
            _state.value .downsum += (inOpen - inClose);
         }
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ;
      }
      if (inClose > inOpen) {
         _state.value .upsum += (inClose - inOpen);
      } else {
         _state.value .downsum += (inOpen - inClose);
      }
      outReal.value = 100.0*( _state.value .upsum/( _state.value .upsum + _state.value .downsum));
      tempClose = ( _state.value .memory+_cur_idx).value .inClose ;
      tempOpen = ( _state.value .memory+_cur_idx).value .inOpen ;
      if (tempClose > tempOpen) {
         _state.value .upsum -= (tempClose - tempOpen);
      } else {
         _state.value .downsum -= (tempOpen - tempClose);
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      return RetCode.Success ;
   }
   public RetCode imiStateFree( struct TA_imi_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode imiStateSave( struct TA_imi_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_IMI_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .upsum,sizeof( _state.value .upsum),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .downsum,sizeof( _state.value .downsum),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode imiStateLoad( struct TA_imi_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct imi ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_IMI_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_IMI_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .upsum,sizeof( _state.value .value .upsum),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .downsum,sizeof( _state.value .value .downsum),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode imi( int startIdx,
      int endIdx,
      float inOpen[],
      float inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int lookback, outIdx = 0;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookback = imiLookback ( optInTimePeriod );
      if(startIdx < lookback)
         startIdx = lookback;
      if( startIdx > endIdx ) {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      while (startIdx <= endIdx) {
         double upsum = .0, downsum = .0;
         int i;
         for (i = startIdx - lookback; i <= startIdx; i++) {
            double close = inClose[i];
            double open = inOpen[i];
            if (close > open) {
               upsum += (close - open);
            } else {
               downsum += (open - close);
            }
            outReal[outIdx] = 100.0*(upsum/(upsum + downsum));
         }
         startIdx++;
         outIdx++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int kamaLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod + (this.unstablePeriod[FuncUnstId.Kama.ordinal()]) ;
   }
   public RetCode kama( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      final double constMax = 2.0/(30.0+1.0);
      final double constDiff = 2.0/(2.0+1.0) - constMax;
      double tempReal, tempReal2;
      double sumROC1, periodROC, prevKAMA;
      int i, today, outIdx, lookbackTotal;
      int trailingIdx;
      double trailingValue;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      lookbackTotal = optInTimePeriod + (this.unstablePeriod[FuncUnstId.Kama.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      sumROC1 = 0.0;
      today = startIdx-lookbackTotal;
      trailingIdx = today;
      i = optInTimePeriod;
      while( i-- > 0 )
      {
         tempReal = inReal[today++];
         tempReal -= inReal[today];
         sumROC1 += Math.abs (tempReal);
      }
      prevKAMA = inReal[today-1];
      tempReal = inReal[today];
      tempReal2 = inReal[trailingIdx++];
      periodROC = tempReal-tempReal2;
      trailingValue = tempReal2;
      if( (sumROC1 <= periodROC) || (((- (0.00000000000001) )<sumROC1)&&(sumROC1< (0.00000000000001) )) )
         tempReal = 1.0;
      else
         tempReal = Math.abs (periodROC/sumROC1);
      tempReal = (tempReal*constDiff)+constMax;
      tempReal *= tempReal;
      prevKAMA = ((inReal[today++]-prevKAMA)*tempReal) + prevKAMA;
      while( today <= startIdx )
      {
         tempReal = inReal[today];
         tempReal2 = inReal[trailingIdx++];
         periodROC = tempReal-tempReal2;
         sumROC1 -= Math.abs (trailingValue-tempReal2);
         sumROC1 += Math.abs (tempReal-inReal[today-1]);
         trailingValue = tempReal2;
         if( (sumROC1 <= periodROC) || (((- (0.00000000000001) )<sumROC1)&&(sumROC1< (0.00000000000001) )) )
            tempReal = 1.0;
         else
            tempReal = Math.abs (periodROC/sumROC1);
         tempReal = (tempReal*constDiff)+constMax;
         tempReal *= tempReal;
         prevKAMA = ((inReal[today++]-prevKAMA)*tempReal) + prevKAMA;
      }
      outReal[0] = prevKAMA;
      outIdx = 1;
      outBegIdx.value = today-1;
      while( today <= endIdx )
      {
         tempReal = inReal[today];
         tempReal2 = inReal[trailingIdx++];
         periodROC = tempReal-tempReal2;
         sumROC1 -= Math.abs (trailingValue-tempReal2);
         sumROC1 += Math.abs (tempReal-inReal[today-1]);
         trailingValue = tempReal2;
         if( (sumROC1 <= periodROC) || (((- (0.00000000000001) )<sumROC1)&&(sumROC1< (0.00000000000001) )) )
            tempReal = 1.0;
         else
            tempReal = Math.abs (periodROC / sumROC1);
         tempReal = (tempReal*constDiff)+constMax;
         tempReal *= tempReal;
         prevKAMA = ((inReal[today++]-prevKAMA)*tempReal) + prevKAMA;
         outReal[outIdx++] = prevKAMA;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode kamaStateInit( struct TA_kama_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct kama ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = kamaLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_KAMA_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode kamaState( struct TA_kama_State* _state,
      double inReal,
      double *outReal )
   {
      final double constMax = 2.0/(30.0+1.0);
      final double constDiff = 2.0/(2.0+1.0) - constMax;
      double tempReal;
      double periodROC;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .sumROC1 = 0.0;
         _state.value .trailingValue = 0.0;
         _state.value .yestReal = inReal;
         _state.value .prevKAMA = inReal;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      } else
         if ( ((int) _state.value .mem_index-1) <= _state.value .optInTimePeriod)
      {
         _state.value .sumROC1 += Math.abs ( _state.value .yestReal - inReal);
         _state.value .yestReal = inReal;
         if (((int) _state.value .mem_index-1) < _state.value .optInTimePeriod)
         {
            _state.value .prevKAMA = inReal;
            ( _state.value .memory+_cur_idx).value .inReal = inReal ;
            return RetCode.NeedMoreData ;
         }
      }
      if (((int) _state.value .mem_index-1) > _state.value .optInTimePeriod)
      {
         _state.value .sumROC1 -= Math.abs ( _state.value .trailingValue- ( _state.value .memory+_cur_idx).value .inReal );
         _state.value .sumROC1 += Math.abs (inReal- _state.value .yestReal);
      }
      _state.value .trailingValue = ( _state.value .memory+_cur_idx).value .inReal ;
      periodROC = inReal - _state.value .trailingValue;
      if( ( _state.value .sumROC1 <= periodROC) || (((- (0.00000000000001) )< _state.value .sumROC1)&&( _state.value .sumROC1< (0.00000000000001) )) )
         tempReal = 1.0;
      else
         tempReal = Math.abs (periodROC/ _state.value .sumROC1);
      tempReal = (tempReal*constDiff)+constMax;
      tempReal *= tempReal;
      _state.value .prevKAMA = ((inReal- _state.value .prevKAMA)*tempReal) + _state.value .prevKAMA;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      _state.value .yestReal = inReal;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      outReal.value = _state.value .prevKAMA;
      return RetCode.Success ;
   }
   public RetCode kamaStateFree( struct TA_kama_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode kamaStateSave( struct TA_kama_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_KAMA_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .sumROC1,sizeof( _state.value .sumROC1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .yestReal,sizeof( _state.value .yestReal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevKAMA,sizeof( _state.value .prevKAMA),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .trailingValue,sizeof( _state.value .trailingValue),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode kamaStateLoad( struct TA_kama_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct kama ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_KAMA_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_KAMA_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .sumROC1,sizeof( _state.value .value .sumROC1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .yestReal,sizeof( _state.value .value .yestReal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevKAMA,sizeof( _state.value .value .prevKAMA),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .trailingValue,sizeof( _state.value .value .trailingValue),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode kama( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      final double constMax = 2.0/(30.0+1.0);
      final double constDiff = 2.0/(2.0+1.0) - constMax;
      double tempReal, tempReal2;
      double sumROC1, periodROC, prevKAMA;
      int i, today, outIdx, lookbackTotal;
      int trailingIdx;
      double trailingValue;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      lookbackTotal = optInTimePeriod + (this.unstablePeriod[FuncUnstId.Kama.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      sumROC1 = 0.0;
      today = startIdx-lookbackTotal;
      trailingIdx = today;
      i = optInTimePeriod;
      while( i-- > 0 )
      {
         tempReal = inReal[today++];
         tempReal -= inReal[today];
         sumROC1 += Math.abs (tempReal);
      }
      prevKAMA = inReal[today-1];
      tempReal = inReal[today];
      tempReal2 = inReal[trailingIdx++];
      periodROC = tempReal-tempReal2;
      trailingValue = tempReal2;
      if( (sumROC1 <= periodROC) || (((- (0.00000000000001) )<sumROC1)&&(sumROC1< (0.00000000000001) )) )
         tempReal = 1.0;
      else
         tempReal = Math.abs (periodROC/sumROC1);
      tempReal = (tempReal*constDiff)+constMax;
      tempReal *= tempReal;
      prevKAMA = ((inReal[today++]-prevKAMA)*tempReal) + prevKAMA;
      while( today <= startIdx )
      {
         tempReal = inReal[today];
         tempReal2 = inReal[trailingIdx++];
         periodROC = tempReal-tempReal2;
         sumROC1 -= Math.abs (trailingValue-tempReal2);
         sumROC1 += Math.abs (tempReal-inReal[today-1]);
         trailingValue = tempReal2;
         if( (sumROC1 <= periodROC) || (((- (0.00000000000001) )<sumROC1)&&(sumROC1< (0.00000000000001) )) )
            tempReal = 1.0;
         else
            tempReal = Math.abs (periodROC/sumROC1);
         tempReal = (tempReal*constDiff)+constMax;
         tempReal *= tempReal;
         prevKAMA = ((inReal[today++]-prevKAMA)*tempReal) + prevKAMA;
      }
      outReal[0] = prevKAMA;
      outIdx = 1;
      outBegIdx.value = today-1;
      while( today <= endIdx )
      {
         tempReal = inReal[today];
         tempReal2 = inReal[trailingIdx++];
         periodROC = tempReal-tempReal2;
         sumROC1 -= Math.abs (trailingValue-tempReal2);
         sumROC1 += Math.abs (tempReal-inReal[today-1]);
         trailingValue = tempReal2;
         if( (sumROC1 <= periodROC) || (((- (0.00000000000001) )<sumROC1)&&(sumROC1< (0.00000000000001) )) )
            tempReal = 1.0;
         else
            tempReal = Math.abs (periodROC / sumROC1);
         tempReal = (tempReal*constDiff)+constMax;
         tempReal *= tempReal;
         prevKAMA = ((inReal[today++]-prevKAMA)*tempReal) + prevKAMA;
         outReal[outIdx++] = prevKAMA;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int linearRegLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod-1;
   }
   public RetCode linearReg( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int today, lookbackTotal;
      double SumX, SumXY, SumY, SumXSqr, Divisor;
      double m, b;
      int i;
      double tempValue1;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = linearRegLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      SumX = optInTimePeriod * ( optInTimePeriod - 1 ) * 0.5;
      SumXSqr = optInTimePeriod * ( optInTimePeriod - 1 ) * ( 2 * optInTimePeriod - 1 ) / 6;
      Divisor = SumX * SumX - optInTimePeriod * SumXSqr;
      while( today <= endIdx )
      {
         SumXY = 0;
         SumY = 0;
         for( i = optInTimePeriod; i-- != 0; )
         {
            SumY += tempValue1 = inReal[today - i];
            SumXY += (double)i * tempValue1;
         }
         m = ( optInTimePeriod * SumXY - SumX * SumY) / Divisor;
         b = ( SumY - m * SumX ) / (double)optInTimePeriod;
         outReal[outIdx++] = b + m * (double)(optInTimePeriod-1);
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode linearRegStateInit( struct TA_linearReg_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct linearReg ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = linearRegLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_LINEARREG_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode linearRegState( struct TA_linearReg_State* _state,
      double inReal,
      double *outReal )
   {
      double m, b, tempReal;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .SumX = _state.value .optInTimePeriod * ( _state.value .optInTimePeriod - 1 ) * 0.5;
         _state.value .SumXSqr = _state.value .optInTimePeriod * ( _state.value .optInTimePeriod - 1 ) * ( 2 * _state.value .optInTimePeriod - 1 ) / 6;
         _state.value .Divisor = _state.value .SumX * _state.value .SumX - _state.value .optInTimePeriod * _state.value .SumXSqr;
         _state.value .SumXY = 0;
         _state.value .SumY = 0;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
      {
         _state.value .SumY += inReal;
         _state.value .SumXY += _state.value .SumY;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      }
      _state.value .SumY += inReal;
      _state.value .SumXY += _state.value .SumY;
      m = ( _state.value .optInTimePeriod * _state.value .SumXY - _state.value .SumX * _state.value .SumY) / _state.value .Divisor;
      b = ( _state.value .SumY - m * _state.value .SumX ) / (double) _state.value .optInTimePeriod;
      outReal.value = b + m * (double)( _state.value .optInTimePeriod-1);
      tempReal = ( _state.value .memory+_cur_idx).value .inReal ;
      _state.value .SumY -= tempReal;
      _state.value .SumXY -= tempReal* _state.value .optInTimePeriod;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      return RetCode.Success ;
   }
   public RetCode linearRegStateFree( struct TA_linearReg_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode linearRegStateSave( struct TA_linearReg_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_LINEARREG_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .SumX,sizeof( _state.value .SumX),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .SumXY,sizeof( _state.value .SumXY),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .SumY,sizeof( _state.value .SumY),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .SumXSqr,sizeof( _state.value .SumXSqr),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .Divisor,sizeof( _state.value .Divisor),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode linearRegStateLoad( struct TA_linearReg_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct linearReg ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_LINEARREG_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_LINEARREG_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .SumX,sizeof( _state.value .value .SumX),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .SumXY,sizeof( _state.value .value .SumXY),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .SumY,sizeof( _state.value .value .SumY),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .SumXSqr,sizeof( _state.value .value .SumXSqr),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .Divisor,sizeof( _state.value .value .Divisor),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode linearReg( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int today, lookbackTotal;
      double SumX, SumXY, SumY, SumXSqr, Divisor;
      double m, b;
      int i;
      double tempValue1;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = linearRegLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      SumX = optInTimePeriod * ( optInTimePeriod - 1 ) * 0.5;
      SumXSqr = optInTimePeriod * ( optInTimePeriod - 1 ) * ( 2 * optInTimePeriod - 1 ) / 6;
      Divisor = SumX * SumX - optInTimePeriod * SumXSqr;
      while( today <= endIdx )
      {
         SumXY = 0;
         SumY = 0;
         for( i = optInTimePeriod; i-- != 0; )
         {
            SumY += tempValue1 = inReal[today - i];
            SumXY += (double)i * tempValue1;
         }
         m = ( optInTimePeriod * SumXY - SumX * SumY) / Divisor;
         b = ( SumY - m * SumX ) / (double)optInTimePeriod;
         outReal[outIdx++] = b + m * (double)(optInTimePeriod-1);
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int linearRegAngleLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod-1;
   }
   public RetCode linearRegAngle( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int today, lookbackTotal;
      double SumX, SumXY, SumY, SumXSqr, Divisor;
      double m;
      int i;
      double tempValue1;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = linearRegAngleLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      SumX = optInTimePeriod * ( optInTimePeriod - 1 ) * 0.5;
      SumXSqr = optInTimePeriod * ( optInTimePeriod - 1 ) * ( 2 * optInTimePeriod - 1 ) / 6;
      Divisor = SumX * SumX - optInTimePeriod * SumXSqr;
      while( today <= endIdx )
      {
         SumXY = 0;
         SumY = 0;
         for( i = optInTimePeriod; i-- != 0; )
         {
            SumY += tempValue1 = inReal[today - i];
            SumXY += (double)i * tempValue1;
         }
         m = ( optInTimePeriod * SumXY - SumX * SumY) / Divisor;
         outReal[outIdx++] = Math.atan (m) * ( 180.0 / 3.14159265358979323846 );
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode linearRegAngleStateInit( struct TA_linearRegAngle_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct linearRegAngle ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = linearRegAngleLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_LINEARREG_ANGLE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode linearRegAngleState( struct TA_linearRegAngle_State* _state,
      double inReal,
      double *outReal )
   {
      double m, tempReal;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .SumX = _state.value .optInTimePeriod * ( _state.value .optInTimePeriod - 1 ) * 0.5;
         _state.value .SumXSqr = _state.value .optInTimePeriod * ( _state.value .optInTimePeriod - 1 ) * ( 2 * _state.value .optInTimePeriod - 1 ) / 6;
         _state.value .Divisor = _state.value .SumX * _state.value .SumX - _state.value .optInTimePeriod * _state.value .SumXSqr;
         _state.value .SumXY = 0;
         _state.value .SumY = 0;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
      {
         _state.value .SumY += inReal;
         _state.value .SumXY += _state.value .SumY;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      }
      _state.value .SumY += inReal;
      _state.value .SumXY += _state.value .SumY;
      m = ( _state.value .optInTimePeriod * _state.value .SumXY - _state.value .SumX * _state.value .SumY) / _state.value .Divisor;
      outReal.value = Math.atan (m) * ( 180.0 / 3.14159265358979323846 );
      tempReal = ( _state.value .memory+_cur_idx).value .inReal ;
      _state.value .SumY -= tempReal;
      _state.value .SumXY -= tempReal* _state.value .optInTimePeriod;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      return RetCode.Success ;
   }
   public RetCode linearRegAngleStateFree( struct TA_linearRegAngle_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode linearRegAngleStateSave( struct TA_linearRegAngle_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_LINEARREG_ANGLE_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .SumX,sizeof( _state.value .SumX),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .SumXY,sizeof( _state.value .SumXY),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .SumY,sizeof( _state.value .SumY),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .SumXSqr,sizeof( _state.value .SumXSqr),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .Divisor,sizeof( _state.value .Divisor),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode linearRegAngleStateLoad( struct TA_linearRegAngle_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct linearRegAngle ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_LINEARREG_ANGLE_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_LINEARREG_ANGLE_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .SumX,sizeof( _state.value .value .SumX),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .SumXY,sizeof( _state.value .value .SumXY),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .SumY,sizeof( _state.value .value .SumY),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .SumXSqr,sizeof( _state.value .value .SumXSqr),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .Divisor,sizeof( _state.value .value .Divisor),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode linearRegAngle( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int today, lookbackTotal;
      double SumX, SumXY, SumY, SumXSqr, Divisor;
      double m;
      int i;
      double tempValue1;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = linearRegAngleLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      SumX = optInTimePeriod * ( optInTimePeriod - 1 ) * 0.5;
      SumXSqr = optInTimePeriod * ( optInTimePeriod - 1 ) * ( 2 * optInTimePeriod - 1 ) / 6;
      Divisor = SumX * SumX - optInTimePeriod * SumXSqr;
      while( today <= endIdx )
      {
         SumXY = 0;
         SumY = 0;
         for( i = optInTimePeriod; i-- != 0; )
         {
            SumY += tempValue1 = inReal[today - i];
            SumXY += (double)i * tempValue1;
         }
         m = ( optInTimePeriod * SumXY - SumX * SumY) / Divisor;
         outReal[outIdx++] = Math.atan (m) * ( 180.0 / 3.14159265358979323846 );
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int linearRegInterceptLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod-1;
   }
   public RetCode linearRegIntercept( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int today, lookbackTotal;
      double SumX, SumXY, SumY, SumXSqr, Divisor;
      double m;
      int i;
      double tempValue1;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = linearRegInterceptLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      SumX = optInTimePeriod * ( optInTimePeriod - 1 ) * 0.5;
      SumXSqr = optInTimePeriod * ( optInTimePeriod - 1 ) * ( 2 * optInTimePeriod - 1 ) / 6;
      Divisor = SumX * SumX - optInTimePeriod * SumXSqr;
      while( today <= endIdx )
      {
         SumXY = 0;
         SumY = 0;
         for( i = optInTimePeriod; i-- != 0; )
         {
            SumY += tempValue1 = inReal[today - i];
            SumXY += (double)i * tempValue1;
         }
         m = ( optInTimePeriod * SumXY - SumX * SumY) / Divisor;
         outReal[outIdx++] = ( SumY - m * SumX ) / (double)optInTimePeriod;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode linearRegInterceptStateInit( struct TA_linearRegIntercept_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct linearRegIntercept ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = linearRegInterceptLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_LINEARREG_INTERCEPT_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode linearRegInterceptState( struct TA_linearRegIntercept_State* _state,
      double inReal,
      double *outReal )
   {
      double m, tempReal;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .SumX = _state.value .optInTimePeriod * ( _state.value .optInTimePeriod - 1 ) * 0.5;
         _state.value .SumXSqr = _state.value .optInTimePeriod * ( _state.value .optInTimePeriod - 1 ) * ( 2 * _state.value .optInTimePeriod - 1 ) / 6;
         _state.value .Divisor = _state.value .SumX * _state.value .SumX - _state.value .optInTimePeriod * _state.value .SumXSqr;
         _state.value .SumXY = 0;
         _state.value .SumY = 0;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
      {
         _state.value .SumY += inReal;
         _state.value .SumXY += _state.value .SumY;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      }
      _state.value .SumY += inReal;
      _state.value .SumXY += _state.value .SumY;
      m = ( _state.value .optInTimePeriod * _state.value .SumXY - _state.value .SumX * _state.value .SumY) / _state.value .Divisor;
      outReal.value = ( _state.value .SumY - m * _state.value .SumX ) / (double) _state.value .optInTimePeriod;
      tempReal = ( _state.value .memory+_cur_idx).value .inReal ;
      _state.value .SumY -= tempReal;
      _state.value .SumXY -= tempReal* _state.value .optInTimePeriod;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      return RetCode.Success ;
   }
   public RetCode linearRegInterceptStateFree( struct TA_linearRegIntercept_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode linearRegInterceptStateSave( struct TA_linearRegIntercept_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_LINEARREG_INTERCEPT_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .SumX,sizeof( _state.value .SumX),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .SumXY,sizeof( _state.value .SumXY),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .SumY,sizeof( _state.value .SumY),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .SumXSqr,sizeof( _state.value .SumXSqr),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .Divisor,sizeof( _state.value .Divisor),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode linearRegInterceptStateLoad( struct TA_linearRegIntercept_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct linearRegIntercept ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_LINEARREG_INTERCEPT_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_LINEARREG_INTERCEPT_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .SumX,sizeof( _state.value .value .SumX),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .SumXY,sizeof( _state.value .value .SumXY),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .SumY,sizeof( _state.value .value .SumY),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .SumXSqr,sizeof( _state.value .value .SumXSqr),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .Divisor,sizeof( _state.value .value .Divisor),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode linearRegIntercept( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int today, lookbackTotal;
      double SumX, SumXY, SumY, SumXSqr, Divisor;
      double m;
      int i;
      double tempValue1;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = linearRegInterceptLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      SumX = optInTimePeriod * ( optInTimePeriod - 1 ) * 0.5;
      SumXSqr = optInTimePeriod * ( optInTimePeriod - 1 ) * ( 2 * optInTimePeriod - 1 ) / 6;
      Divisor = SumX * SumX - optInTimePeriod * SumXSqr;
      while( today <= endIdx )
      {
         SumXY = 0;
         SumY = 0;
         for( i = optInTimePeriod; i-- != 0; )
         {
            SumY += tempValue1 = inReal[today - i];
            SumXY += (double)i * tempValue1;
         }
         m = ( optInTimePeriod * SumXY - SumX * SumY) / Divisor;
         outReal[outIdx++] = ( SumY - m * SumX ) / (double)optInTimePeriod;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int linearRegSlopeLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod-1;
   }
   public RetCode linearRegSlope( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int today, lookbackTotal;
      double SumX, SumXY, SumY, SumXSqr, Divisor;
      int i;
      double tempValue1;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = linearRegSlopeLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      SumX = optInTimePeriod * ( optInTimePeriod - 1 ) * 0.5;
      SumXSqr = optInTimePeriod * ( optInTimePeriod - 1 ) * ( 2 * optInTimePeriod - 1 ) / 6;
      Divisor = SumX * SumX - optInTimePeriod * SumXSqr;
      while( today <= endIdx )
      {
         SumXY = 0;
         SumY = 0;
         for( i = optInTimePeriod; i-- != 0; )
         {
            SumY += tempValue1 = inReal[today - i];
            SumXY += (double)i * tempValue1;
         }
         outReal[outIdx++] = ( optInTimePeriod * SumXY - SumX * SumY) / Divisor;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode linearRegSlopeStateInit( struct TA_linearRegSlope_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct linearRegSlope ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = linearRegSlopeLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_LINEARREG_SLOPE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode linearRegSlopeState( struct TA_linearRegSlope_State* _state,
      double inReal,
      double *outReal )
   {
      double tempReal;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .SumX = _state.value .optInTimePeriod * ( _state.value .optInTimePeriod - 1 ) * 0.5;
         _state.value .SumXSqr = _state.value .optInTimePeriod * ( _state.value .optInTimePeriod - 1 ) * ( 2 * _state.value .optInTimePeriod - 1 ) / 6;
         _state.value .Divisor = _state.value .SumX * _state.value .SumX - _state.value .optInTimePeriod * _state.value .SumXSqr;
         _state.value .SumXY = 0;
         _state.value .SumY = 0;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
      {
         _state.value .SumY += inReal;
         _state.value .SumXY += _state.value .SumY;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      }
      _state.value .SumY += inReal;
      _state.value .SumXY += _state.value .SumY;
      outReal.value = ( _state.value .optInTimePeriod * _state.value .SumXY - _state.value .SumX * _state.value .SumY) / _state.value .Divisor;
      tempReal = ( _state.value .memory+_cur_idx).value .inReal ;
      _state.value .SumY -= tempReal;
      _state.value .SumXY -= tempReal* _state.value .optInTimePeriod;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      return RetCode.Success ;
   }
   public RetCode linearRegSlopeStateFree( struct TA_linearRegSlope_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode linearRegSlopeStateSave( struct TA_linearRegSlope_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_LINEARREG_SLOPE_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .SumX,sizeof( _state.value .SumX),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .SumXY,sizeof( _state.value .SumXY),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .SumY,sizeof( _state.value .SumY),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .SumXSqr,sizeof( _state.value .SumXSqr),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .Divisor,sizeof( _state.value .Divisor),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode linearRegSlopeStateLoad( struct TA_linearRegSlope_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct linearRegSlope ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_LINEARREG_SLOPE_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_LINEARREG_SLOPE_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .SumX,sizeof( _state.value .value .SumX),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .SumXY,sizeof( _state.value .value .SumXY),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .SumY,sizeof( _state.value .value .SumY),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .SumXSqr,sizeof( _state.value .value .SumXSqr),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .Divisor,sizeof( _state.value .value .Divisor),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode linearRegSlope( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int today, lookbackTotal;
      double SumX, SumXY, SumY, SumXSqr, Divisor;
      int i;
      double tempValue1;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = linearRegSlopeLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      SumX = optInTimePeriod * ( optInTimePeriod - 1 ) * 0.5;
      SumXSqr = optInTimePeriod * ( optInTimePeriod - 1 ) * ( 2 * optInTimePeriod - 1 ) / 6;
      Divisor = SumX * SumX - optInTimePeriod * SumXSqr;
      while( today <= endIdx )
      {
         SumXY = 0;
         SumY = 0;
         for( i = optInTimePeriod; i-- != 0; )
         {
            SumY += tempValue1 = inReal[today - i];
            SumXY += (double)i * tempValue1;
         }
         outReal[outIdx++] = ( optInTimePeriod * SumXY - SumX * SumY) / Divisor;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int lnLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode ln( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.log (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode lnStateInit( struct TA_ln_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct ln ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = lnLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_LN_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode lnState( struct TA_ln_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.log (inReal);
      return RetCode.Success ;
   }
   public RetCode lnStateFree( struct TA_ln_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode lnStateSave( struct TA_ln_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_LN_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode lnStateLoad( struct TA_ln_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct ln ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_LN_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_LN_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode ln( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.log (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int log10Lookback( )
   {
      return RetCode.Success ;
   }
   public RetCode log10( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.log10 (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode log10StateInit( struct TA_log10_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct log10 ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = log10Lookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_LOG10_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode log10State( struct TA_log10_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.log10 (inReal);
      return RetCode.Success ;
   }
   public RetCode log10StateFree( struct TA_log10_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode log10StateSave( struct TA_log10_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_LOG10_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode log10StateLoad( struct TA_log10_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct log10 ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_LOG10_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_LOG10_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode log10( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.log10 (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int movingAverageLookback( int optInTimePeriod,
      MAType optInMAType )
   {
      int retValue;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      if( optInTimePeriod <= 1 )
         return RetCode.Success ;
      switch( optInMAType )
      {
         case Sma :
            retValue = smaLookback ( optInTimePeriod );
         break;
         case Ema :
            retValue = emaLookback ( optInTimePeriod );
         break;
         case Wma :
            retValue = wmaLookback ( optInTimePeriod );
         break;
         case Dema :
            retValue = demaLookback ( optInTimePeriod );
         break;
         case Tema :
            retValue = temaLookback ( optInTimePeriod );
         break;
         case Trima :
            retValue = trimaLookback ( optInTimePeriod );
         break;
         case Kama :
            retValue = kamaLookback ( optInTimePeriod );
         break;
         case Mama :
            retValue = mamaLookback ( 0.5, 0.05 );
         break;
         case T3 :
            retValue = t3Lookback ( optInTimePeriod, 0.7 );
         break;
         default:
            retValue = 0;
      }
      return retValue;
   }
   public RetCode movingAverage( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MAType optInMAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double []dummyBuffer ;
      RetCode retCode;
      int nbElement;
      int outIdx, todayIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInTimePeriod == 1 )
      {
         nbElement = endIdx-startIdx+1;
         outNBElement.value = nbElement;
         for( todayIdx=startIdx, outIdx=0; outIdx < nbElement; outIdx++, todayIdx++ )
            outReal[outIdx] = inReal[todayIdx];
         outBegIdx.value = startIdx;
         return RetCode.Success ;
      }
      switch( optInMAType )
      {
         case Sma :
            retCode = sma ( startIdx, endIdx, inReal, optInTimePeriod,
            outBegIdx, outNBElement, outReal );
         break;
         case Ema :
            retCode = ema ( startIdx, endIdx, inReal, optInTimePeriod,
            outBegIdx, outNBElement, outReal );
         break;
         case Wma :
            retCode = wma ( startIdx, endIdx, inReal, optInTimePeriod,
            outBegIdx, outNBElement, outReal );
         break;
         case Dema :
            retCode = dema ( startIdx, endIdx, inReal, optInTimePeriod,
            outBegIdx, outNBElement, outReal );
         break;
         case Tema :
            retCode = tema ( startIdx, endIdx, inReal, optInTimePeriod,
            outBegIdx, outNBElement, outReal );
         break;
         case Trima :
            retCode = trima ( startIdx, endIdx, inReal, optInTimePeriod,
            outBegIdx, outNBElement, outReal );
         break;
         case Kama :
            retCode = kama ( startIdx, endIdx, inReal, optInTimePeriod,
            outBegIdx, outNBElement, outReal );
         break;
         case Mama :
            dummyBuffer = new double[(endIdx-startIdx+1)] ;
         retCode = mama ( startIdx, endIdx, inReal, 0.5, 0.05,
            outBegIdx, outNBElement,
            outReal, dummyBuffer );
         break;
         case T3 :
            retCode = t3 ( startIdx, endIdx, inReal,
            optInTimePeriod, 0.7,
            outBegIdx, outNBElement, outReal );
         break;
         default:
            retCode = RetCode.BadParam ;
         break;
      }
      return retCode;
   }
   public RetCode movingAverageStateInit( struct TA_movingAverage_State** _state,
      int optInTimePeriod,
      MAType optInMAType )
   {
      RetCode retValue;
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct movingAverage ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .optInMAType = optInMAType;
      _state.value .value .mem_size = movingAverageLookback (optInTimePeriod, optInMAType );
      _state.value .value .memory = NULL;
      if( optInTimePeriod == 1 )
      {
         _state.value .value .ta_state = NULL;
         return RetCode.Success ;
      }
      switch( optInMAType )
      {
         case Sma :
            retValue = sma ( (struct sma **) & _state.value .value .ta_state, optInTimePeriod );
         break;
         case Ema :
            retValue = ema ( (struct ema **) & _state.value .value .ta_state, optInTimePeriod );
         break;
         case Wma :
            retValue = wma ( (struct wma **) & _state.value .value .ta_state, optInTimePeriod );
         break;
         case Dema :
            retValue = dema ( (struct dema **) & _state.value .value .ta_state, optInTimePeriod );
         break;
         case Tema :
            retValue = tema ( (struct tema **) & _state.value .value .ta_state, optInTimePeriod );
         break;
         case Trima :
            retValue = trima ( (struct trima **) & _state.value .value .ta_state, optInTimePeriod );
         break;
         case Kama :
            retValue = kama ( (struct kama **) & _state.value .value .ta_state, optInTimePeriod );
         break;
         case Mama :
            retValue = mama ( (struct mama **) & _state.value .value .ta_state, 0.5, 0.05 );
         break;
         case T3 :
            retValue = t3 ( (struct t3 **) & _state.value .value .ta_state, optInTimePeriod, 0.7 );
         break;
         default:
            retValue = RetCode.BadParam ;
      }
      return retValue;
   }
   public RetCode movingAverageState( struct TA_movingAverage_State* _state,
      double inReal,
      double *outReal )
   {
      RetCode retValue;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if( _state.value .optInTimePeriod == 1 )
      {
         outReal.value = inReal;
         return RetCode.Success ;
      }
      switch( _state.value .optInMAType )
      {
         case Sma :
            retValue = sma ( (struct sma *) _state.value .ta_state, inReal, outReal );
         break;
         case Ema :
            retValue = ema ( (struct ema *) _state.value .ta_state, inReal, outReal );
         break;
         case Wma :
            retValue = wma ( (struct wma *) _state.value .ta_state, inReal, outReal );
         break;
         case Dema :
            retValue = dema ( (struct dema *) _state.value .ta_state, inReal, outReal );
         break;
         case Tema :
            retValue = tema ( (struct tema *) _state.value .ta_state, inReal, outReal );
         break;
         case Trima :
            retValue = trima ( (struct trima *) _state.value .ta_state, inReal, outReal );
         break;
         case Kama :
            retValue = kama ( (struct kama *) _state.value .ta_state, inReal, outReal );
         break;
         case Mama :
         {
            double dummy;
            retValue = mama ( (struct mama *) _state.value .ta_state, inReal, outReal, &dummy );
         }
         break;
         case T3 :
            retValue = t3 ( (struct t3 *) _state.value .ta_state, inReal, outReal );
         break;
         default:
            retValue = RetCode.BadParam ;
      }
      return retValue;
   }
   public RetCode movingAverageStateFree( struct TA_movingAverage_State** _state )
   {
      RetCode retValue;
      if( _state.value .value .optInTimePeriod != 1 )
      {
         switch( _state.value .value .optInMAType )
         {
            case Sma :
               retValue = sma ( (struct sma **) & _state.value .value .ta_state);
            break;
            case Ema :
               retValue = ema ( (struct ema **) & _state.value .value .ta_state);
            break;
            case Wma :
               retValue = wma ( (struct wma **) & _state.value .value .ta_state);
            break;
            case Dema :
               retValue = dema ( (struct dema **) & _state.value .value .ta_state);
            break;
            case Tema :
               retValue = tema ( (struct tema **) & _state.value .value .ta_state);
            break;
            case Trima :
               retValue = trima ( (struct trima **) & _state.value .value .ta_state);
            break;
            case Kama :
               retValue = kama ( (struct kama **) & _state.value .value .ta_state);
            break;
            case Mama :
               retValue = mama ( (struct mama **) & _state.value .value .ta_state);
            break;
            case T3 :
               retValue = t3 ( (struct t3 **) & _state.value .value .ta_state);
            break;
            default:
               retValue = RetCode.BadParam ;
         }
      }
      if (retValue != RetCode.Success )
         return retValue;
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode movingAverageStateSave( struct TA_movingAverage_State* _state,
      FILE* _file )
   {
      RetCode retValue;
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_MA_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInMAType,sizeof( _state.value .optInMAType),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      {
         switch( _state.value .optInMAType )
         {
            case Sma :
               retValue = TA_SMA_StateSave ( (struct sma *) _state.value .ta_state, _file);
            break;
            case Ema :
               retValue = TA_EMA_StateSave ( (struct ema *) _state.value .ta_state, _file);
            break;
            case Wma :
               retValue = TA_WMA_StateSave ( (struct wma *) _state.value .ta_state, _file);
            break;
            case Dema :
               retValue = TA_DEMA_StateSave ( (struct dema *) _state.value .ta_state, _file);
            break;
            case Tema :
               retValue = TA_TEMA_StateSave ( (struct tema *) _state.value .ta_state, _file);
            break;
            case Trima :
               retValue = TA_TRIMA_StateSave ( (struct trima *) _state.value .ta_state, _file);
            break;
            case Kama :
               retValue = TA_KAMA_StateSave ( (struct kama *) _state.value .ta_state, _file);
            break;
            case Mama :
               retValue = TA_MAMA_StateSave ( (struct mama *) _state.value .ta_state, _file);
            break;
            case T3 :
               retValue = TA_T3_StateSave ( (struct t3 *) _state.value .ta_state, _file);
            break;
            default:
               retValue = RetCode.BadParam ;
         }
      }
      return retValue;
   }
   public RetCode movingAverageStateLoad( struct TA_movingAverage_State** _state,
      FILE* _file )
   {
      RetCode retValue;
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct movingAverage ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_MA_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_MA_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInMAType,sizeof( _state.value .value .optInMAType),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      {
         switch( _state.value .value .optInMAType )
         {
            case Sma :
               retValue = TA_SMA_StateLoad ( (struct sma **) & _state.value .value .ta_state, _file);
            break;
            case Ema :
               retValue = TA_EMA_StateLoad ( (struct ema **) & _state.value .value .ta_state, _file);
            break;
            case Wma :
               retValue = TA_WMA_StateLoad ( (struct wma **) & _state.value .value .ta_state, _file);
            break;
            case Dema :
               retValue = TA_DEMA_StateLoad ( (struct dema **) & _state.value .value .ta_state, _file);
            break;
            case Tema :
               retValue = TA_TEMA_StateLoad ( (struct tema **) & _state.value .value .ta_state, _file);
            break;
            case Trima :
               retValue = TA_TRIMA_StateLoad ( (struct trima **) & _state.value .value .ta_state, _file);
            break;
            case Kama :
               retValue = TA_KAMA_StateLoad ( (struct kama **) & _state.value .value .ta_state, _file);
            break;
            case Mama :
               retValue = TA_MAMA_StateLoad ( (struct mama **) & _state.value .value .ta_state, _file);
            break;
            case T3 :
               retValue = TA_T3_StateLoad ( (struct t3 **) & _state.value .value .ta_state, _file);
            break;
            default:
               retValue = RetCode.BadParam ;
         }
      }
      return retValue;
   }
   public RetCode movingAverage( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MAType optInMAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double []dummyBuffer ;
      RetCode retCode;
      int nbElement;
      int outIdx, todayIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInTimePeriod == 1 )
      {
         nbElement = endIdx-startIdx+1;
         outNBElement.value = nbElement;
         for( todayIdx=startIdx, outIdx=0; outIdx < nbElement; outIdx++, todayIdx++ )
            outReal[outIdx] = inReal[todayIdx];
         outBegIdx.value = startIdx;
         return RetCode.Success ;
      }
      switch( optInMAType )
      {
         case Sma :
            retCode = sma ( startIdx, endIdx, inReal, optInTimePeriod,
            outBegIdx, outNBElement, outReal );
         break;
         case Ema :
            retCode = ema ( startIdx, endIdx, inReal, optInTimePeriod,
            outBegIdx, outNBElement, outReal );
         break;
         case Wma :
            retCode = wma ( startIdx, endIdx, inReal, optInTimePeriod,
            outBegIdx, outNBElement, outReal );
         break;
         case Dema :
            retCode = dema ( startIdx, endIdx, inReal, optInTimePeriod,
            outBegIdx, outNBElement, outReal );
         break;
         case Tema :
            retCode = tema ( startIdx, endIdx, inReal, optInTimePeriod,
            outBegIdx, outNBElement, outReal );
         break;
         case Trima :
            retCode = trima ( startIdx, endIdx, inReal, optInTimePeriod,
            outBegIdx, outNBElement, outReal );
         break;
         case Kama :
            retCode = kama ( startIdx, endIdx, inReal, optInTimePeriod,
            outBegIdx, outNBElement, outReal );
         break;
         case Mama :
            dummyBuffer = new double[(endIdx-startIdx+1)] ;
         retCode = mama ( startIdx, endIdx, inReal, 0.5, 0.05,
            outBegIdx, outNBElement,
            outReal, dummyBuffer );
         break;
         case T3 :
            retCode = t3 ( startIdx, endIdx, inReal,
            optInTimePeriod, 0.7,
            outBegIdx, outNBElement, outReal );
         break;
         default:
            retCode = RetCode.BadParam ;
         break;
      }
      return retCode;
   }
   /* Generated */
   public int macdLookback( int optInFastPeriod,
      int optInSlowPeriod,
      int optInSignalPeriod )
   {
      int tempInteger;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return -1;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return -1;
      if( (int)optInSignalPeriod == ( Integer.MIN_VALUE ) )
         optInSignalPeriod = 9;
      else if( ((int)optInSignalPeriod < 1) || ((int)optInSignalPeriod > 100000) )
         return -1;
      if( optInSlowPeriod < optInFastPeriod )
      {
         tempInteger = optInSlowPeriod;
         optInSlowPeriod = optInFastPeriod;
         optInFastPeriod = tempInteger;
      }
      return emaLookback ( optInSlowPeriod )
         + emaLookback ( optInSignalPeriod );
   }
   public RetCode macd( int startIdx,
      int endIdx,
      double inReal[],
      int optInFastPeriod,
      int optInSlowPeriod,
      int optInSignalPeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outMACD[],
      double outMACDSignal[],
      double outMACDHist[] )
   {
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSignalPeriod == ( Integer.MIN_VALUE ) )
         optInSignalPeriod = 9;
      else if( ((int)optInSignalPeriod < 1) || ((int)optInSignalPeriod > 100000) )
         return RetCode.BadParam ;
      return TA_INT_MACD ( startIdx, endIdx, inReal,
         optInFastPeriod,
         optInSlowPeriod,
         optInSignalPeriod,
         outBegIdx,
         outNBElement,
         outMACD,
         outMACDSignal,
         outMACDHist );
   }
   RetCode TA_INT_MACD( int startIdx,
      int endIdx,
      double inReal[],
      int optInFastPeriod,
      int optInSlowPeriod,
      int optInSignalPeriod_2,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outMACD[],
      double outMACDSignal[],
      double outMACDHist[] )
   {
      double []slowEMABuffer ;
      double []fastEMABuffer ;
      double k1, k2;
      RetCode retCode;
      int tempInteger;
      MInteger outBegIdx1 = new MInteger() ;
      MInteger outNbElement1 = new MInteger() ;
      MInteger outBegIdx2 = new MInteger() ;
      MInteger outNbElement2 = new MInteger() ;
      int lookbackTotal, lookbackSignal;
      int i;
      if( optInSlowPeriod < optInFastPeriod )
      {
         tempInteger = optInSlowPeriod;
         optInSlowPeriod = optInFastPeriod;
         optInFastPeriod = tempInteger;
      }
      if( optInSlowPeriod != 0 )
         k1 = ((double)2.0 / ((double)(optInSlowPeriod + 1))) ;
      else
      {
         optInSlowPeriod = 26;
         k1 = (double)0.075;
      }
      if( optInFastPeriod != 0 )
         k2 = ((double)2.0 / ((double)(optInFastPeriod + 1))) ;
      else
      {
         optInFastPeriod = 12;
         k2 = (double)0.15;
      }
      lookbackSignal = emaLookback ( optInSignalPeriod_2 );
      lookbackTotal = lookbackSignal;
      lookbackTotal += emaLookback ( optInSlowPeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      tempInteger = (endIdx-startIdx)+1+lookbackSignal;
      fastEMABuffer = new double[tempInteger] ;
      slowEMABuffer = new double[tempInteger] ;
      tempInteger = startIdx-lookbackSignal;
      retCode = TA_INT_EMA ( tempInteger, endIdx,
         inReal, optInSlowPeriod, k1,
         outBegIdx1 , outNbElement1 , slowEMABuffer );
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      retCode = TA_INT_EMA ( tempInteger, endIdx,
         inReal, optInFastPeriod, k2,
         outBegIdx2 , outNbElement2 , fastEMABuffer );
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      if( ( outBegIdx1.value != tempInteger) ||
         ( outBegIdx2.value != tempInteger) ||
         ( outNbElement1.value != outNbElement2.value ) ||
         ( outNbElement1.value != (endIdx-startIdx)+1+lookbackSignal) )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return (RetCode.InternalError) ;
      }
      for( i=0; i < outNbElement1.value ; i++ )
         fastEMABuffer[i] = fastEMABuffer[i] - slowEMABuffer[i];
      System.arraycopy(fastEMABuffer,lookbackSignal,outMACD,0,(endIdx-startIdx)+1) ;
      retCode = TA_INT_EMA ( 0, outNbElement1.value -1,
         fastEMABuffer, optInSignalPeriod_2, ((double)2.0 / ((double)(optInSignalPeriod_2 + 1))) ,
         outBegIdx2 , outNbElement2 , outMACDSignal );
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      for( i=0; i < outNbElement2.value ; i++ )
         outMACDHist[i] = outMACD[i]-outMACDSignal[i];
      outBegIdx.value = startIdx;
      outNBElement.value = outNbElement2.value ;
      return RetCode.Success ;
   }
   public RetCode macdStateInit( struct TA_macd_State** _state,
      int optInFastPeriod,
      int optInSlowPeriod,
      int optInSignalPeriod )
   {
      RetCode retCode;
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSignalPeriod == ( Integer.MIN_VALUE ) )
         optInSignalPeriod = 9;
      else if( ((int)optInSignalPeriod < 1) || ((int)optInSignalPeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct macd ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInFastPeriod = optInFastPeriod;
      _state.value .value .optInSlowPeriod = optInSlowPeriod;
      _state.value .value .optInSignalPeriod = optInSignalPeriod;
      _state.value .value .mem_size = macdLookback (optInFastPeriod, optInSlowPeriod, optInSignalPeriod );
      _state.value .value .memory = NULL;
      if( optInSlowPeriod < optInFastPeriod )
      {
         _state.value .value .optInSlowPeriod = optInFastPeriod;
         _state.value .value .optInFastPeriod = optInSlowPeriod;
      }
      retCode = ema ((struct ema **)& _state.value .value .slowEMAState, _state.value .value .optInSlowPeriod);
      if (retCode != RetCode.Success ) return retCode;
      retCode = ema ((struct ema **)& _state.value .value .fastEMAState, _state.value .value .optInFastPeriod);
      if (retCode != RetCode.Success ) return retCode;
      retCode = ema ((struct ema **)& _state.value .value .signalEMAState, _state.value .value .optInSignalPeriod);
      return retCode;
   }
   public int TA_INT_MACD_StateInit( struct TA_macd_State** _state,
      int optInFastPeriod,
      int optInSlowPeriod,
      int optInSignalPeriod )
   {
      double k1, k2;
      RetCode retCode;
      if( optInSlowPeriod < optInFastPeriod )
      {
         int temp = optInSlowPeriod;
         optInSlowPeriod = optInFastPeriod;
         optInFastPeriod = temp;
      }
      if( optInSlowPeriod != 0 )
         k1 = ((double)2.0 / ((double)(optInSlowPeriod + 1))) ;
      else
      {
         optInSlowPeriod = 26;
         k1 = (double)0.075;
      }
      if( optInFastPeriod != 0 )
         k2 = ((double)2.0 / ((double)(optInFastPeriod + 1))) ;
      else
      {
         optInFastPeriod = 12;
         k2 = (double)0.15;
      }
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSignalPeriod == ( Integer.MIN_VALUE ) )
         optInSignalPeriod = 9;
      else if( ((int)optInSignalPeriod < 1) || ((int)optInSignalPeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct macd ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInFastPeriod = optInFastPeriod;
      _state.value .value .optInSlowPeriod = optInSlowPeriod;
      _state.value .value .optInSignalPeriod = optInSignalPeriod;
      _state.value .value .mem_size = macdLookback (optInFastPeriod, optInSlowPeriod, optInSignalPeriod );
      _state.value .value .memory = NULL;
      retCode = TA_INT_EMA_StateInit ((struct ema **)& _state.value .value .slowEMAState, _state.value .value .optInSlowPeriod, k1);
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_INT_EMA_StateInit ((struct ema **)& _state.value .value .fastEMAState, _state.value .value .optInFastPeriod, k2);
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_INT_EMA_StateInit ((struct ema **)& _state.value .value .signalEMAState, _state.value .value .optInSignalPeriod, ((double)2.0 / ((double)( _state.value .value .optInSignalPeriod + 1))) );
      return retCode;
   }
   public RetCode macdState( struct TA_macd_State* _state,
      double inReal,
      double *outMACD,
      double *outMACDSignal,
      double *outMACDHist )
   {
      RetCode retCode1;
      RetCode retCode2;
      RetCode retCode3;
      double slowEMA, fastEMA;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .fastEMADelay = emaLookback ( _state.value .optInSlowPeriod ) - emaLookback ( _state.value .optInFastPeriod );
      }
      retCode1 = ema ( _state.value .slowEMAState, inReal, &slowEMA );
      if( retCode1 != RetCode.Success &&
         retCode1 != RetCode.NeedMoreData )
         return retCode1;
      if ( ( _state.value .fastEMADelay < (int) _state.value .mem_index) || ( (this.compatibility) != Compatibility.Default ))
      {
         retCode2 = ema ( _state.value .fastEMAState, inReal, &fastEMA );
         if( retCode2 != RetCode.Success &&
            retCode2 != RetCode.NeedMoreData )
            return retCode2;
      } else return RetCode.NeedMoreData ;
      if (retCode1 | retCode2)
         return (retCode1 | retCode2);
      outMACD.value = fastEMA - slowEMA;
      retCode3 = ema ( _state.value .signalEMAState, fastEMA - slowEMA, outMACDSignal );
      if( retCode3 != RetCode.Success &&
         retCode3 != RetCode.NeedMoreData )
         return retCode3;
      outMACDHist.value = outMACD.value - outMACDSignal.value ;
      return (retCode1 | retCode2 | retCode3);
   }
   public RetCode macdStateFree( struct TA_macd_State** _state )
   {
      RetCode retCode;
      retCode = ema ((struct ema **)& _state.value .value .slowEMAState);
      if (retCode != RetCode.Success ) return retCode;
      retCode = ema ((struct ema **)& _state.value .value .fastEMAState);
      if (retCode != RetCode.Success ) return retCode;
      retCode = ema ((struct ema **)& _state.value .value .signalEMAState);
      if (retCode != RetCode.Success ) return retCode;
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode macdStateSave( struct TA_macd_State* _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_MACD_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInFastPeriod,sizeof( _state.value .optInFastPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInSlowPeriod,sizeof( _state.value .optInSlowPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInSignalPeriod,sizeof( _state.value .optInSignalPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .fastEMADelay,sizeof( _state.value .fastEMADelay),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_EMA_StateSave ( (struct ema *) _state.value .slowEMAState, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_EMA_StateSave ( (struct ema *) _state.value .fastEMAState, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_EMA_StateSave ( (struct ema *) _state.value .signalEMAState, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode macdStateLoad( struct TA_macd_State** _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct macd ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_MACD_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_MACD_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInFastPeriod,sizeof( _state.value .value .optInFastPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInSlowPeriod,sizeof( _state.value .value .optInSlowPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInSignalPeriod,sizeof( _state.value .value .optInSignalPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .fastEMADelay,sizeof( _state.value .value .fastEMADelay),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_EMA_StateLoad ( (struct ema **) & _state.value .value .slowEMAState, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_EMA_StateLoad ( (struct ema **) & _state.value .value .fastEMAState, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_EMA_StateLoad ( (struct ema **) & _state.value .value .signalEMAState, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode macd( int startIdx,
      int endIdx,
      float inReal[],
      int optInFastPeriod,
      int optInSlowPeriod,
      int optInSignalPeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outMACD[],
      double outMACDSignal[],
      double outMACDHist[] )
   {
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSignalPeriod == ( Integer.MIN_VALUE ) )
         optInSignalPeriod = 9;
      else if( ((int)optInSignalPeriod < 1) || ((int)optInSignalPeriod > 100000) )
         return RetCode.BadParam ;
      return TA_INT_MACD ( startIdx, endIdx, inReal,
         optInFastPeriod,
         optInSlowPeriod,
         optInSignalPeriod,
         outBegIdx,
         outNBElement,
         outMACD,
         outMACDSignal,
         outMACDHist );
   }
   RetCode TA_INT_MACD( int startIdx,
      int endIdx,
      float inReal[],
      int optInFastPeriod,
      int optInSlowPeriod,
      int optInSignalPeriod_2,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outMACD[],
      double outMACDSignal[],
      double outMACDHist[] )
   {
      double []slowEMABuffer ;
      double []fastEMABuffer ;
      double k1, k2;
      RetCode retCode;
      int tempInteger;
      MInteger outBegIdx1 = new MInteger() ;
      MInteger outNbElement1 = new MInteger() ;
      MInteger outBegIdx2 = new MInteger() ;
      MInteger outNbElement2 = new MInteger() ;
      int lookbackTotal, lookbackSignal;
      int i;
      if( optInSlowPeriod < optInFastPeriod )
      {
         tempInteger = optInSlowPeriod;
         optInSlowPeriod = optInFastPeriod;
         optInFastPeriod = tempInteger;
      }
      if( optInSlowPeriod != 0 )
         k1 = ((double)2.0 / ((double)(optInSlowPeriod + 1))) ;
      else
      {
         optInSlowPeriod = 26;
         k1 = (double)0.075;
      }
      if( optInFastPeriod != 0 )
         k2 = ((double)2.0 / ((double)(optInFastPeriod + 1))) ;
      else
      {
         optInFastPeriod = 12;
         k2 = (double)0.15;
      }
      lookbackSignal = emaLookback ( optInSignalPeriod_2 );
      lookbackTotal = lookbackSignal;
      lookbackTotal += emaLookback ( optInSlowPeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      tempInteger = (endIdx-startIdx)+1+lookbackSignal;
      fastEMABuffer = new double[tempInteger] ;
      slowEMABuffer = new double[tempInteger] ;
      tempInteger = startIdx-lookbackSignal;
      retCode = TA_INT_EMA ( tempInteger, endIdx,
         inReal, optInSlowPeriod, k1,
         outBegIdx1 , outNbElement1 , slowEMABuffer );
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      retCode = TA_INT_EMA ( tempInteger, endIdx,
         inReal, optInFastPeriod, k2,
         outBegIdx2 , outNbElement2 , fastEMABuffer );
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      if( ( outBegIdx1.value != tempInteger) ||
         ( outBegIdx2.value != tempInteger) ||
         ( outNbElement1.value != outNbElement2.value ) ||
         ( outNbElement1.value != (endIdx-startIdx)+1+lookbackSignal) )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return (RetCode.InternalError) ;
      }
      for( i=0; i < outNbElement1.value ; i++ )
         fastEMABuffer[i] = fastEMABuffer[i] - slowEMABuffer[i];
      System.arraycopy(fastEMABuffer,lookbackSignal,outMACD,0,(endIdx-startIdx)+1) ;
      retCode = TA_INT_EMA ( 0, outNbElement1.value -1,
         fastEMABuffer, optInSignalPeriod_2, ((double)2.0 / ((double)(optInSignalPeriod_2 + 1))) ,
         outBegIdx2 , outNbElement2 , outMACDSignal );
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      for( i=0; i < outNbElement2.value ; i++ )
         outMACDHist[i] = outMACD[i]-outMACDSignal[i];
      outBegIdx.value = startIdx;
      outNBElement.value = outNbElement2.value ;
      return RetCode.Success ;
   }
   /* Generated */
   public int macdExtLookback( int optInFastPeriod,
      MAType optInFastMAType, int optInSlowPeriod,
      MAType optInSlowMAType, int optInSignalPeriod,
      MAType optInSignalMAType )
   {
      int tempInteger, lookbackLargest;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return -1;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return -1;
      if( (int)optInSignalPeriod == ( Integer.MIN_VALUE ) )
         optInSignalPeriod = 9;
      else if( ((int)optInSignalPeriod < 1) || ((int)optInSignalPeriod > 100000) )
         return -1;
      lookbackLargest = movingAverageLookback ( optInFastPeriod, optInFastMAType );
      tempInteger = movingAverageLookback ( optInSlowPeriod, optInSlowMAType );
      if( tempInteger > lookbackLargest )
         lookbackLargest = tempInteger;
      return lookbackLargest + movingAverageLookback ( optInSignalPeriod, optInSignalMAType );
   }
   public RetCode macdExt( int startIdx,
      int endIdx,
      double inReal[],
      int optInFastPeriod,
      MAType optInFastMAType, int optInSlowPeriod,
      MAType optInSlowMAType, int optInSignalPeriod,
      MAType optInSignalMAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outMACD[],
      double outMACDSignal[],
      double outMACDHist[] )
   {
      double []slowMABuffer ;
      double []fastMABuffer ;
      RetCode retCode;
      int tempInteger;
      MInteger outBegIdx1 = new MInteger() ;
      MInteger outNbElement1 = new MInteger() ;
      MInteger outBegIdx2 = new MInteger() ;
      MInteger outNbElement2 = new MInteger() ;
      int lookbackTotal, lookbackSignal, lookbackLargest;
      int i;
      MAType tempMAType;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSignalPeriod == ( Integer.MIN_VALUE ) )
         optInSignalPeriod = 9;
      else if( ((int)optInSignalPeriod < 1) || ((int)optInSignalPeriod > 100000) )
         return RetCode.BadParam ;
      if( optInSlowPeriod < optInFastPeriod )
      {
         tempInteger = optInSlowPeriod;
         optInSlowPeriod = optInFastPeriod;
         optInFastPeriod = tempInteger;
         tempMAType = optInSlowMAType;
         optInSlowMAType = optInFastMAType;
         optInFastMAType = tempMAType;
      }
      lookbackLargest = movingAverageLookback ( optInFastPeriod, optInFastMAType );
      tempInteger = movingAverageLookback ( optInSlowPeriod, optInSlowMAType );
      if( tempInteger > lookbackLargest )
         lookbackLargest = tempInteger;
      lookbackSignal = movingAverageLookback ( optInSignalPeriod, optInSignalMAType );
      lookbackTotal = lookbackSignal+lookbackLargest;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      tempInteger = (endIdx-startIdx)+1+lookbackSignal;
      fastMABuffer = new double[tempInteger] ;
      slowMABuffer = new double[tempInteger] ;
      tempInteger = startIdx-lookbackSignal;
      retCode = movingAverage ( tempInteger, endIdx,
         inReal, optInSlowPeriod, optInSlowMAType,
         outBegIdx1 , outNbElement1 ,
         slowMABuffer );
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      retCode = movingAverage ( tempInteger, endIdx,
         inReal, optInFastPeriod, optInFastMAType,
         outBegIdx2 , outNbElement2 ,
         fastMABuffer );
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      if( ( outBegIdx1.value != tempInteger) ||
         ( outBegIdx2.value != tempInteger) ||
         ( outNbElement1.value != outNbElement2.value ) ||
         ( outNbElement1.value != (endIdx-startIdx)+1+lookbackSignal) )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return (RetCode.InternalError) ;
      }
      for( i=0; i < outNbElement1.value ; i++ )
         fastMABuffer[i] = fastMABuffer[i] - slowMABuffer[i];
      System.arraycopy(fastMABuffer,lookbackSignal,outMACD,0,(endIdx-startIdx)+1) ;
      retCode = movingAverage ( 0, outNbElement1.value -1,
         fastMABuffer, optInSignalPeriod, optInSignalMAType,
         outBegIdx2 , outNbElement2 , outMACDSignal );
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      for( i=0; i < outNbElement2.value ; i++ )
         outMACDHist[i] = outMACD[i]-outMACDSignal[i];
      outBegIdx.value = startIdx;
      outNBElement.value = outNbElement2.value ;
      return RetCode.Success ;
   }
   public RetCode macdExtStateInit( struct TA_macdExt_State** _state,
      int optInFastPeriod,
      MAType optInFastMAType, int optInSlowPeriod,
      MAType optInSlowMAType, int optInSignalPeriod,
      MAType optInSignalMAType )
   {
      RetCode retCode;
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSignalPeriod == ( Integer.MIN_VALUE ) )
         optInSignalPeriod = 9;
      else if( ((int)optInSignalPeriod < 1) || ((int)optInSignalPeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct macdExt ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInFastPeriod = optInFastPeriod;
      _state.value .value .optInFastMAType = optInFastMAType;
      _state.value .value .optInSlowPeriod = optInSlowPeriod;
      _state.value .value .optInSlowMAType = optInSlowMAType;
      _state.value .value .optInSignalPeriod = optInSignalPeriod;
      _state.value .value .optInSignalMAType = optInSignalMAType;
      _state.value .value .mem_size = macdExtLookback (optInFastPeriod, optInFastMAType, optInSlowPeriod, optInSlowMAType, optInSignalPeriod, optInSignalMAType );
      _state.value .value .memory = NULL;
      if( optInSlowPeriod < optInFastPeriod )
      {
         _state.value .value .optInSlowPeriod = _state.value .value .optInFastPeriod;
         _state.value .value .optInFastPeriod = optInSlowPeriod;
         _state.value .value .optInSlowMAType = _state.value .value .optInFastMAType;
         _state.value .value .optInFastMAType = optInSlowMAType;
      }
      retCode = movingAverage ((struct movingAverage **)& _state.value .value .slowMAState, _state.value .value .optInSlowPeriod, _state.value .value .optInSlowMAType);
      if (retCode != RetCode.Success ) return retCode;
      retCode = movingAverage ((struct movingAverage **)& _state.value .value .fastMAState, _state.value .value .optInFastPeriod, _state.value .value .optInFastMAType);
      if (retCode != RetCode.Success ) return retCode;
      retCode = movingAverage ((struct movingAverage **)& _state.value .value .signalMAState, _state.value .value .optInSignalPeriod, _state.value .value .optInSignalMAType);
      return retCode;
   }
   public RetCode macdExtState( struct TA_macdExt_State* _state,
      double inReal,
      double *outMACD,
      double *outMACDSignal,
      double *outMACDHist )
   {
      RetCode retCode1;
      RetCode retCode2;
      RetCode retCode3;
      double slowMA, fastMA;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .fastMADelay = abs( movingAverageLookback ( _state.value .optInSlowPeriod, _state.value .optInSlowMAType ) - movingAverageLookback ( _state.value .optInFastPeriod, _state.value .optInFastMAType ) );
      }
      retCode1 = movingAverage ( _state.value .slowMAState, inReal, &slowMA );
      if( retCode1 != RetCode.Success &&
         retCode1 != RetCode.NeedMoreData )
         return retCode1;
      if ( _state.value .fastMADelay < (int) _state.value .mem_index)
      {
         retCode2 = movingAverage ( _state.value .fastMAState, inReal, &fastMA );
         if( retCode2 != RetCode.Success &&
            retCode2 != RetCode.NeedMoreData )
            return retCode2;
      } else return RetCode.NeedMoreData ;
      if (retCode1 | retCode2)
         return (retCode1 | retCode2);
      outMACD.value = fastMA - slowMA;
      retCode3 = movingAverage ( _state.value .signalMAState, fastMA - slowMA, outMACDSignal );
      if( retCode3 != RetCode.Success &&
         retCode3 != RetCode.NeedMoreData )
         return retCode3;
      outMACDHist.value = outMACD.value - outMACDSignal.value ;
      return (retCode1 | retCode2 | retCode3);
   }
   public RetCode macdExtStateFree( struct TA_macdExt_State** _state )
   {
      RetCode retCode;
      retCode = movingAverage ((struct movingAverage **)& _state.value .value .slowMAState);
      if (retCode != RetCode.Success ) return retCode;
      retCode = movingAverage ((struct movingAverage **)& _state.value .value .fastMAState);
      if (retCode != RetCode.Success ) return retCode;
      retCode = movingAverage ((struct movingAverage **)& _state.value .value .signalMAState);
      if (retCode != RetCode.Success ) return retCode;
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode macdExtStateSave( struct TA_macdExt_State* _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_MACDEXT_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInFastPeriod,sizeof( _state.value .optInFastPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInFastMAType,sizeof( _state.value .optInFastMAType),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInSlowPeriod,sizeof( _state.value .optInSlowPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInSlowMAType,sizeof( _state.value .optInSlowMAType),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInSignalPeriod,sizeof( _state.value .optInSignalPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInSignalMAType,sizeof( _state.value .optInSignalMAType),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .fastMADelay,sizeof( _state.value .fastMADelay),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_MA_StateSave ( (struct movingAverage *) _state.value .slowMAState, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_MA_StateSave ( (struct movingAverage *) _state.value .fastMAState, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_MA_StateSave ( (struct movingAverage *) _state.value .signalMAState, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode macdExtStateLoad( struct TA_macdExt_State** _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct macdExt ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_MACDEXT_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_MACDEXT_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInFastPeriod,sizeof( _state.value .value .optInFastPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInFastMAType,sizeof( _state.value .value .optInFastMAType),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInSlowPeriod,sizeof( _state.value .value .optInSlowPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInSlowMAType,sizeof( _state.value .value .optInSlowMAType),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInSignalPeriod,sizeof( _state.value .value .optInSignalPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInSignalMAType,sizeof( _state.value .value .optInSignalMAType),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .fastMADelay,sizeof( _state.value .value .fastMADelay),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_MA_StateLoad ( (struct movingAverage **) & _state.value .value .slowMAState, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_MA_StateLoad ( (struct movingAverage **) & _state.value .value .fastMAState, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_MA_StateLoad ( (struct movingAverage **) & _state.value .value .signalMAState, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode macdExt( int startIdx,
      int endIdx,
      float inReal[],
      int optInFastPeriod,
      MAType optInFastMAType, int optInSlowPeriod,
      MAType optInSlowMAType, int optInSignalPeriod,
      MAType optInSignalMAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outMACD[],
      double outMACDSignal[],
      double outMACDHist[] )
   {
      double []slowMABuffer ;
      double []fastMABuffer ;
      RetCode retCode;
      int tempInteger;
      MInteger outBegIdx1 = new MInteger() ;
      MInteger outNbElement1 = new MInteger() ;
      MInteger outBegIdx2 = new MInteger() ;
      MInteger outNbElement2 = new MInteger() ;
      int lookbackTotal, lookbackSignal, lookbackLargest;
      int i;
      MAType tempMAType;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSignalPeriod == ( Integer.MIN_VALUE ) )
         optInSignalPeriod = 9;
      else if( ((int)optInSignalPeriod < 1) || ((int)optInSignalPeriod > 100000) )
         return RetCode.BadParam ;
      if( optInSlowPeriod < optInFastPeriod )
      {
         tempInteger = optInSlowPeriod;
         optInSlowPeriod = optInFastPeriod;
         optInFastPeriod = tempInteger;
         tempMAType = optInSlowMAType;
         optInSlowMAType = optInFastMAType;
         optInFastMAType = tempMAType;
      }
      lookbackLargest = movingAverageLookback ( optInFastPeriod, optInFastMAType );
      tempInteger = movingAverageLookback ( optInSlowPeriod, optInSlowMAType );
      if( tempInteger > lookbackLargest )
         lookbackLargest = tempInteger;
      lookbackSignal = movingAverageLookback ( optInSignalPeriod, optInSignalMAType );
      lookbackTotal = lookbackSignal+lookbackLargest;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      tempInteger = (endIdx-startIdx)+1+lookbackSignal;
      fastMABuffer = new double[tempInteger] ;
      slowMABuffer = new double[tempInteger] ;
      tempInteger = startIdx-lookbackSignal;
      retCode = movingAverage ( tempInteger, endIdx,
         inReal, optInSlowPeriod, optInSlowMAType,
         outBegIdx1 , outNbElement1 ,
         slowMABuffer );
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      retCode = movingAverage ( tempInteger, endIdx,
         inReal, optInFastPeriod, optInFastMAType,
         outBegIdx2 , outNbElement2 ,
         fastMABuffer );
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      if( ( outBegIdx1.value != tempInteger) ||
         ( outBegIdx2.value != tempInteger) ||
         ( outNbElement1.value != outNbElement2.value ) ||
         ( outNbElement1.value != (endIdx-startIdx)+1+lookbackSignal) )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return (RetCode.InternalError) ;
      }
      for( i=0; i < outNbElement1.value ; i++ )
         fastMABuffer[i] = fastMABuffer[i] - slowMABuffer[i];
      System.arraycopy(fastMABuffer,lookbackSignal,outMACD,0,(endIdx-startIdx)+1) ;
      retCode = movingAverage ( 0, outNbElement1.value -1,
         fastMABuffer, optInSignalPeriod, optInSignalMAType,
         outBegIdx2 , outNbElement2 , outMACDSignal );
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      for( i=0; i < outNbElement2.value ; i++ )
         outMACDHist[i] = outMACD[i]-outMACDSignal[i];
      outBegIdx.value = startIdx;
      outNBElement.value = outNbElement2.value ;
      return RetCode.Success ;
   }
   /* Generated */
   public int macdFixLookback( int optInSignalPeriod )
   {
      if( (int)optInSignalPeriod == ( Integer.MIN_VALUE ) )
         optInSignalPeriod = 9;
      else if( ((int)optInSignalPeriod < 1) || ((int)optInSignalPeriod > 100000) )
         return -1;
      return emaLookback ( 26 )
         + emaLookback ( optInSignalPeriod );
   }
   public RetCode macdFix( int startIdx,
      int endIdx,
      double inReal[],
      int optInSignalPeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outMACD[],
      double outMACDSignal[],
      double outMACDHist[] )
   {
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInSignalPeriod == ( Integer.MIN_VALUE ) )
         optInSignalPeriod = 9;
      else if( ((int)optInSignalPeriod < 1) || ((int)optInSignalPeriod > 100000) )
         return RetCode.BadParam ;
      return TA_INT_MACD ( startIdx, endIdx, inReal,
         0,
         0,
         optInSignalPeriod,
         outBegIdx,
         outNBElement,
         outMACD,
         outMACDSignal,
         outMACDHist );
   }
   public RetCode macdFixStateInit( struct TA_macdFix_State** _state,
      int optInSignalPeriod )
   {
      return TA_INT_MACD_StateInit ((struct macd **) _state,
         0,
         0,
         optInSignalPeriod);
   }
   public RetCode macdFixState( struct TA_macdFix_State* _state,
      double inReal,
      double *outMACD,
      double *outMACDSignal,
      double *outMACDHist )
   {
      return macd ( (struct macd *) _state, inReal, outMACD, outMACDSignal, outMACDHist );
   }
   public RetCode macdFixStateFree( struct TA_macdFix_State** _state )
   {
      return macd ( (struct macd **) _state );
   }
   public RetCode macdFixStateSave( struct TA_macdFix_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_MACDFIX_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInSignalPeriod,sizeof( _state.value .optInSignalPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode macdFixStateLoad( struct TA_macdFix_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct macdFix ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_MACDFIX_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_MACDFIX_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInSignalPeriod,sizeof( _state.value .value .optInSignalPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode macdFix( int startIdx,
      int endIdx,
      float inReal[],
      int optInSignalPeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outMACD[],
      double outMACDSignal[],
      double outMACDHist[] )
   {
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInSignalPeriod == ( Integer.MIN_VALUE ) )
         optInSignalPeriod = 9;
      else if( ((int)optInSignalPeriod < 1) || ((int)optInSignalPeriod > 100000) )
         return RetCode.BadParam ;
      return TA_INT_MACD ( startIdx, endIdx, inReal,
         0,
         0,
         optInSignalPeriod,
         outBegIdx,
         outNBElement,
         outMACD,
         outMACDSignal,
         outMACDHist );
   }
   /* Generated */
   public int mamaLookback( double optInFastLimit,
      double optInSlowLimit )
   {
      if( optInFastLimit == (-4e+37) )
         optInFastLimit = 5.000000e-1;
      else if( (optInFastLimit < 1.000000e-2) || (optInFastLimit > 9.900000e-1) )
         return -1;
      if( optInSlowLimit == (-4e+37) )
         optInSlowLimit = 5.000000e-2;
      else if( (optInSlowLimit < 1.000000e-2) || (optInSlowLimit > 9.900000e-1) )
         return -1;
      return 32 + (this.unstablePeriod[FuncUnstId.Mama.ordinal()]) ;
   }
   public RetCode mama( int startIdx,
      int endIdx,
      double inReal[],
      double optInFastLimit,
      double optInSlowLimit,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outMAMA[],
      double outFAMA[] )
   {
      int outIdx, i;
      int lookbackTotal, today;
      double tempReal, tempReal2;
      double adjustedPrevPeriod, period;
      int trailingWMAIdx;
      double periodWMASum, periodWMASub, trailingWMAValue;
      double smoothedValue;
      final double a = 0.0962;
      final double b = 0.5769;
      double hilbertTempReal;
      int hilbertIdx;
      double []detrender_Odd = new double[3] ; double []detrender_Even = new double[3] ; double detrender; double prev_detrender_Odd ; double prev_detrender_Even ; double prev_detrender_input_Odd ; double prev_detrender_input_Even ;
      double []Q1_Odd = new double[3] ; double []Q1_Even = new double[3] ; double Q1; double prev_Q1_Odd ; double prev_Q1_Even ; double prev_Q1_input_Odd ; double prev_Q1_input_Even ;
      double []jI_Odd = new double[3] ; double []jI_Even = new double[3] ; double jI; double prev_jI_Odd ; double prev_jI_Even ; double prev_jI_input_Odd ; double prev_jI_input_Even ;
      double []jQ_Odd = new double[3] ; double []jQ_Even = new double[3] ; double jQ; double prev_jQ_Odd ; double prev_jQ_Even ; double prev_jQ_input_Odd ; double prev_jQ_input_Even ;
      double Q2, I2, prevQ2, prevI2, Re, Im;
      double I1ForOddPrev2, I1ForOddPrev3;
      double I1ForEvenPrev2, I1ForEvenPrev3;
      double rad2Deg;
      double mama,fama,todayValue,prevPhase;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInFastLimit == (-4e+37) )
         optInFastLimit = 5.000000e-1;
      else if( (optInFastLimit < 1.000000e-2) || (optInFastLimit > 9.900000e-1) )
         return RetCode.BadParam ;
      if( optInSlowLimit == (-4e+37) )
         optInSlowLimit = 5.000000e-2;
      else if( (optInSlowLimit < 1.000000e-2) || (optInSlowLimit > 9.900000e-1) )
         return RetCode.BadParam ;
      rad2Deg = 180.0 / (4.0 * Math.atan (1));
      lookbackTotal = 32 + (this.unstablePeriod[FuncUnstId.Mama.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingWMAIdx = startIdx - lookbackTotal;
      today = trailingWMAIdx;
      tempReal = inReal[today++];
      periodWMASub = tempReal;
      periodWMASum = tempReal;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*2.0;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*3.0;
      trailingWMAValue = 0.0;
      i = 9;
      do
      {
         tempReal = inReal[today++];
         { periodWMASub += tempReal; periodWMASub -= trailingWMAValue; periodWMASum += tempReal*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
      } while( --i != 0);
      hilbertIdx = 0;
      { detrender_Odd [0] = 0.0; detrender_Odd [1] = 0.0; detrender_Odd [2] = 0.0; detrender_Even [0] = 0.0; detrender_Even [1] = 0.0; detrender_Even [2] = 0.0; detrender = 0.0; prev_detrender_Odd = 0.0; prev_detrender_Even = 0.0; prev_detrender_input_Odd = 0.0; prev_detrender_input_Even = 0.0; } ;
      { Q1_Odd [0] = 0.0; Q1_Odd [1] = 0.0; Q1_Odd [2] = 0.0; Q1_Even [0] = 0.0; Q1_Even [1] = 0.0; Q1_Even [2] = 0.0; Q1 = 0.0; prev_Q1_Odd = 0.0; prev_Q1_Even = 0.0; prev_Q1_input_Odd = 0.0; prev_Q1_input_Even = 0.0; } ;
      { jI_Odd [0] = 0.0; jI_Odd [1] = 0.0; jI_Odd [2] = 0.0; jI_Even [0] = 0.0; jI_Even [1] = 0.0; jI_Even [2] = 0.0; jI = 0.0; prev_jI_Odd = 0.0; prev_jI_Even = 0.0; prev_jI_input_Odd = 0.0; prev_jI_input_Even = 0.0; } ;
      { jQ_Odd [0] = 0.0; jQ_Odd [1] = 0.0; jQ_Odd [2] = 0.0; jQ_Even [0] = 0.0; jQ_Even [1] = 0.0; jQ_Even [2] = 0.0; jQ = 0.0; prev_jQ_Odd = 0.0; prev_jQ_Even = 0.0; prev_jQ_input_Odd = 0.0; prev_jQ_input_Even = 0.0; } ;
      period = 0.0;
      outIdx = 0;
      prevI2 = prevQ2 = 0.0;
      Re = Im = 0.0;
      mama = fama = 0.0;
      I1ForOddPrev3 = I1ForEvenPrev3 = 0.0;
      I1ForOddPrev2 = I1ForEvenPrev2 = 0.0;
      prevPhase = 0.0;
      while( today <= endIdx )
      {
         adjustedPrevPeriod = (0.075*period)+0.54;
         todayValue = inReal[today];
         { periodWMASub += todayValue; periodWMASub -= trailingWMAValue; periodWMASum += todayValue*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
         if( (today%2) == 0 )
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Even [hilbertIdx]; detrender_Even [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Even ; prev_detrender_Even = b * prev_detrender_input_Even ; detrender += prev_detrender_Even ; prev_detrender_input_Even = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Even [hilbertIdx]; Q1_Even [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Even ; prev_Q1_Even = b * prev_Q1_input_Even ; Q1 += prev_Q1_Even ; prev_Q1_input_Even = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForEvenPrev3; jI = -jI_Even [hilbertIdx]; jI_Even [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Even ; prev_jI_Even = b * prev_jI_input_Even ; jI += prev_jI_Even ; prev_jI_input_Even = I1ForEvenPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Even [hilbertIdx]; jQ_Even [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Even ; prev_jQ_Even = b * prev_jQ_input_Even ; jQ += prev_jQ_Even ; prev_jQ_input_Even = Q1; jQ *= adjustedPrevPeriod; } ;
            if( ++hilbertIdx == 3 )
               hilbertIdx = 0;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForEvenPrev3 - jQ)) + (0.8*prevI2);
            I1ForOddPrev3 = I1ForOddPrev2;
            I1ForOddPrev2 = detrender;
            if( I1ForEvenPrev3 != 0.0 )
               tempReal2 = ( Math.atan (Q1/I1ForEvenPrev3)*rad2Deg);
            else
               tempReal2 = 0.0;
         }
         else
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Odd [hilbertIdx]; detrender_Odd [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Odd ; prev_detrender_Odd = b * prev_detrender_input_Odd ; detrender += prev_detrender_Odd ; prev_detrender_input_Odd = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Odd [hilbertIdx]; Q1_Odd [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Odd ; prev_Q1_Odd = b * prev_Q1_input_Odd ; Q1 += prev_Q1_Odd ; prev_Q1_input_Odd = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForOddPrev3; jI = -jI_Odd [hilbertIdx]; jI_Odd [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Odd ; prev_jI_Odd = b * prev_jI_input_Odd ; jI += prev_jI_Odd ; prev_jI_input_Odd = I1ForOddPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Odd [hilbertIdx]; jQ_Odd [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Odd ; prev_jQ_Odd = b * prev_jQ_input_Odd ; jQ += prev_jQ_Odd ; prev_jQ_input_Odd = Q1; jQ *= adjustedPrevPeriod; } ;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForOddPrev3 - jQ)) + (0.8*prevI2);
            I1ForEvenPrev3 = I1ForEvenPrev2;
            I1ForEvenPrev2 = detrender;
            if( I1ForOddPrev3 != 0.0 )
               tempReal2 = ( Math.atan (Q1/I1ForOddPrev3)*rad2Deg);
            else
               tempReal2 = 0.0;
         }
         tempReal = prevPhase - tempReal2;
         prevPhase = tempReal2;
         if( tempReal < 1.0 )
            tempReal = 1.0;
         if( tempReal > 1.0 )
         {
            tempReal = optInFastLimit/tempReal;
            if( tempReal < optInSlowLimit )
               tempReal = optInSlowLimit;
         }
         else
         {
            tempReal = optInFastLimit;
         }
         mama = (tempReal*todayValue)+((1-tempReal)*mama);
         tempReal *= 0.5;
         fama = (tempReal*mama)+((1-tempReal)*fama);
         if( today >= startIdx )
         {
            outMAMA[outIdx] = mama;
            outFAMA[outIdx++] = fama;
         }
         Re = (0.2*((I2*prevI2)+(Q2*prevQ2)))+(0.8*Re);
         Im = (0.2*((I2*prevQ2)-(Q2*prevI2)))+(0.8*Im);
         prevQ2 = Q2;
         prevI2 = I2;
         tempReal = period;
         if( (Im != 0.0) && (Re != 0.0) )
            period = 360.0 / ( Math.atan (Im/Re)*rad2Deg);
         tempReal2 = 1.5*tempReal;
         if( period > tempReal2)
            period = tempReal2;
         tempReal2 = 0.67*tempReal;
         if( period < tempReal2 )
            period = tempReal2;
         if( period < 6 )
            period = 6;
         else if( period > 50 )
            period = 50;
         period = (0.2*period) + (0.8 * tempReal);
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   struct TA_MAMA_HILBERT_STRUCT { double []_Odd = new double[3] ; double []_Even = new double[3] ; double var; double prev_Odd; double prev_Even; double prev_input_Odd; double prev_input_Even; };
   public RetCode mamaStateInit( struct TA_mama_State** _state,
      double optInFastLimit,
      double optInSlowLimit )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( optInFastLimit == (-4e+37) )
         optInFastLimit = 5.000000e-1;
      else if( (optInFastLimit < 1.000000e-2) || (optInFastLimit > 9.900000e-1) )
         return RetCode.BadParam ;
      if( optInSlowLimit == (-4e+37) )
         optInSlowLimit = 5.000000e-2;
      else if( (optInSlowLimit < 1.000000e-2) || (optInSlowLimit > 9.900000e-1) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct mama ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInFastLimit = optInFastLimit;
      _state.value .value .optInSlowLimit = optInSlowLimit;
      _state.value .value .mem_size = mamaLookback (optInFastLimit, optInSlowLimit );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_MAMA_Data));
      else
         _state.value .value .memory = NULL;
      { _state.value .value .detrender = calloc(1, sizeof(struct TA_MAMA_HILBERT_STRUCT )); if ( _state.value .value .detrender == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .Q1 = calloc(1, sizeof(struct TA_MAMA_HILBERT_STRUCT )); if ( _state.value .value .Q1 == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .jI = calloc(1, sizeof(struct TA_MAMA_HILBERT_STRUCT )); if ( _state.value .value .jI == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .jQ = calloc(1, sizeof(struct TA_MAMA_HILBERT_STRUCT )); if ( _state.value .value .jQ == NULL) return RetCode.AllocErr ; } ;
      return RetCode.Success ;
   }
   public RetCode mamaState( struct TA_mama_State* _state,
      double inReal,
      double *outMAMA,
      double *outFAMA )
   {
      double hilbertTempReal, smoothedValue;
      double adjustedPrevPeriod;
      double Q2, I2;
      double tempReal, tempReal2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .periodWMASub = 0.;
         _state.value .periodWMASum = 0.;
         _state.value .hilbertIdx = 0;
         _state.value .period = 0;
         _state.value .prevI2 = 0.;
         _state.value .prevQ2 = 0.;
         _state.value .I1ForOddPrev2 = 0;
         _state.value .I1ForEvenPrev2 = 0;
         _state.value .I1ForOddPrev3 = 0;
         _state.value .I1ForEvenPrev3 = 0;
         _state.value .prevPhase = 0.;
         _state.value .mama = 0.;
         _state.value .fama = 0.;
         _state.value .Im = 0.;
         _state.value .Re = 0.;
         _state.value .trailingWMAValue = 0.;
         _state.value .rad2Deg = 180.0 / (4.0 * Math.atan (1));
         _state.value .a = 0.0962;
         _state.value .b = 0.5769;
         { struct TA_MAMA_HILBERT_STRUCT * ref; ref = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .detrender; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_MAMA_HILBERT_STRUCT * ref; ref = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .Q1; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_MAMA_HILBERT_STRUCT * ref; ref = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .jI; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_MAMA_HILBERT_STRUCT * ref; ref = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .jQ; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
      }
      if ( _state.value .mem_index < 4)
      {
         _state.value .periodWMASub += inReal;
         _state.value .periodWMASum += _state.value .mem_index*inReal;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      } else
         if ( _state.value .mem_index <= 12)
      {
         { _state.value .periodWMASub += inReal; _state.value .periodWMASub -= _state.value .trailingWMAValue; _state.value .periodWMASum += inReal*4.0; _state.value .trailingWMAValue = ( _state.value .memory+(( _state.value .mem_index-1+-3)% _state.value .mem_size ) ).value .inReal ; smoothedValue = _state.value .periodWMASum*0.1; _state.value .periodWMASum -= _state.value .periodWMASub; } ;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      }
      adjustedPrevPeriod = (0.075* _state.value .period)+0.54;
      { _state.value .periodWMASub += inReal; _state.value .periodWMASub -= _state.value .trailingWMAValue; _state.value .periodWMASum += inReal*4.0; _state.value .trailingWMAValue = ( _state.value .memory+(( _state.value .mem_index-1+-3)% _state.value .mem_size ) ).value .inReal ; smoothedValue = _state.value .periodWMASum*0.1; _state.value .periodWMASum -= _state.value .periodWMASub; } ;
      if( (( _state.value .mem_index+1)%2) == 0 )
      {
         { struct TA_MAMA_HILBERT_STRUCT * ref; ref = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .detrender; hilbertTempReal = _state.value .a * smoothedValue; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = smoothedValue; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_MAMA_HILBERT_STRUCT * ref; ref = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .Q1; hilbertTempReal = _state.value .a * (struct TA_MAMA_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_MAMA_HILBERT_STRUCT * ref; ref = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .jI; hilbertTempReal = _state.value .a * _state.value .I1ForEvenPrev3; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = _state.value .I1ForEvenPrev3; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_MAMA_HILBERT_STRUCT * ref; ref = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .jQ; hilbertTempReal = _state.value .a * (struct TA_MAMA_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         if( ++ _state.value .hilbertIdx == 3 )
            _state.value .hilbertIdx = 0;
         Q2 = (0.2*( (struct TA_MAMA_HILBERT_STRUCT *) _state.value .Q1.value .var + (struct TA_MAMA_HILBERT_STRUCT *) _state.value .jI.value .var )) + (0.8* _state.value .prevQ2);
         I2 = (0.2*( _state.value .I1ForEvenPrev3 - (struct TA_MAMA_HILBERT_STRUCT *) _state.value .jQ.value .var )) + (0.8* _state.value .prevI2);
         _state.value .I1ForOddPrev3 = _state.value .I1ForOddPrev2;
         _state.value .I1ForOddPrev2 = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .detrender.value .var ;
         if( _state.value .I1ForEvenPrev3 != 0.0 )
            tempReal2 = ( Math.atan ( (struct TA_MAMA_HILBERT_STRUCT *) _state.value .Q1.value .var / _state.value .I1ForEvenPrev3)* _state.value .rad2Deg);
         else
            tempReal2 = 0.0;
      } else {
         { struct TA_MAMA_HILBERT_STRUCT * ref; ref = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .detrender; hilbertTempReal = _state.value .a * smoothedValue; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = smoothedValue; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_MAMA_HILBERT_STRUCT * ref; ref = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .Q1; hilbertTempReal = _state.value .a * (struct TA_MAMA_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_MAMA_HILBERT_STRUCT * ref; ref = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .jI; hilbertTempReal = _state.value .a * _state.value .I1ForOddPrev3; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = _state.value .I1ForOddPrev3; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_MAMA_HILBERT_STRUCT * ref; ref = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .jQ; hilbertTempReal = _state.value .a * (struct TA_MAMA_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         Q2 = (0.2*( (struct TA_MAMA_HILBERT_STRUCT *) _state.value .Q1.value .var + (struct TA_MAMA_HILBERT_STRUCT *) _state.value .jI.value .var )) + (0.8* _state.value .prevQ2);
         I2 = (0.2*( _state.value .I1ForOddPrev3 - (struct TA_MAMA_HILBERT_STRUCT *) _state.value .jQ.value .var )) + (0.8* _state.value .prevI2);
         _state.value .I1ForEvenPrev3 = _state.value .I1ForEvenPrev2;
         _state.value .I1ForEvenPrev2 = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .detrender.value .var ;
         if( _state.value .I1ForOddPrev3 != 0.0 )
            tempReal2 = ( Math.atan ( (struct TA_MAMA_HILBERT_STRUCT *) _state.value .Q1.value .var / _state.value .I1ForOddPrev3)* _state.value .rad2Deg);
         else
            tempReal2 = 0.0;
      }
      tempReal = _state.value .prevPhase - tempReal2;
      _state.value .prevPhase = tempReal2;
      if( tempReal < 1.0 )
         tempReal = 1.0;
      if( tempReal > 1.0 )
      {
         tempReal = _state.value .optInFastLimit/tempReal;
         if( tempReal < _state.value .optInSlowLimit )
            tempReal = _state.value .optInSlowLimit;
      }
      else
      {
         tempReal = _state.value .optInFastLimit;
      }
      _state.value .mama = (tempReal*inReal)+((1-tempReal)* _state.value .mama);
      tempReal *= 0.5;
      _state.value .fama = (tempReal* _state.value .mama)+((1-tempReal)* _state.value .fama);
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         outMAMA.value = _state.value .mama;
         outFAMA.value = _state.value .fama;
      }
      _state.value .Re = (0.2*((I2* _state.value .prevI2)+(Q2* _state.value .prevQ2)))+(0.8* _state.value .Re);
      _state.value .Im = (0.2*((I2* _state.value .prevQ2)-(Q2* _state.value .prevI2)))+(0.8* _state.value .Im);
      _state.value .prevQ2 = Q2;
      _state.value .prevI2 = I2;
      tempReal = _state.value .period;
      if( ( _state.value .Im != 0.0) && ( _state.value .Re != 0.0) )
         _state.value .period = 360.0 / ( Math.atan ( _state.value .Im/ _state.value .Re)* _state.value .rad2Deg);
      tempReal2 = 1.5*tempReal;
      if( _state.value .period > tempReal2)
         _state.value .period = tempReal2;
      tempReal2 = 0.67*tempReal;
      if( _state.value .period < tempReal2 )
         _state.value .period = tempReal2;
      if( _state.value .period < 6 )
         _state.value .period = 6;
      else if( _state.value .period > 50 )
         _state.value .period = 50;
      _state.value .period = (0.2* _state.value .period) + (0.8 * tempReal);
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      else
         return RetCode.Success ;
   }
   public RetCode mamaStateFree( struct TA_mama_State** _state )
   {
      { if ( _state.value .value .detrender != NULL) { free ( _state.value .value .detrender); _state.value .value .detrender = NULL; } } ;
      { if ( _state.value .value .Q1 != NULL) { free ( _state.value .value .Q1); _state.value .value .Q1 = NULL; } } ;
      { if ( _state.value .value .jI != NULL) { free ( _state.value .value .jI); _state.value .value .jI = NULL; } } ;
      { if ( _state.value .value .jQ != NULL) { free ( _state.value .value .jQ); _state.value .value .jQ = NULL; } } ;
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode mamaStateSave( struct TA_mama_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_MAMA_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInFastLimit,sizeof( _state.value .optInFastLimit),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInSlowLimit,sizeof( _state.value .optInSlowLimit),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .hilbertIdx,sizeof( _state.value .hilbertIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodWMASub,sizeof( _state.value .periodWMASub),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodWMASum,sizeof( _state.value .periodWMASum),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .period,sizeof( _state.value .period),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .I1ForOddPrev2,sizeof( _state.value .I1ForOddPrev2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .I1ForEvenPrev2,sizeof( _state.value .I1ForEvenPrev2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .I1ForOddPrev3,sizeof( _state.value .I1ForOddPrev3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .I1ForEvenPrev3,sizeof( _state.value .I1ForEvenPrev3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevI2,sizeof( _state.value .prevI2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevQ2,sizeof( _state.value .prevQ2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevPhase,sizeof( _state.value .prevPhase),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mama,sizeof( _state.value .mama),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .fama,sizeof( _state.value .fama),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .Im,sizeof( _state.value .Im),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .Re,sizeof( _state.value .Re),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .trailingWMAValue,sizeof( _state.value .trailingWMAValue),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .rad2Deg,sizeof( _state.value .rad2Deg),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .a,sizeof( _state.value .a),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .b,sizeof( _state.value .b),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      { if ( _state.value .detrender == NULL) return RetCode.BadParam ; if (fwrite( _state.value .detrender,sizeof(struct TA_MAMA_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .Q1 == NULL) return RetCode.BadParam ; if (fwrite( _state.value .Q1,sizeof(struct TA_MAMA_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .jI == NULL) return RetCode.BadParam ; if (fwrite( _state.value .jI,sizeof(struct TA_MAMA_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .jQ == NULL) return RetCode.BadParam ; if (fwrite( _state.value .jQ,sizeof(struct TA_MAMA_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode mamaStateLoad( struct TA_mama_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct mama ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_MAMA_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_MAMA_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInFastLimit,sizeof( _state.value .value .optInFastLimit),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInSlowLimit,sizeof( _state.value .value .optInSlowLimit),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .hilbertIdx,sizeof( _state.value .value .hilbertIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodWMASub,sizeof( _state.value .value .periodWMASub),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodWMASum,sizeof( _state.value .value .periodWMASum),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .period,sizeof( _state.value .value .period),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .I1ForOddPrev2,sizeof( _state.value .value .I1ForOddPrev2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .I1ForEvenPrev2,sizeof( _state.value .value .I1ForEvenPrev2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .I1ForOddPrev3,sizeof( _state.value .value .I1ForOddPrev3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .I1ForEvenPrev3,sizeof( _state.value .value .I1ForEvenPrev3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevI2,sizeof( _state.value .value .prevI2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevQ2,sizeof( _state.value .value .prevQ2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevPhase,sizeof( _state.value .value .prevPhase),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mama,sizeof( _state.value .value .mama),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .fama,sizeof( _state.value .value .fama),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .Im,sizeof( _state.value .value .Im),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .Re,sizeof( _state.value .value .Re),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .trailingWMAValue,sizeof( _state.value .value .trailingWMAValue),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .rad2Deg,sizeof( _state.value .value .rad2Deg),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .a,sizeof( _state.value .value .a),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .b,sizeof( _state.value .value .b),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      { if ( _state.value .value .detrender != NULL) return RetCode.BadParam ; { _state.value .value .detrender = calloc(1, sizeof(struct TA_MAMA_HILBERT_STRUCT )); if ( _state.value .value .detrender == NULL) return RetCode.AllocErr ; } if (fread( _state.value .value .detrender,sizeof(struct TA_MAMA_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .value .Q1 != NULL) return RetCode.BadParam ; { _state.value .value .Q1 = calloc(1, sizeof(struct TA_MAMA_HILBERT_STRUCT )); if ( _state.value .value .Q1 == NULL) return RetCode.AllocErr ; } if (fread( _state.value .value .Q1,sizeof(struct TA_MAMA_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .value .jI != NULL) return RetCode.BadParam ; { _state.value .value .jI = calloc(1, sizeof(struct TA_MAMA_HILBERT_STRUCT )); if ( _state.value .value .jI == NULL) return RetCode.AllocErr ; } if (fread( _state.value .value .jI,sizeof(struct TA_MAMA_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      { if ( _state.value .value .jQ != NULL) return RetCode.BadParam ; { _state.value .value .jQ = calloc(1, sizeof(struct TA_MAMA_HILBERT_STRUCT )); if ( _state.value .value .jQ == NULL) return RetCode.AllocErr ; } if (fread( _state.value .value .jQ,sizeof(struct TA_MAMA_HILBERT_STRUCT ),1,_file) < 1) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode mama( int startIdx,
      int endIdx,
      float inReal[],
      double optInFastLimit,
      double optInSlowLimit,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outMAMA[],
      double outFAMA[] )
   {
      int outIdx, i;
      int lookbackTotal, today;
      double tempReal, tempReal2;
      double adjustedPrevPeriod, period;
      int trailingWMAIdx;
      double periodWMASum, periodWMASub, trailingWMAValue;
      double smoothedValue;
      final double a = 0.0962;
      final double b = 0.5769;
      double hilbertTempReal;
      int hilbertIdx;
      double []detrender_Odd = new double[3] ; double []detrender_Even = new double[3] ; double detrender; double prev_detrender_Odd ; double prev_detrender_Even ; double prev_detrender_input_Odd ; double prev_detrender_input_Even ;
      double []Q1_Odd = new double[3] ; double []Q1_Even = new double[3] ; double Q1; double prev_Q1_Odd ; double prev_Q1_Even ; double prev_Q1_input_Odd ; double prev_Q1_input_Even ;
      double []jI_Odd = new double[3] ; double []jI_Even = new double[3] ; double jI; double prev_jI_Odd ; double prev_jI_Even ; double prev_jI_input_Odd ; double prev_jI_input_Even ;
      double []jQ_Odd = new double[3] ; double []jQ_Even = new double[3] ; double jQ; double prev_jQ_Odd ; double prev_jQ_Even ; double prev_jQ_input_Odd ; double prev_jQ_input_Even ;
      double Q2, I2, prevQ2, prevI2, Re, Im;
      double I1ForOddPrev2, I1ForOddPrev3;
      double I1ForEvenPrev2, I1ForEvenPrev3;
      double rad2Deg;
      double mama,fama,todayValue,prevPhase;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInFastLimit == (-4e+37) )
         optInFastLimit = 5.000000e-1;
      else if( (optInFastLimit < 1.000000e-2) || (optInFastLimit > 9.900000e-1) )
         return RetCode.BadParam ;
      if( optInSlowLimit == (-4e+37) )
         optInSlowLimit = 5.000000e-2;
      else if( (optInSlowLimit < 1.000000e-2) || (optInSlowLimit > 9.900000e-1) )
         return RetCode.BadParam ;
      rad2Deg = 180.0 / (4.0 * Math.atan (1));
      lookbackTotal = 32 + (this.unstablePeriod[FuncUnstId.Mama.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingWMAIdx = startIdx - lookbackTotal;
      today = trailingWMAIdx;
      tempReal = inReal[today++];
      periodWMASub = tempReal;
      periodWMASum = tempReal;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*2.0;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*3.0;
      trailingWMAValue = 0.0;
      i = 9;
      do
      {
         tempReal = inReal[today++];
         { periodWMASub += tempReal; periodWMASub -= trailingWMAValue; periodWMASum += tempReal*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
      } while( --i != 0);
      hilbertIdx = 0;
      { detrender_Odd [0] = 0.0; detrender_Odd [1] = 0.0; detrender_Odd [2] = 0.0; detrender_Even [0] = 0.0; detrender_Even [1] = 0.0; detrender_Even [2] = 0.0; detrender = 0.0; prev_detrender_Odd = 0.0; prev_detrender_Even = 0.0; prev_detrender_input_Odd = 0.0; prev_detrender_input_Even = 0.0; } ;
      { Q1_Odd [0] = 0.0; Q1_Odd [1] = 0.0; Q1_Odd [2] = 0.0; Q1_Even [0] = 0.0; Q1_Even [1] = 0.0; Q1_Even [2] = 0.0; Q1 = 0.0; prev_Q1_Odd = 0.0; prev_Q1_Even = 0.0; prev_Q1_input_Odd = 0.0; prev_Q1_input_Even = 0.0; } ;
      { jI_Odd [0] = 0.0; jI_Odd [1] = 0.0; jI_Odd [2] = 0.0; jI_Even [0] = 0.0; jI_Even [1] = 0.0; jI_Even [2] = 0.0; jI = 0.0; prev_jI_Odd = 0.0; prev_jI_Even = 0.0; prev_jI_input_Odd = 0.0; prev_jI_input_Even = 0.0; } ;
      { jQ_Odd [0] = 0.0; jQ_Odd [1] = 0.0; jQ_Odd [2] = 0.0; jQ_Even [0] = 0.0; jQ_Even [1] = 0.0; jQ_Even [2] = 0.0; jQ = 0.0; prev_jQ_Odd = 0.0; prev_jQ_Even = 0.0; prev_jQ_input_Odd = 0.0; prev_jQ_input_Even = 0.0; } ;
      period = 0.0;
      outIdx = 0;
      prevI2 = prevQ2 = 0.0;
      Re = Im = 0.0;
      mama = fama = 0.0;
      I1ForOddPrev3 = I1ForEvenPrev3 = 0.0;
      I1ForOddPrev2 = I1ForEvenPrev2 = 0.0;
      prevPhase = 0.0;
      while( today <= endIdx )
      {
         adjustedPrevPeriod = (0.075*period)+0.54;
         todayValue = inReal[today];
         { periodWMASub += todayValue; periodWMASub -= trailingWMAValue; periodWMASum += todayValue*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
         if( (today%2) == 0 )
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Even [hilbertIdx]; detrender_Even [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Even ; prev_detrender_Even = b * prev_detrender_input_Even ; detrender += prev_detrender_Even ; prev_detrender_input_Even = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Even [hilbertIdx]; Q1_Even [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Even ; prev_Q1_Even = b * prev_Q1_input_Even ; Q1 += prev_Q1_Even ; prev_Q1_input_Even = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForEvenPrev3; jI = -jI_Even [hilbertIdx]; jI_Even [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Even ; prev_jI_Even = b * prev_jI_input_Even ; jI += prev_jI_Even ; prev_jI_input_Even = I1ForEvenPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Even [hilbertIdx]; jQ_Even [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Even ; prev_jQ_Even = b * prev_jQ_input_Even ; jQ += prev_jQ_Even ; prev_jQ_input_Even = Q1; jQ *= adjustedPrevPeriod; } ;
            if( ++hilbertIdx == 3 )
               hilbertIdx = 0;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForEvenPrev3 - jQ)) + (0.8*prevI2);
            I1ForOddPrev3 = I1ForOddPrev2;
            I1ForOddPrev2 = detrender;
            if( I1ForEvenPrev3 != 0.0 )
               tempReal2 = ( Math.atan (Q1/I1ForEvenPrev3)*rad2Deg);
            else
               tempReal2 = 0.0;
         }
         else
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Odd [hilbertIdx]; detrender_Odd [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Odd ; prev_detrender_Odd = b * prev_detrender_input_Odd ; detrender += prev_detrender_Odd ; prev_detrender_input_Odd = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Odd [hilbertIdx]; Q1_Odd [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Odd ; prev_Q1_Odd = b * prev_Q1_input_Odd ; Q1 += prev_Q1_Odd ; prev_Q1_input_Odd = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForOddPrev3; jI = -jI_Odd [hilbertIdx]; jI_Odd [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Odd ; prev_jI_Odd = b * prev_jI_input_Odd ; jI += prev_jI_Odd ; prev_jI_input_Odd = I1ForOddPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Odd [hilbertIdx]; jQ_Odd [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Odd ; prev_jQ_Odd = b * prev_jQ_input_Odd ; jQ += prev_jQ_Odd ; prev_jQ_input_Odd = Q1; jQ *= adjustedPrevPeriod; } ;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForOddPrev3 - jQ)) + (0.8*prevI2);
            I1ForEvenPrev3 = I1ForEvenPrev2;
            I1ForEvenPrev2 = detrender;
            if( I1ForOddPrev3 != 0.0 )
               tempReal2 = ( Math.atan (Q1/I1ForOddPrev3)*rad2Deg);
            else
               tempReal2 = 0.0;
         }
         tempReal = prevPhase - tempReal2;
         prevPhase = tempReal2;
         if( tempReal < 1.0 )
            tempReal = 1.0;
         if( tempReal > 1.0 )
         {
            tempReal = optInFastLimit/tempReal;
            if( tempReal < optInSlowLimit )
               tempReal = optInSlowLimit;
         }
         else
         {
            tempReal = optInFastLimit;
         }
         mama = (tempReal*todayValue)+((1-tempReal)*mama);
         tempReal *= 0.5;
         fama = (tempReal*mama)+((1-tempReal)*fama);
         if( today >= startIdx )
         {
            outMAMA[outIdx] = mama;
            outFAMA[outIdx++] = fama;
         }
         Re = (0.2*((I2*prevI2)+(Q2*prevQ2)))+(0.8*Re);
         Im = (0.2*((I2*prevQ2)-(Q2*prevI2)))+(0.8*Im);
         prevQ2 = Q2;
         prevI2 = I2;
         tempReal = period;
         if( (Im != 0.0) && (Re != 0.0) )
            period = 360.0 / ( Math.atan (Im/Re)*rad2Deg);
         tempReal2 = 1.5*tempReal;
         if( period > tempReal2)
            period = tempReal2;
         tempReal2 = 0.67*tempReal;
         if( period < tempReal2 )
            period = tempReal2;
         if( period < 6 )
            period = 6;
         else if( period > 50 )
            period = 50;
         period = (0.2*period) + (0.8 * tempReal);
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int movingAverageVariablePeriodLookback( int optInMinPeriod,
      int optInMaxPeriod,
      MAType optInMAType )
   {
      if( (int)optInMinPeriod == ( Integer.MIN_VALUE ) )
         optInMinPeriod = 2;
      else if( ((int)optInMinPeriod < 2) || ((int)optInMinPeriod > 100000) )
         return -1;
      if( (int)optInMaxPeriod == ( Integer.MIN_VALUE ) )
         optInMaxPeriod = 30;
      else if( ((int)optInMaxPeriod < 2) || ((int)optInMaxPeriod > 100000) )
         return -1;
      return movingAverageLookback (optInMaxPeriod, optInMAType);
   }
   public RetCode movingAverageVariablePeriod( int startIdx,
      int endIdx,
      double inReal[],
      double inPeriods[],
      int optInMinPeriod,
      int optInMaxPeriod,
      MAType optInMAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int i, j, lookbackTotal, outputSize, tempInt, curPeriod;
      int []localPeriodArray ;
      double []localOutputArray ;
      MInteger localBegIdx = new MInteger() ;
      MInteger localNbElement = new MInteger() ;
      RetCode retCode;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInMinPeriod == ( Integer.MIN_VALUE ) )
         optInMinPeriod = 2;
      else if( ((int)optInMinPeriod < 2) || ((int)optInMinPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInMaxPeriod == ( Integer.MIN_VALUE ) )
         optInMaxPeriod = 30;
      else if( ((int)optInMaxPeriod < 2) || ((int)optInMaxPeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = movingAverageLookback (optInMaxPeriod,optInMAType);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      if( lookbackTotal > startIdx )
         tempInt = lookbackTotal;
      else
         tempInt = startIdx;
      if( tempInt > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outputSize = endIdx - tempInt + 1;
      localOutputArray = new double[outputSize] ;
      localPeriodArray = new int[outputSize] ;
      for( i=0; i < outputSize; i++ )
      {
         tempInt = (int)(inPeriods[startIdx+i]);
         if( tempInt < optInMinPeriod )
            tempInt = optInMinPeriod;
         else if( tempInt > optInMaxPeriod )
            tempInt = optInMaxPeriod;
         localPeriodArray[i] = tempInt;
      }
      for( i=0; i < outputSize; i++ )
      {
         curPeriod = localPeriodArray[i];
         if( curPeriod != 0 )
         {
            retCode = movingAverage ( startIdx, endIdx, inReal,
               curPeriod, optInMAType,
               localBegIdx , localNbElement ,localOutputArray );
            if( retCode != RetCode.Success )
            {
               outBegIdx.value = 0 ;
               outNBElement.value = 0 ;
               return retCode;
            }
            outReal[i] = localOutputArray[i];
            for( j=i+1; j < outputSize; j++ )
            {
               if( localPeriodArray[j] == curPeriod )
               {
                  localPeriodArray[j] = 0;
                  outReal[j] = localOutputArray[j];
               }
            }
         }
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outputSize;
      return RetCode.Success ;
   }
   public RetCode movingAverageVariablePeriodStateInit( struct TA_movingAverageVariablePeriod_State** _state,
      int optInMinPeriod,
      int optInMaxPeriod,
      MAType optInMAType )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInMinPeriod == ( Integer.MIN_VALUE ) )
         optInMinPeriod = 2;
      else if( ((int)optInMinPeriod < 2) || ((int)optInMinPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInMaxPeriod == ( Integer.MIN_VALUE ) )
         optInMaxPeriod = 30;
      else if( ((int)optInMaxPeriod < 2) || ((int)optInMaxPeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct movingAverageVariablePeriod ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInMinPeriod = optInMinPeriod;
      _state.value .value .optInMaxPeriod = optInMaxPeriod;
      _state.value .value .optInMAType = optInMAType;
      _state.value .value .mem_size = movingAverageVariablePeriodLookback (optInMinPeriod, optInMaxPeriod, optInMAType );
      _state.value .value .memory = NULL;
      return movingAverage ((struct movingAverage **)& _state.value .value .MAState, _state.value .value .optInMaxPeriod, _state.value .value .optInMAType );
   }
   public RetCode movingAverageVariablePeriodState( struct TA_movingAverageVariablePeriod_State* _state,
      double inReal,
      double inPeriods,
      double *outReal )
   {
      double period;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if (inPeriods > _state.value .optInMaxPeriod) period = _state.value .optInMaxPeriod;
      else if(inPeriods < _state.value .optInMinPeriod) period = _state.value .optInMinPeriod;
      else period = inPeriods;
      struct movingAverage * ma_state = (struct movingAverage *) _state.value .MAState;
      ma_state->optInTimePeriod = period;
      return movingAverage ( ma_state, inReal, outReal );
   }
   public RetCode movingAverageVariablePeriodStateFree( struct TA_movingAverageVariablePeriod_State** _state )
   {
      movingAverage ((struct movingAverage **)& _state.value .value .MAState);
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode movingAverageVariablePeriodStateSave( struct TA_movingAverageVariablePeriod_State* _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_MAVP_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInMinPeriod,sizeof( _state.value .optInMinPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInMaxPeriod,sizeof( _state.value .optInMaxPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInMAType,sizeof( _state.value .optInMAType),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_MA_StateSave ( (struct movingAverage *) _state.value .MAState, _file );
      return retCode;
   }
   public RetCode movingAverageVariablePeriodStateLoad( struct TA_movingAverageVariablePeriod_State** _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct movingAverageVariablePeriod ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_MAVP_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_MAVP_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInMinPeriod,sizeof( _state.value .value .optInMinPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInMaxPeriod,sizeof( _state.value .value .optInMaxPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInMAType,sizeof( _state.value .value .optInMAType),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_MA_StateLoad ( (struct movingAverage **) & _state.value .value .MAState, _file );
      return retCode;
   }
   public RetCode movingAverageVariablePeriod( int startIdx,
      int endIdx,
      float inReal[],
      float inPeriods[],
      int optInMinPeriod,
      int optInMaxPeriod,
      MAType optInMAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int i, j, lookbackTotal, outputSize, tempInt, curPeriod;
      int []localPeriodArray ;
      double []localOutputArray ;
      MInteger localBegIdx = new MInteger() ;
      MInteger localNbElement = new MInteger() ;
      RetCode retCode;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInMinPeriod == ( Integer.MIN_VALUE ) )
         optInMinPeriod = 2;
      else if( ((int)optInMinPeriod < 2) || ((int)optInMinPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInMaxPeriod == ( Integer.MIN_VALUE ) )
         optInMaxPeriod = 30;
      else if( ((int)optInMaxPeriod < 2) || ((int)optInMaxPeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = movingAverageLookback (optInMaxPeriod,optInMAType);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      if( lookbackTotal > startIdx )
         tempInt = lookbackTotal;
      else
         tempInt = startIdx;
      if( tempInt > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outputSize = endIdx - tempInt + 1;
      localOutputArray = new double[outputSize] ;
      localPeriodArray = new int[outputSize] ;
      for( i=0; i < outputSize; i++ )
      {
         tempInt = (int)(inPeriods[startIdx+i]);
         if( tempInt < optInMinPeriod )
            tempInt = optInMinPeriod;
         else if( tempInt > optInMaxPeriod )
            tempInt = optInMaxPeriod;
         localPeriodArray[i] = tempInt;
      }
      for( i=0; i < outputSize; i++ )
      {
         curPeriod = localPeriodArray[i];
         if( curPeriod != 0 )
         {
            retCode = movingAverage ( startIdx, endIdx, inReal,
               curPeriod, optInMAType,
               localBegIdx , localNbElement ,localOutputArray );
            if( retCode != RetCode.Success )
            {
               outBegIdx.value = 0 ;
               outNBElement.value = 0 ;
               return retCode;
            }
            outReal[i] = localOutputArray[i];
            for( j=i+1; j < outputSize; j++ )
            {
               if( localPeriodArray[j] == curPeriod )
               {
                  localPeriodArray[j] = 0;
                  outReal[j] = localOutputArray[j];
               }
            }
         }
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outputSize;
      return RetCode.Success ;
   }
   /* Generated */
   public int maxLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return (optInTimePeriod-1);
   }
   public RetCode max( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double highest, tmp;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, today, i, highestIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      highestIdx = -1;
      highest = 0.0;
      while( today <= endIdx )
      {
         tmp = inReal[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inReal[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmp = inReal[i];
               if( tmp > highest )
               {
                  highestIdx = i;
                  highest = tmp;
               }
            }
         }
         else if( tmp >= highest )
         {
            highestIdx = today;
            highest = tmp;
         }
         outReal[outIdx++] = highest;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode maxStateInit( struct TA_max_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct max ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = maxLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode maxState( struct TA_max_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
         _state.value .max = inReal;
      else
         if( _state.value .max < inReal )
         _state.value .max = inReal;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      outReal.value = _state.value .max;
      return RetCode.Success ;
   }
   public RetCode maxStateFree( struct TA_max_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode maxStateSave( struct TA_max_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_MAX_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .max,sizeof( _state.value .max),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode maxStateLoad( struct TA_max_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct max ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_MAX_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_MAX_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .max,sizeof( _state.value .value .max),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode max( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double highest, tmp;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, today, i, highestIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      highestIdx = -1;
      highest = 0.0;
      while( today <= endIdx )
      {
         tmp = inReal[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inReal[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmp = inReal[i];
               if( tmp > highest )
               {
                  highestIdx = i;
                  highest = tmp;
               }
            }
         }
         else if( tmp >= highest )
         {
            highestIdx = today;
            highest = tmp;
         }
         outReal[outIdx++] = highest;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int maxIndexLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return (optInTimePeriod-1);
   }
   public RetCode maxIndex( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double highest, tmp;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, today, i, highestIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      highestIdx = -1;
      highest = 0.0;
      while( today <= endIdx )
      {
         tmp = inReal[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inReal[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmp = inReal[i];
               if( tmp > highest )
               {
                  highestIdx = i;
                  highest = tmp;
               }
            }
         }
         else if( tmp >= highest )
         {
            highestIdx = today;
            highest = tmp;
         }
         outInteger[outIdx++] = highestIdx;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode maxIndexStateInit( struct TA_maxIndex_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct maxIndex ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = maxIndexLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode maxIndexState( struct TA_maxIndex_State* _state,
      double inReal,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .max = inReal;
         _state.value .maxIdx = 0;
         _state.value .currentIdx = 0;
      } else
         ++ _state.value .currentIdx;
      if( _state.value .max < inReal )
      {
         _state.value .max = inReal;
         _state.value .maxIdx = _state.value .currentIdx;
      } else
         if( _state.value .max == inReal )
         _state.value .maxIdx = _state.value .currentIdx;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      outInteger.value = _state.value .maxIdx;
      return RetCode.Success ;
   }
   public RetCode maxIndexStateFree( struct TA_maxIndex_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode maxIndexStateSave( struct TA_maxIndex_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_MAXINDEX_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .max,sizeof( _state.value .max),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .maxIdx,sizeof( _state.value .maxIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .currentIdx,sizeof( _state.value .currentIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode maxIndexStateLoad( struct TA_maxIndex_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct maxIndex ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_MAXINDEX_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_MAXINDEX_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .max,sizeof( _state.value .value .max),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .maxIdx,sizeof( _state.value .value .maxIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .currentIdx,sizeof( _state.value .value .currentIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode maxIndex( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double highest, tmp;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, today, i, highestIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      highestIdx = -1;
      highest = 0.0;
      while( today <= endIdx )
      {
         tmp = inReal[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inReal[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmp = inReal[i];
               if( tmp > highest )
               {
                  highestIdx = i;
                  highest = tmp;
               }
            }
         }
         else if( tmp >= highest )
         {
            highestIdx = today;
            highest = tmp;
         }
         outInteger[outIdx++] = highestIdx;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int medPriceLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode medPrice( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      outIdx = 0;
      for( i=startIdx; i <= endIdx; i++ )
      {
         outReal[outIdx++] = (inHigh[i]+inLow[i])/2.0;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode medPriceStateInit( struct TA_medPrice_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct medPrice ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = medPriceLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_MEDPRICE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode medPriceState( struct TA_medPrice_State* _state,
      double inHigh,
      double inLow,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         return RetCode.NeedMoreData ; }
      outReal.value = (inHigh+inLow)/2.0;
      return RetCode.Success ;
   }
   public RetCode medPriceStateFree( struct TA_medPrice_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode medPriceStateSave( struct TA_medPrice_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_MEDPRICE_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode medPriceStateLoad( struct TA_medPrice_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct medPrice ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_MEDPRICE_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_MEDPRICE_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode medPrice( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      outIdx = 0;
      for( i=startIdx; i <= endIdx; i++ )
      {
         outReal[outIdx++] = (inHigh[i]+inLow[i])/2.0;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int mfiLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod + (this.unstablePeriod[FuncUnstId.Mfi.ordinal()]) ;
   }
   public RetCode mfi( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      double inVolume[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double posSumMF, negSumMF, prevValue;
      double tempValue1, tempValue2;
      int lookbackTotal, outIdx, i, today;
      int mflow_Idx = 0; MoneyFlow []mflow; int maxIdx_mflow = (50-1) ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      { if( optInTimePeriod <= 0 ) return RetCode.AllocErr ; mflow = new MoneyFlow[optInTimePeriod]; for( int _mflow_index =0; _mflow_index <mflow.length; _mflow_index ++) { mflow[_mflow_index ]=new MoneyFlow(); } maxIdx_mflow = (optInTimePeriod-1); } ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      lookbackTotal = optInTimePeriod + (this.unstablePeriod[FuncUnstId.Mfi.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx-lookbackTotal;
      prevValue = (inHigh[today]+inLow[today]+inClose[today])/3.0;
      posSumMF = 0.0;
      negSumMF = 0.0;
      today++;
      for( i=optInTimePeriod; i > 0; i-- )
      {
         tempValue1 = (inHigh[today]+inLow[today]+inClose[today])/3.0;
         tempValue2 = tempValue1 - prevValue;
         prevValue = tempValue1;
         tempValue1 *= inVolume[today++];
         if( tempValue2 < 0 )
         {
            (mflow[mflow_Idx]). negative = tempValue1;
            negSumMF += tempValue1;
            (mflow[mflow_Idx]). positive = 0.0;
         }
         else if( tempValue2 > 0 )
         {
            (mflow[mflow_Idx]). positive = tempValue1;
            posSumMF += tempValue1;
            (mflow[mflow_Idx]). negative = 0.0;
         }
         else
         {
            (mflow[mflow_Idx]). positive = 0.0;
            (mflow[mflow_Idx]). negative = 0.0;
         }
         { mflow_Idx ++; if( mflow_Idx > maxIdx_mflow ) mflow_Idx = 0; } ;
      }
      if( today > startIdx )
      {
         tempValue1 = posSumMF+negSumMF;
         if( tempValue1 < 1.0 )
            outReal[outIdx++] = 0.0;
         else
            outReal[outIdx++] = 100.0*(posSumMF/tempValue1);
      }
      else
      {
         while( today < startIdx )
         {
            posSumMF -= (mflow[mflow_Idx]). positive;
            negSumMF -= (mflow[mflow_Idx]). negative;
            tempValue1 = (inHigh[today]+inLow[today]+inClose[today])/3.0;
            tempValue2 = tempValue1 - prevValue;
            prevValue = tempValue1;
            tempValue1 *= inVolume[today++];
            if( tempValue2 < 0 )
            {
               (mflow[mflow_Idx]). negative = tempValue1;
               negSumMF += tempValue1;
               (mflow[mflow_Idx]). positive = 0.0;
            }
            else if( tempValue2 > 0 )
            {
               (mflow[mflow_Idx]). positive = tempValue1;
               posSumMF += tempValue1;
               (mflow[mflow_Idx]). negative = 0.0;
            }
            else
            {
               (mflow[mflow_Idx]). positive = 0.0;
               (mflow[mflow_Idx]). negative = 0.0;
            }
            { mflow_Idx ++; if( mflow_Idx > maxIdx_mflow ) mflow_Idx = 0; } ;
         }
      }
      while( today <= endIdx )
      {
         posSumMF -= (mflow[mflow_Idx]). positive;
         negSumMF -= (mflow[mflow_Idx]). negative;
         tempValue1 = (inHigh[today]+inLow[today]+inClose[today])/3.0;
         tempValue2 = tempValue1 - prevValue;
         prevValue = tempValue1;
         tempValue1 *= inVolume[today++];
         if( tempValue2 < 0 )
         {
            (mflow[mflow_Idx]). negative = tempValue1;
            negSumMF += tempValue1;
            (mflow[mflow_Idx]). positive = 0.0;
         }
         else if( tempValue2 > 0 )
         {
            (mflow[mflow_Idx]). positive = tempValue1;
            posSumMF += tempValue1;
            (mflow[mflow_Idx]). negative = 0.0;
         }
         else
         {
            (mflow[mflow_Idx]). positive = 0.0;
            (mflow[mflow_Idx]). negative = 0.0;
         }
         tempValue1 = posSumMF+negSumMF;
         if( tempValue1 < 1.0 )
            outReal[outIdx++] = 0.0;
         else
            outReal[outIdx++] = 100.0*(posSumMF/tempValue1);
         { mflow_Idx ++; if( mflow_Idx > maxIdx_mflow ) mflow_Idx = 0; } ;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   struct TA_MFI_STATE_CIRCBUF { int idx; MoneyFlow* circbuf; int size; };
   public RetCode mfiStateInit( struct TA_mfi_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct mfi ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = mfiLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_MFI_Data));
      else
         _state.value .value .memory = NULL;
      { _state.value .value .mflow = calloc(1, sizeof(struct TA_MFI_STATE_CIRCBUF )); if ( _state.value .value .mflow == NULL) return RetCode.AllocErr ; struct TA_MFI_STATE_CIRCBUF * buf = (struct TA_MFI_STATE_CIRCBUF *) _state.value .value .mflow; buf->idx = 0; buf->size = _state.value .value .optInTimePeriod; buf->circbuf = calloc(_state.value .value .optInTimePeriod, sizeof(MoneyFlow)); if (!buf->circbuf) return RetCode.AllocErr ;} ;
      return RetCode.Success ;
   }
   public RetCode mfiState( struct TA_mfi_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double inVolume,
      double *outReal )
   {
      double tempValue1, tempValue2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .prevValue = (inHigh+inLow+inClose)/3.0;
         _state.value .posSumMF = 0;
         _state.value .negSumMF = 0;
         return RetCode.NeedMoreData ;
      }
      if ( _state.value .mem_index-1 > (unsigned int) _state.value .optInTimePeriod)
      {
         _state.value .posSumMF -= (*( ((struct TA_MFI_STATE_CIRCBUF *) _state.value .mflow)->circbuf + ((struct TA_MFI_STATE_CIRCBUF *) _state.value .mflow)->idx )) .positive;
         _state.value .negSumMF -= (*( ((struct TA_MFI_STATE_CIRCBUF *) _state.value .mflow)->circbuf + ((struct TA_MFI_STATE_CIRCBUF *) _state.value .mflow)->idx )) .negative;
      }
      tempValue1 = (inHigh+inLow+inClose)/3.0;
      tempValue2 = tempValue1 - _state.value .prevValue;
      _state.value .prevValue = tempValue1;
      tempValue1 *= inVolume;
      if( tempValue2 < 0 )
      {
         (*( ((struct TA_MFI_STATE_CIRCBUF *) _state.value .mflow)->circbuf + ((struct TA_MFI_STATE_CIRCBUF *) _state.value .mflow)->idx )) .negative = tempValue1;
         _state.value .negSumMF += tempValue1;
         (*( ((struct TA_MFI_STATE_CIRCBUF *) _state.value .mflow)->circbuf + ((struct TA_MFI_STATE_CIRCBUF *) _state.value .mflow)->idx )) .positive = 0.0;
      }
      else if( tempValue2 > 0 )
      {
         (*( ((struct TA_MFI_STATE_CIRCBUF *) _state.value .mflow)->circbuf + ((struct TA_MFI_STATE_CIRCBUF *) _state.value .mflow)->idx )) .positive = tempValue1;
         _state.value .posSumMF += tempValue1;
         (*( ((struct TA_MFI_STATE_CIRCBUF *) _state.value .mflow)->circbuf + ((struct TA_MFI_STATE_CIRCBUF *) _state.value .mflow)->idx )) .negative = 0.0;
      }
      else
      {
         (*( ((struct TA_MFI_STATE_CIRCBUF *) _state.value .mflow)->circbuf + ((struct TA_MFI_STATE_CIRCBUF *) _state.value .mflow)->idx )) .positive = 0.0;
         (*( ((struct TA_MFI_STATE_CIRCBUF *) _state.value .mflow)->circbuf + ((struct TA_MFI_STATE_CIRCBUF *) _state.value .mflow)->idx )) .negative = 0.0;
      }
      { struct TA_MFI_STATE_CIRCBUF * buf = (struct TA_MFI_STATE_CIRCBUF *) _state.value .mflow; if(buf->idx < buf->size-1) buf->idx++; else buf->idx = 0;} ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      tempValue1 = _state.value .posSumMF + _state.value .negSumMF;
      if( tempValue1 < 1.0 )
         outReal.value = 0.0;
      else
         outReal.value = 100.0*( _state.value .posSumMF/tempValue1);
      return RetCode.Success ;
   }
   public RetCode mfiStateFree( struct TA_mfi_State** _state )
   {
      { struct TA_MFI_STATE_CIRCBUF * buf = (struct TA_MFI_STATE_CIRCBUF *) _state.value .value .mflow; if (buf != NULL) { if (buf->circbuf != NULL) free(buf->circbuf); free (buf); _state.value .value .mflow = NULL; } } ;
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode mfiStateSave( struct TA_mfi_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_MFI_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevValue,sizeof( _state.value .prevValue),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .posSumMF,sizeof( _state.value .posSumMF),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .negSumMF,sizeof( _state.value .negSumMF),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      { int io_circbuf_res; struct TA_MFI_STATE_CIRCBUF * str_circbuf = _state.value .mflow; io_circbuf_res = fwrite(&str_circbuf->idx,sizeof(str_circbuf->idx),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; io_circbuf_res = fwrite(&str_circbuf->size,sizeof(str_circbuf->size),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; if (str_circbuf->size > 0) { io_circbuf_res = fwrite(str_circbuf->circbuf,sizeof(str_circbuf->circbuf),str_circbuf->size,_file); if (io_circbuf_res < str_circbuf->size) return RetCode.IOFailed ; } }
      return 0;
   }
   public RetCode mfiStateLoad( struct TA_mfi_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct mfi ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_MFI_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_MFI_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevValue,sizeof( _state.value .value .prevValue),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .posSumMF,sizeof( _state.value .value .posSumMF),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .negSumMF,sizeof( _state.value .value .negSumMF),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      { int io_circbuf_res; int circbuf_idx; int circbuf_size; if ( _state.value .value .mflow != NULL) return RetCode.BadParam ; io_circbuf_res = fread(&circbuf_idx,sizeof(circbuf_idx),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; io_circbuf_res = fread(&circbuf_size,sizeof(circbuf_size),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; { _state.value .value .mflow = calloc(1, sizeof(struct TA_MFI_STATE_CIRCBUF )); if ( _state.value .value .mflow == NULL) return RetCode.AllocErr ; struct TA_MFI_STATE_CIRCBUF * buf = (struct TA_MFI_STATE_CIRCBUF *) _state.value .value .mflow; buf->idx = 0; buf->size = circbuf_size; buf->circbuf = calloc(circbuf_size, sizeof(MoneyFlow)); if (!buf->circbuf) return RetCode.AllocErr ;} struct TA_MFI_STATE_CIRCBUF * str_circbuf = _state.value .value .mflow; str_circbuf->idx = circbuf_idx; if (str_circbuf->size > 0) { io_circbuf_res = fread(str_circbuf->circbuf,sizeof(str_circbuf->circbuf),str_circbuf->size,_file); if (io_circbuf_res < str_circbuf->size) return RetCode.IOFailed ; } }
      return 0;
   }
   public RetCode mfi( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      float inVolume[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double posSumMF, negSumMF, prevValue;
      double tempValue1, tempValue2;
      int lookbackTotal, outIdx, i, today;
      int mflow_Idx = 0; MoneyFlow []mflow; int maxIdx_mflow = (50-1) ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      { if( optInTimePeriod <= 0 ) return RetCode.AllocErr ; mflow = new MoneyFlow[optInTimePeriod]; for( int _mflow_index =0; _mflow_index <mflow.length; _mflow_index ++) { mflow[_mflow_index ]=new MoneyFlow(); } maxIdx_mflow = (optInTimePeriod-1); } ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      lookbackTotal = optInTimePeriod + (this.unstablePeriod[FuncUnstId.Mfi.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx-lookbackTotal;
      prevValue = (inHigh[today]+inLow[today]+inClose[today])/3.0;
      posSumMF = 0.0;
      negSumMF = 0.0;
      today++;
      for( i=optInTimePeriod; i > 0; i-- )
      {
         tempValue1 = (inHigh[today]+inLow[today]+inClose[today])/3.0;
         tempValue2 = tempValue1 - prevValue;
         prevValue = tempValue1;
         tempValue1 *= inVolume[today++];
         if( tempValue2 < 0 )
         {
            (mflow[mflow_Idx]). negative = tempValue1;
            negSumMF += tempValue1;
            (mflow[mflow_Idx]). positive = 0.0;
         }
         else if( tempValue2 > 0 )
         {
            (mflow[mflow_Idx]). positive = tempValue1;
            posSumMF += tempValue1;
            (mflow[mflow_Idx]). negative = 0.0;
         }
         else
         {
            (mflow[mflow_Idx]). positive = 0.0;
            (mflow[mflow_Idx]). negative = 0.0;
         }
         { mflow_Idx ++; if( mflow_Idx > maxIdx_mflow ) mflow_Idx = 0; } ;
      }
      if( today > startIdx )
      {
         tempValue1 = posSumMF+negSumMF;
         if( tempValue1 < 1.0 )
            outReal[outIdx++] = 0.0;
         else
            outReal[outIdx++] = 100.0*(posSumMF/tempValue1);
      }
      else
      {
         while( today < startIdx )
         {
            posSumMF -= (mflow[mflow_Idx]). positive;
            negSumMF -= (mflow[mflow_Idx]). negative;
            tempValue1 = (inHigh[today]+inLow[today]+inClose[today])/3.0;
            tempValue2 = tempValue1 - prevValue;
            prevValue = tempValue1;
            tempValue1 *= inVolume[today++];
            if( tempValue2 < 0 )
            {
               (mflow[mflow_Idx]). negative = tempValue1;
               negSumMF += tempValue1;
               (mflow[mflow_Idx]). positive = 0.0;
            }
            else if( tempValue2 > 0 )
            {
               (mflow[mflow_Idx]). positive = tempValue1;
               posSumMF += tempValue1;
               (mflow[mflow_Idx]). negative = 0.0;
            }
            else
            {
               (mflow[mflow_Idx]). positive = 0.0;
               (mflow[mflow_Idx]). negative = 0.0;
            }
            { mflow_Idx ++; if( mflow_Idx > maxIdx_mflow ) mflow_Idx = 0; } ;
         }
      }
      while( today <= endIdx )
      {
         posSumMF -= (mflow[mflow_Idx]). positive;
         negSumMF -= (mflow[mflow_Idx]). negative;
         tempValue1 = (inHigh[today]+inLow[today]+inClose[today])/3.0;
         tempValue2 = tempValue1 - prevValue;
         prevValue = tempValue1;
         tempValue1 *= inVolume[today++];
         if( tempValue2 < 0 )
         {
            (mflow[mflow_Idx]). negative = tempValue1;
            negSumMF += tempValue1;
            (mflow[mflow_Idx]). positive = 0.0;
         }
         else if( tempValue2 > 0 )
         {
            (mflow[mflow_Idx]). positive = tempValue1;
            posSumMF += tempValue1;
            (mflow[mflow_Idx]). negative = 0.0;
         }
         else
         {
            (mflow[mflow_Idx]). positive = 0.0;
            (mflow[mflow_Idx]). negative = 0.0;
         }
         tempValue1 = posSumMF+negSumMF;
         if( tempValue1 < 1.0 )
            outReal[outIdx++] = 0.0;
         else
            outReal[outIdx++] = 100.0*(posSumMF/tempValue1);
         { mflow_Idx ++; if( mflow_Idx > maxIdx_mflow ) mflow_Idx = 0; } ;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int midPointLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return (optInTimePeriod-1);
   }
   public RetCode midPoint( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double lowest, highest, tmp;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      while( today <= endIdx )
      {
         lowest = inReal[trailingIdx++];
         highest = lowest;
         for( i=trailingIdx; i <= today; i++ )
         {
            tmp = inReal[i];
            if( tmp < lowest ) lowest= tmp;
            else if( tmp > highest) highest = tmp;
         }
         outReal[outIdx++] = (highest+lowest)/2.0;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode midPointStateInit( struct TA_midPoint_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct midPoint ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = midPointLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode midPointState( struct TA_midPoint_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .highest = inReal;
         _state.value .lowest = inReal;
      } else {
         if( _state.value .lowest > inReal )
            _state.value .lowest = inReal;
         if( _state.value .highest < inReal )
            _state.value .highest = inReal;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      outReal.value = ( _state.value .highest+ _state.value .lowest)/2.0;
      return RetCode.Success ;
   }
   public RetCode midPointStateFree( struct TA_midPoint_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode midPointStateSave( struct TA_midPoint_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_MIDPOINT_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .highest,sizeof( _state.value .highest),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .lowest,sizeof( _state.value .lowest),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode midPointStateLoad( struct TA_midPoint_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct midPoint ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_MIDPOINT_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_MIDPOINT_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .highest,sizeof( _state.value .value .highest),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .lowest,sizeof( _state.value .value .lowest),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode midPoint( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double lowest, highest, tmp;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      while( today <= endIdx )
      {
         lowest = inReal[trailingIdx++];
         highest = lowest;
         for( i=trailingIdx; i <= today; i++ )
         {
            tmp = inReal[i];
            if( tmp < lowest ) lowest= tmp;
            else if( tmp > highest) highest = tmp;
         }
         outReal[outIdx++] = (highest+lowest)/2.0;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int midPriceLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return (optInTimePeriod-1);
   }
   public RetCode midPrice( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double lowest, highest, tmp;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      while( today <= endIdx )
      {
         lowest = inLow[trailingIdx];
         highest = inHigh[trailingIdx];
         trailingIdx++;
         for( i=trailingIdx; i <= today; i++ )
         {
            tmp = inLow[i];
            if( tmp < lowest ) lowest= tmp;
            tmp = inHigh[i];
            if( tmp > highest) highest = tmp;
         }
         outReal[outIdx++] = (highest+lowest)/2.0;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode midPriceStateInit( struct TA_midPrice_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct midPrice ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = midPriceLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode midPriceState( struct TA_midPrice_State* _state,
      double inHigh,
      double inLow,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .highest = inHigh;
         _state.value .lowest = inLow;
      } else {
         if( _state.value .lowest > inLow )
            _state.value .lowest = inLow;
         if( _state.value .highest < inHigh )
            _state.value .highest = inHigh;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      outReal.value = ( _state.value .highest+ _state.value .lowest)/2.0;
      return RetCode.Success ;
   }
   public RetCode midPriceStateFree( struct TA_midPrice_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode midPriceStateSave( struct TA_midPrice_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_MIDPRICE_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .highest,sizeof( _state.value .highest),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .lowest,sizeof( _state.value .lowest),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode midPriceStateLoad( struct TA_midPrice_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct midPrice ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_MIDPRICE_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_MIDPRICE_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .highest,sizeof( _state.value .value .highest),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .lowest,sizeof( _state.value .value .lowest),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode midPrice( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double lowest, highest, tmp;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      while( today <= endIdx )
      {
         lowest = inLow[trailingIdx];
         highest = inHigh[trailingIdx];
         trailingIdx++;
         for( i=trailingIdx; i <= today; i++ )
         {
            tmp = inLow[i];
            if( tmp < lowest ) lowest= tmp;
            tmp = inHigh[i];
            if( tmp > highest) highest = tmp;
         }
         outReal[outIdx++] = (highest+lowest)/2.0;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int minLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return (optInTimePeriod-1);
   }
   public RetCode min( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double lowest, tmp;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, lowestIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      lowestIdx = -1;
      lowest = 0.0;
      while( today <= endIdx )
      {
         tmp = inReal[today];
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inReal[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmp = inReal[i];
               if( tmp < lowest )
               {
                  lowestIdx = i;
                  lowest = tmp;
               }
            }
         }
         else if( tmp <= lowest )
         {
            lowestIdx = today;
            lowest = tmp;
         }
         outReal[outIdx++] = lowest;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode minStateInit( struct TA_min_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct min ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = minLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode minState( struct TA_min_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
         _state.value .min = inReal;
      else
         if( _state.value .min > inReal )
         _state.value .min = inReal;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      outReal.value = _state.value .min;
      return RetCode.Success ;
   }
   public RetCode minStateFree( struct TA_min_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode minStateSave( struct TA_min_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_MIN_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .min,sizeof( _state.value .min),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode minStateLoad( struct TA_min_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct min ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_MIN_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_MIN_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .min,sizeof( _state.value .value .min),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode min( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double lowest, tmp;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, lowestIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      lowestIdx = -1;
      lowest = 0.0;
      while( today <= endIdx )
      {
         tmp = inReal[today];
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inReal[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmp = inReal[i];
               if( tmp < lowest )
               {
                  lowestIdx = i;
                  lowest = tmp;
               }
            }
         }
         else if( tmp <= lowest )
         {
            lowestIdx = today;
            lowest = tmp;
         }
         outReal[outIdx++] = lowest;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int minIndexLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return (optInTimePeriod-1);
   }
   public RetCode minIndex( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double lowest, tmp;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, lowestIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      lowestIdx = -1;
      lowest = 0.0;
      while( today <= endIdx )
      {
         tmp = inReal[today];
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inReal[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmp = inReal[i];
               if( tmp < lowest )
               {
                  lowestIdx = i;
                  lowest = tmp;
               }
            }
         }
         else if( tmp <= lowest )
         {
            lowestIdx = today;
            lowest = tmp;
         }
         outInteger[outIdx++] = lowestIdx;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode minIndexStateInit( struct TA_minIndex_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct minIndex ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = minIndexLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode minIndexState( struct TA_minIndex_State* _state,
      double inReal,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .min = inReal;
         _state.value .minIdx = 0;
         _state.value .currentIdx = 0;
      } else
         ++ _state.value .currentIdx;
      if( _state.value .min > inReal )
      {
         _state.value .min = inReal;
         _state.value .minIdx = _state.value .currentIdx;
      } else
         if( _state.value .min == inReal )
         _state.value .minIdx = _state.value .currentIdx;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      outInteger.value = _state.value .minIdx;
      return RetCode.Success ;
   }
   public RetCode minIndexStateFree( struct TA_minIndex_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode minIndexStateSave( struct TA_minIndex_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_MININDEX_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .min,sizeof( _state.value .min),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .minIdx,sizeof( _state.value .minIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .currentIdx,sizeof( _state.value .currentIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode minIndexStateLoad( struct TA_minIndex_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct minIndex ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_MININDEX_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_MININDEX_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .min,sizeof( _state.value .value .min),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .minIdx,sizeof( _state.value .value .minIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .currentIdx,sizeof( _state.value .value .currentIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode minIndex( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double lowest, tmp;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, lowestIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      lowestIdx = -1;
      lowest = 0.0;
      while( today <= endIdx )
      {
         tmp = inReal[today];
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inReal[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmp = inReal[i];
               if( tmp < lowest )
               {
                  lowestIdx = i;
                  lowest = tmp;
               }
            }
         }
         else if( tmp <= lowest )
         {
            lowestIdx = today;
            lowest = tmp;
         }
         outInteger[outIdx++] = lowestIdx;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int minMaxLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return (optInTimePeriod-1);
   }
   public RetCode minMax( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outMin[],
      double outMax[] )
   {
      double highest, lowest, tmpHigh, tmpLow;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, today, i, highestIdx, lowestIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      highestIdx = -1;
      highest = 0.0;
      lowestIdx = -1;
      lowest = 0.0;
      while( today <= endIdx )
      {
         tmpLow = tmpHigh = inReal[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inReal[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmpHigh = inReal[i];
               if( tmpHigh > highest )
               {
                  highestIdx = i;
                  highest = tmpHigh;
               }
            }
         }
         else if( tmpHigh >= highest )
         {
            highestIdx = today;
            highest = tmpHigh;
         }
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inReal[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmpLow = inReal[i];
               if( tmpLow < lowest )
               {
                  lowestIdx = i;
                  lowest = tmpLow;
               }
            }
         }
         else if( tmpLow <= lowest )
         {
            lowestIdx = today;
            lowest = tmpLow;
         }
         outMax[outIdx] = highest;
         outMin[outIdx] = lowest;
         outIdx++;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode minMaxStateInit( struct TA_minMax_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct minMax ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = minMaxLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode minMaxState( struct TA_minMax_State* _state,
      double inReal,
      double *outMin,
      double *outMax )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .min = inReal;
         _state.value .max = inReal;
      } else {
         if( _state.value .min > inReal )
            _state.value .min = inReal;
         if( _state.value .max < inReal )
            _state.value .max = inReal;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      outMin.value = _state.value .min;
      outMax.value = _state.value .max;
      return RetCode.Success ;
   }
   public RetCode minMaxStateFree( struct TA_minMax_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode minMaxStateSave( struct TA_minMax_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_MINMAX_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .min,sizeof( _state.value .min),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .max,sizeof( _state.value .max),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode minMaxStateLoad( struct TA_minMax_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct minMax ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_MINMAX_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_MINMAX_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .min,sizeof( _state.value .value .min),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .max,sizeof( _state.value .value .max),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode minMax( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outMin[],
      double outMax[] )
   {
      double highest, lowest, tmpHigh, tmpLow;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, today, i, highestIdx, lowestIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      highestIdx = -1;
      highest = 0.0;
      lowestIdx = -1;
      lowest = 0.0;
      while( today <= endIdx )
      {
         tmpLow = tmpHigh = inReal[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inReal[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmpHigh = inReal[i];
               if( tmpHigh > highest )
               {
                  highestIdx = i;
                  highest = tmpHigh;
               }
            }
         }
         else if( tmpHigh >= highest )
         {
            highestIdx = today;
            highest = tmpHigh;
         }
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inReal[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmpLow = inReal[i];
               if( tmpLow < lowest )
               {
                  lowestIdx = i;
                  lowest = tmpLow;
               }
            }
         }
         else if( tmpLow <= lowest )
         {
            lowestIdx = today;
            lowest = tmpLow;
         }
         outMax[outIdx] = highest;
         outMin[outIdx] = lowest;
         outIdx++;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int minMaxIndexLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return (optInTimePeriod-1);
   }
   public RetCode minMaxIndex( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outMinIdx[],
      int outMaxIdx[] )
   {
      double highest, lowest, tmpHigh, tmpLow;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, today, i, highestIdx, lowestIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      highestIdx = -1;
      highest = 0.0;
      lowestIdx = -1;
      lowest = 0.0;
      while( today <= endIdx )
      {
         tmpLow = tmpHigh = inReal[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inReal[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmpHigh = inReal[i];
               if( tmpHigh > highest )
               {
                  highestIdx = i;
                  highest = tmpHigh;
               }
            }
         }
         else if( tmpHigh >= highest )
         {
            highestIdx = today;
            highest = tmpHigh;
         }
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inReal[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmpLow = inReal[i];
               if( tmpLow < lowest )
               {
                  lowestIdx = i;
                  lowest = tmpLow;
               }
            }
         }
         else if( tmpLow <= lowest )
         {
            lowestIdx = today;
            lowest = tmpLow;
         }
         outMaxIdx[outIdx] = highestIdx;
         outMinIdx[outIdx] = lowestIdx;
         outIdx++;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode minMaxIndexStateInit( struct TA_minMaxIndex_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct minMaxIndex ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = minMaxIndexLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode minMaxIndexState( struct TA_minMaxIndex_State* _state,
      double inReal,
      int *outMinIdx,
      int *outMaxIdx )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .max = inReal;
         _state.value .min = inReal;
         _state.value .maxIdx = 0;
         _state.value .minIdx = 0;
         _state.value .currentIdx = 0;
      } else
         ++ _state.value .currentIdx;
      if( _state.value .max < inReal )
      {
         _state.value .max = inReal;
         _state.value .maxIdx = _state.value .currentIdx;
      }
      if( _state.value .min > inReal )
      {
         _state.value .min = inReal;
         _state.value .minIdx = _state.value .currentIdx;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      outMaxIdx.value = _state.value .maxIdx;
      outMinIdx.value = _state.value .minIdx;
      return RetCode.Success ;
   }
   public RetCode minMaxIndexStateFree( struct TA_minMaxIndex_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode minMaxIndexStateSave( struct TA_minMaxIndex_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_MINMAXINDEX_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .min,sizeof( _state.value .min),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .max,sizeof( _state.value .max),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .minIdx,sizeof( _state.value .minIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .maxIdx,sizeof( _state.value .maxIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .currentIdx,sizeof( _state.value .currentIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode minMaxIndexStateLoad( struct TA_minMaxIndex_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct minMaxIndex ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_MINMAXINDEX_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_MINMAXINDEX_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .min,sizeof( _state.value .value .min),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .max,sizeof( _state.value .value .max),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .minIdx,sizeof( _state.value .value .minIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .maxIdx,sizeof( _state.value .value .maxIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .currentIdx,sizeof( _state.value .value .currentIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode minMaxIndex( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outMinIdx[],
      int outMaxIdx[] )
   {
      double highest, lowest, tmpHigh, tmpLow;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, today, i, highestIdx, lowestIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      highestIdx = -1;
      highest = 0.0;
      lowestIdx = -1;
      lowest = 0.0;
      while( today <= endIdx )
      {
         tmpLow = tmpHigh = inReal[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inReal[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmpHigh = inReal[i];
               if( tmpHigh > highest )
               {
                  highestIdx = i;
                  highest = tmpHigh;
               }
            }
         }
         else if( tmpHigh >= highest )
         {
            highestIdx = today;
            highest = tmpHigh;
         }
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inReal[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmpLow = inReal[i];
               if( tmpLow < lowest )
               {
                  lowestIdx = i;
                  lowest = tmpLow;
               }
            }
         }
         else if( tmpLow <= lowest )
         {
            lowestIdx = today;
            lowest = tmpLow;
         }
         outMaxIdx[outIdx] = highestIdx;
         outMinIdx[outIdx] = lowestIdx;
         outIdx++;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int minusDILookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      if( optInTimePeriod > 1 )
         return optInTimePeriod + (this.unstablePeriod[FuncUnstId.MinusDI.ordinal()]) ;
      else
         return 1;
   }
   public RetCode minusDI( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, lookbackTotal, outIdx;
      double prevHigh, prevLow, prevClose;
      double prevMinusDM, prevTR;
      double tempReal, tempReal2, diffP, diffM;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInTimePeriod > 1 )
         lookbackTotal = optInTimePeriod + (this.unstablePeriod[FuncUnstId.MinusDI.ordinal()]) ;
      else
         lookbackTotal = 1;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      if( optInTimePeriod <= 1 )
      {
         outBegIdx.value = startIdx;
         today = startIdx-1;
         prevHigh = inHigh[today];
         prevLow = inLow[today];
         prevClose = inClose[today];
         while( today < endIdx )
         {
            today++;
            tempReal = inHigh[today];
            diffP = tempReal-prevHigh;
            prevHigh = tempReal;
            tempReal = inLow[today];
            diffM = prevLow-tempReal;
            prevLow = tempReal;
            if( (diffM > 0) && (diffP < diffM) )
            {
               { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
               if( (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
                  outReal[outIdx++] = (double)0.0;
               else
                  outReal[outIdx++] = diffM/tempReal;
            }
            else
               outReal[outIdx++] = (double)0.0;
            prevClose = inClose[today];
         }
         outNBElement.value = outIdx;
         return RetCode.Success ;
      }
      outBegIdx.value = today = startIdx;
      prevMinusDM = 0.0;
      prevTR = 0.0;
      today = startIdx - lookbackTotal;
      prevHigh = inHigh[today];
      prevLow = inLow[today];
      prevClose = inClose[today];
      i = optInTimePeriod-1;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR += tempReal;
         prevClose = inClose[today];
      }
      i = (this.unstablePeriod[FuncUnstId.MinusDI.ordinal()]) + 1;
      while( i-- != 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod) + diffM;
         }
         else
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod);
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
      }
      if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
         outReal[0] = (100.0*(prevMinusDM/prevTR)) ;
      else
         outReal[0] = 0.0;
      outIdx = 1;
      while( today < endIdx )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod) + diffM;
         }
         else
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod);
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
         if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
            outReal[outIdx++] = (100.0*(prevMinusDM/prevTR)) ;
         else
            outReal[outIdx++] = 0.0;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode minusDIStateInit( struct TA_minusDI_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct minusDI ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = minusDILookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode minusDIState( struct TA_minusDI_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      double tempReal, tempReal2, diffP, diffM;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .prevTR = 0.0;
         _state.value .prevMinusDM = 0.0;
         _state.value .prevHigh = inHigh;
         _state.value .prevLow = inLow;
         _state.value .prevClose = inClose;
         return RetCode.NeedMoreData ;
      }
      diffP = inHigh- _state.value .prevHigh;
      _state.value .prevHigh = inHigh;
      diffM = _state.value .prevLow-inLow;
      _state.value .prevLow = inLow;
      if ( _state.value .optInTimePeriod <= 1)
      {
         if( (diffM > 0) && (diffP < diffM) )
         {
            { tempReal = _state.value .prevHigh- _state.value .prevLow; tempReal2 = Math.abs ( _state.value .prevHigh- _state.value .prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs ( _state.value .prevLow- _state.value .prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
            if( (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
               outReal.value = (double)0.0;
            else
               outReal.value = diffM/tempReal;
         }
         else
            outReal.value = (double)0.0;
         _state.value .prevClose = inClose;
         return RetCode.Success ;
      }
      if ((int) _state.value .mem_index <= _state.value .optInTimePeriod )
      {
         if( (diffM > 0) && (diffP < diffM) )
         {
            _state.value .prevMinusDM += diffM;
         }
      } else
         if( (diffM > 0) && (diffP < diffM) )
      {
         _state.value .prevMinusDM = _state.value .prevMinusDM - ( _state.value .prevMinusDM/ _state.value .optInTimePeriod) + diffM;
      }
      else
      {
         _state.value .prevMinusDM = _state.value .prevMinusDM - ( _state.value .prevMinusDM/ _state.value .optInTimePeriod);
      }
      { tempReal = _state.value .prevHigh- _state.value .prevLow; tempReal2 = Math.abs ( _state.value .prevHigh- _state.value .prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs ( _state.value .prevLow- _state.value .prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
      if ((int) _state.value .mem_index <= _state.value .optInTimePeriod )
         _state.value .prevTR += tempReal;
      else
         _state.value .prevTR = _state.value .prevTR - ( _state.value .prevTR/ _state.value .optInTimePeriod) + tempReal;
      _state.value .prevClose = inClose;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      if( ! (((- (0.00000000000001) )< _state.value .prevTR)&&( _state.value .prevTR< (0.00000000000001) )) )
         outReal.value = (100.0 * ( _state.value .prevMinusDM/ _state.value .prevTR)) ;
      else
         outReal.value = 0.0;
      return RetCode.Success ;
   }
   public RetCode minusDIStateFree( struct TA_minusDI_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode minusDIStateSave( struct TA_minusDI_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_MINUS_DI_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevHigh,sizeof( _state.value .prevHigh),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevLow,sizeof( _state.value .prevLow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevClose,sizeof( _state.value .prevClose),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevTR,sizeof( _state.value .prevTR),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevMinusDM,sizeof( _state.value .prevMinusDM),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode minusDIStateLoad( struct TA_minusDI_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct minusDI ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_MINUS_DI_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_MINUS_DI_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevHigh,sizeof( _state.value .value .prevHigh),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevLow,sizeof( _state.value .value .prevLow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevClose,sizeof( _state.value .value .prevClose),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevTR,sizeof( _state.value .value .prevTR),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevMinusDM,sizeof( _state.value .value .prevMinusDM),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode minusDI( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, lookbackTotal, outIdx;
      double prevHigh, prevLow, prevClose;
      double prevMinusDM, prevTR;
      double tempReal, tempReal2, diffP, diffM;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInTimePeriod > 1 )
         lookbackTotal = optInTimePeriod + (this.unstablePeriod[FuncUnstId.MinusDI.ordinal()]) ;
      else
         lookbackTotal = 1;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      if( optInTimePeriod <= 1 )
      {
         outBegIdx.value = startIdx;
         today = startIdx-1;
         prevHigh = inHigh[today];
         prevLow = inLow[today];
         prevClose = inClose[today];
         while( today < endIdx )
         {
            today++;
            tempReal = inHigh[today];
            diffP = tempReal-prevHigh;
            prevHigh = tempReal;
            tempReal = inLow[today];
            diffM = prevLow-tempReal;
            prevLow = tempReal;
            if( (diffM > 0) && (diffP < diffM) )
            {
               { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
               if( (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
                  outReal[outIdx++] = (double)0.0;
               else
                  outReal[outIdx++] = diffM/tempReal;
            }
            else
               outReal[outIdx++] = (double)0.0;
            prevClose = inClose[today];
         }
         outNBElement.value = outIdx;
         return RetCode.Success ;
      }
      outBegIdx.value = today = startIdx;
      prevMinusDM = 0.0;
      prevTR = 0.0;
      today = startIdx - lookbackTotal;
      prevHigh = inHigh[today];
      prevLow = inLow[today];
      prevClose = inClose[today];
      i = optInTimePeriod-1;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR += tempReal;
         prevClose = inClose[today];
      }
      i = (this.unstablePeriod[FuncUnstId.MinusDI.ordinal()]) + 1;
      while( i-- != 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod) + diffM;
         }
         else
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod);
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
      }
      if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
         outReal[0] = (100.0*(prevMinusDM/prevTR)) ;
      else
         outReal[0] = 0.0;
      outIdx = 1;
      while( today < endIdx )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod) + diffM;
         }
         else
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod);
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
         if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
            outReal[outIdx++] = (100.0*(prevMinusDM/prevTR)) ;
         else
            outReal[outIdx++] = 0.0;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int minusDMLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      if( optInTimePeriod > 1 )
         return optInTimePeriod + (this.unstablePeriod[FuncUnstId.MinusDM.ordinal()]) - 1;
      else
         return 1;
   }
   public RetCode minusDM( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, lookbackTotal, outIdx;
      double prevHigh, prevLow, tempReal;
      double prevMinusDM;
      double diffP, diffM;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInTimePeriod > 1 )
         lookbackTotal = optInTimePeriod + (this.unstablePeriod[FuncUnstId.MinusDM.ordinal()]) - 1;
      else
         lookbackTotal = 1;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      if( optInTimePeriod <= 1 )
      {
         outBegIdx.value = startIdx;
         today = startIdx-1;
         prevHigh = inHigh[today];
         prevLow = inLow[today];
         while( today < endIdx )
         {
            today++;
            tempReal = inHigh[today];
            diffP = tempReal-prevHigh;
            prevHigh = tempReal;
            tempReal = inLow[today];
            diffM = prevLow-tempReal;
            prevLow = tempReal;
            if( (diffM > 0) && (diffP < diffM) )
            {
               outReal[outIdx++] = diffM;
            }
            else
               outReal[outIdx++] = 0;
         }
         outNBElement.value = outIdx;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      prevMinusDM = 0.0;
      today = startIdx - lookbackTotal;
      prevHigh = inHigh[today];
      prevLow = inLow[today];
      i = optInTimePeriod-1;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
      }
      i = (this.unstablePeriod[FuncUnstId.MinusDM.ordinal()]) ;
      while( i-- != 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod) + diffM;
         }
         else
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod);
         }
      }
      outReal[0] = prevMinusDM;
      outIdx = 1;
      while( today < endIdx )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod) + diffM;
         }
         else
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod);
         }
         outReal[outIdx++] = prevMinusDM;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode minusDMStateInit( struct TA_minusDM_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct minusDM ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = minusDMLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode minusDMState( struct TA_minusDM_State* _state,
      double inHigh,
      double inLow,
      double *outReal )
   {
      double diffP, diffM;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .prevMinusDM = 0.0;
         _state.value .prevHigh = inHigh;
         _state.value .prevLow = inLow;
         return RetCode.NeedMoreData ;
      }
      diffP = inHigh- _state.value .prevHigh;
      _state.value .prevHigh = inHigh;
      diffM = _state.value .prevLow-inLow;
      _state.value .prevLow = inLow;
      if ( _state.value .optInTimePeriod <= 1)
      {
         if( (diffM > 0) && (diffP < diffM) )
         {
            outReal.value = diffM;
         }
         else
            outReal.value = (double)0.0;
         return RetCode.Success ;
      }
      if ((int) _state.value .mem_index <= _state.value .optInTimePeriod )
      {
         if( (diffM > 0) && (diffP < diffM) )
         {
            _state.value .prevMinusDM += diffM;
         }
      } else
         if( (diffM > 0) && (diffP < diffM) )
      {
         _state.value .prevMinusDM = _state.value .prevMinusDM - ( _state.value .prevMinusDM/ _state.value .optInTimePeriod) + diffM;
      }
      else
      {
         _state.value .prevMinusDM = _state.value .prevMinusDM - ( _state.value .prevMinusDM/ _state.value .optInTimePeriod);
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      outReal.value = _state.value .prevMinusDM;
      return RetCode.Success ;
   }
   public RetCode minusDMStateFree( struct TA_minusDM_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode minusDMStateSave( struct TA_minusDM_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_MINUS_DM_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevHigh,sizeof( _state.value .prevHigh),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevLow,sizeof( _state.value .prevLow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevMinusDM,sizeof( _state.value .prevMinusDM),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode minusDMStateLoad( struct TA_minusDM_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct minusDM ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_MINUS_DM_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_MINUS_DM_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevHigh,sizeof( _state.value .value .prevHigh),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevLow,sizeof( _state.value .value .prevLow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevMinusDM,sizeof( _state.value .value .prevMinusDM),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode minusDM( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, lookbackTotal, outIdx;
      double prevHigh, prevLow, tempReal;
      double prevMinusDM;
      double diffP, diffM;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInTimePeriod > 1 )
         lookbackTotal = optInTimePeriod + (this.unstablePeriod[FuncUnstId.MinusDM.ordinal()]) - 1;
      else
         lookbackTotal = 1;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      if( optInTimePeriod <= 1 )
      {
         outBegIdx.value = startIdx;
         today = startIdx-1;
         prevHigh = inHigh[today];
         prevLow = inLow[today];
         while( today < endIdx )
         {
            today++;
            tempReal = inHigh[today];
            diffP = tempReal-prevHigh;
            prevHigh = tempReal;
            tempReal = inLow[today];
            diffM = prevLow-tempReal;
            prevLow = tempReal;
            if( (diffM > 0) && (diffP < diffM) )
            {
               outReal[outIdx++] = diffM;
            }
            else
               outReal[outIdx++] = 0;
         }
         outNBElement.value = outIdx;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      prevMinusDM = 0.0;
      today = startIdx - lookbackTotal;
      prevHigh = inHigh[today];
      prevLow = inLow[today];
      i = optInTimePeriod-1;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
      }
      i = (this.unstablePeriod[FuncUnstId.MinusDM.ordinal()]) ;
      while( i-- != 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod) + diffM;
         }
         else
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod);
         }
      }
      outReal[0] = prevMinusDM;
      outIdx = 1;
      while( today < endIdx )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod) + diffM;
         }
         else
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod);
         }
         outReal[outIdx++] = prevMinusDM;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int momLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod;
   }
   public RetCode mom( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int inIdx, outIdx, trailingIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( startIdx < optInTimePeriod )
         startIdx = optInTimePeriod;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      inIdx = startIdx;
      trailingIdx = startIdx - optInTimePeriod;
      while( inIdx <= endIdx )
         outReal[outIdx++] = inReal[inIdx++] - inReal[trailingIdx++];
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode momStateInit( struct TA_mom_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct mom ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = momLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_MOM_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode momState( struct TA_mom_State* _state,
      double inReal,
      double *outReal )
   {
      double temp;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      temp = ( _state.value .memory+_cur_idx).value .inReal ;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      outReal.value = inReal - temp;
      return RetCode.Success ;
   }
   public RetCode momStateFree( struct TA_mom_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode momStateSave( struct TA_mom_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_MOM_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode momStateLoad( struct TA_mom_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct mom ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_MOM_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_MOM_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode mom( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int inIdx, outIdx, trailingIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( startIdx < optInTimePeriod )
         startIdx = optInTimePeriod;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      inIdx = startIdx;
      trailingIdx = startIdx - optInTimePeriod;
      while( inIdx <= endIdx )
         outReal[outIdx++] = inReal[inIdx++] - inReal[trailingIdx++];
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int multLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode mult( int startIdx,
      int endIdx,
      double inReal0[],
      double inReal1[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = inReal0[i]*inReal1[i];
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode multStateInit( struct TA_mult_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct mult ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = multLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_MULT_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode multState( struct TA_mult_State* _state,
      double inReal0,
      double inReal1,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal0 = inReal0 ;
         ( _state.value .memory+_cur_idx).value .inReal1 = inReal1 ;
         return RetCode.NeedMoreData ; }
      outReal.value = inReal0*inReal1;
      return RetCode.Success ;
   }
   public RetCode multStateFree( struct TA_mult_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode multStateSave( struct TA_mult_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_MULT_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode multStateLoad( struct TA_mult_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct mult ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_MULT_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_MULT_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode mult( int startIdx,
      int endIdx,
      float inReal0[],
      float inReal1[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = inReal0[i]*inReal1[i];
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int natrLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod + (this.unstablePeriod[FuncUnstId.Natr.ordinal()]) ;
   }
   public RetCode natr( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      RetCode retCode;
      int outIdx, today, lookbackTotal;
      int nbATR;
      MInteger outBegIdx1 = new MInteger() ;
      MInteger outNbElement1 = new MInteger() ;
      double prevATR, tempValue;
      double []tempBuffer ;
      double []prevATRTemp = new double[1] ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      lookbackTotal = natrLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
         return RetCode.Success ;
      if( optInTimePeriod <= 1 )
      {
         return trueRange ( startIdx, endIdx,
            inHigh, inLow, inClose,
            outBegIdx, outNBElement, outReal );
      }
      tempBuffer = new double[lookbackTotal+(endIdx-startIdx)+1] ;
      retCode = trueRange ( (startIdx-lookbackTotal+1), endIdx,
         inHigh, inLow, inClose,
         outBegIdx1 , outNbElement1 ,
         tempBuffer );
      if( retCode != RetCode.Success )
      {
         return retCode;
      }
      retCode = TA_INT_SMA ( optInTimePeriod-1,
         optInTimePeriod-1,
         tempBuffer, optInTimePeriod,
         outBegIdx1 , outNbElement1 ,
         prevATRTemp );
      if( retCode != RetCode.Success )
      {
         return retCode;
      }
      prevATR = prevATRTemp[0];
      today = optInTimePeriod;
      outIdx = (this.unstablePeriod[FuncUnstId.Natr.ordinal()]) ;
      while( outIdx != 0 )
      {
         prevATR *= optInTimePeriod - 1;
         prevATR += tempBuffer[today++];
         prevATR /= optInTimePeriod;
         outIdx--;
      }
      outIdx = 1;
      tempValue = inClose[today];
      if( ! (((- (0.00000000000001) )<tempValue)&&(tempValue< (0.00000000000001) )) )
         outReal[0] = (prevATR/tempValue)*100.0;
      else
         outReal[0] = 0.0;
      nbATR = (endIdx - startIdx)+1;
      while( --nbATR != 0 )
      {
         prevATR *= optInTimePeriod - 1;
         prevATR += tempBuffer[today++];
         prevATR /= optInTimePeriod;
         tempValue = inClose[today];
         if( ! (((- (0.00000000000001) )<tempValue)&&(tempValue< (0.00000000000001) )) )
            outReal[outIdx] = (prevATR/tempValue)*100.0;
         else
            outReal[0] = 0.0;
         outIdx++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return retCode;
   }
   public RetCode natrStateInit( struct TA_natr_State** _state,
      int optInTimePeriod )
   {
      TA_RetCode retCode;
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct natr ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = natrLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_NATR_Data));
      else
         _state.value .value .memory = NULL;
      if( optInTimePeriod <= 1 )
      {
         return trueRange ( (struct trueRange **) & _state.value .value .StateTRANGE );
      }
      retCode = trueRange ( (struct trueRange **) & _state.value .value .StateTRANGE );
      if (retCode != RetCode.Success ) return retCode;
      return sma ( (struct sma **) & _state.value .value .StateSMA, optInTimePeriod );
      return RetCode.Success ;
   }
   public RetCode natrState( struct TA_natr_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      if( _state.value .optInTimePeriod <= 1 )
      {
         return trueRange ( (struct trueRange *) _state.value .StateTRANGE, inHigh, inLow, inClose, outReal );
      }
      TA_RetCode retCode;
      double tempReal, tempATR;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .firstATR = 1;
      }
      retCode = trueRange ( _state.value .StateTRANGE,inHigh, inLow, inClose, &tempReal );
      if( retCode != RetCode.Success ) return retCode;
      if ( _state.value .firstATR == 1)
      {
         retCode = sma ( _state.value .StateSMA, tempReal, &tempATR );
         if( retCode != RetCode.Success ) return retCode;
         _state.value .firstATR = 0;
         _state.value .prevATR = tempATR;
      } else {
         _state.value .prevATR *= _state.value .optInTimePeriod - 1;
         _state.value .prevATR += tempReal;
         _state.value .prevATR /= _state.value .optInTimePeriod;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      if( ! (((- (0.00000000000001) )<inClose)&&(inClose< (0.00000000000001) )) )
         outReal.value = ( _state.value .prevATR/inClose)*100.0;
      else outReal.value = 0.;
      return RetCode.Success ;
   }
   public RetCode natrStateFree( struct TA_natr_State** _state )
   {
      if( _state.value .value .optInTimePeriod <= 1 )
      {
         return trueRange ( (struct trueRange **) & _state.value .value .StateTRANGE);
      }
      TA_RetCode retCode;
      retCode = trueRange ( (struct trueRange **) & _state.value .value .StateTRANGE );
      if (retCode != RetCode.Success ) return retCode;
      else retCode = sma ( (struct sma **) & _state.value .value .StateSMA );
      if (retCode != RetCode.Success ) return retCode;
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode natrStateSave( struct TA_natr_State* _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_NATR_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevATR,sizeof( _state.value .prevATR),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .firstATR,sizeof( _state.value .firstATR),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_TRANGE_StateSave ( (struct trueRange *) _state.value .StateTRANGE, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_SMA_StateSave ( (struct sma *) _state.value .StateSMA, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode natrStateLoad( struct TA_natr_State** _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct natr ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_NATR_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_NATR_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevATR,sizeof( _state.value .value .prevATR),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .firstATR,sizeof( _state.value .value .firstATR),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_TRANGE_StateLoad ( (struct trueRange **) & _state.value .value .StateTRANGE, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_SMA_StateLoad ( (struct sma **) & _state.value .value .StateSMA, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode natr( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      RetCode retCode;
      int outIdx, today, lookbackTotal;
      int nbATR;
      MInteger outBegIdx1 = new MInteger() ;
      MInteger outNbElement1 = new MInteger() ;
      double prevATR, tempValue;
      double []tempBuffer ;
      double []prevATRTemp = new double[1] ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      lookbackTotal = natrLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
         return RetCode.Success ;
      if( optInTimePeriod <= 1 )
      {
         return trueRange ( startIdx, endIdx,
            inHigh, inLow, inClose,
            outBegIdx, outNBElement, outReal );
      }
      tempBuffer = new double[lookbackTotal+(endIdx-startIdx)+1] ;
      retCode = trueRange ( (startIdx-lookbackTotal+1), endIdx,
         inHigh, inLow, inClose,
         outBegIdx1 , outNbElement1 ,
         tempBuffer );
      if( retCode != RetCode.Success )
      {
         return retCode;
      }
      retCode = TA_INT_SMA ( optInTimePeriod-1,
         optInTimePeriod-1,
         tempBuffer, optInTimePeriod,
         outBegIdx1 , outNbElement1 ,
         prevATRTemp );
      if( retCode != RetCode.Success )
      {
         return retCode;
      }
      prevATR = prevATRTemp[0];
      today = optInTimePeriod;
      outIdx = (this.unstablePeriod[FuncUnstId.Natr.ordinal()]) ;
      while( outIdx != 0 )
      {
         prevATR *= optInTimePeriod - 1;
         prevATR += tempBuffer[today++];
         prevATR /= optInTimePeriod;
         outIdx--;
      }
      outIdx = 1;
      tempValue = inClose[today];
      if( ! (((- (0.00000000000001) )<tempValue)&&(tempValue< (0.00000000000001) )) )
         outReal[0] = (prevATR/tempValue)*100.0;
      else
         outReal[0] = 0.0;
      nbATR = (endIdx - startIdx)+1;
      while( --nbATR != 0 )
      {
         prevATR *= optInTimePeriod - 1;
         prevATR += tempBuffer[today++];
         prevATR /= optInTimePeriod;
         tempValue = inClose[today];
         if( ! (((- (0.00000000000001) )<tempValue)&&(tempValue< (0.00000000000001) )) )
            outReal[outIdx] = (prevATR/tempValue)*100.0;
         else
            outReal[0] = 0.0;
         outIdx++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return retCode;
   }
   /* Generated */
   public int nviLookback( )
   {
      return 1;
   }
   public RetCode nvi( int startIdx,
      int endIdx,
      double inClose[],
      double inVolume[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double prev_nvi;
      int outIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( startIdx < 1 )
         startIdx = 1;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      prev_nvi = 100.;
      outBegIdx.value = startIdx;
      while( startIdx <= endIdx )
      {
         if (inVolume[startIdx] < inVolume[startIdx-1])
            prev_nvi *= inClose[startIdx] / inClose[startIdx-1];
         outReal[outIdx++] = prev_nvi;
         startIdx++;
      }
      outNBElement.value = outIdx;
      return TA_SUCCESS;
   }
   public RetCode nviStateInit( struct TA_nvi_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct nvi ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = nviLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_NVI_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode nviState( struct TA_nvi_State* _state,
      double inClose,
      double inVolume,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         ( _state.value .memory+_cur_idx).value .inVolume = inVolume ;
         return RetCode.NeedMoreData ; }
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .prevNVI = 100.;
      }
      if (inVolume < ( _state.value .memory+_cur_idx).value .inVolume )
         _state.value .prevNVI *= inClose / ( _state.value .memory+_cur_idx).value .inClose ;
      outReal.value = _state.value .prevNVI;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      ( _state.value .memory+_cur_idx).value .inVolume = inVolume ;
      return RetCode.Success ;
   }
   public RetCode nviStateFree( struct TA_nvi_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode nviStateSave( struct TA_nvi_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_NVI_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .prevNVI,sizeof( _state.value .prevNVI),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode nviStateLoad( struct TA_nvi_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct nvi ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_NVI_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_NVI_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .prevNVI,sizeof( _state.value .value .prevNVI),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode nvi( int startIdx,
      int endIdx,
      float inClose[],
      float inVolume[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double prev_nvi;
      int outIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( startIdx < 1 )
         startIdx = 1;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      prev_nvi = 100.;
      outBegIdx.value = startIdx;
      while( startIdx <= endIdx )
      {
         if (inVolume[startIdx] < inVolume[startIdx-1])
            prev_nvi *= inClose[startIdx] / inClose[startIdx-1];
         outReal[outIdx++] = prev_nvi;
         startIdx++;
      }
      outNBElement.value = outIdx;
      return TA_SUCCESS;
   }
   /* Generated */
   public int obvLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode obv( int startIdx,
      int endIdx,
      double inClose[],
      double inVolume[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int i;
      int outIdx;
      double prevReal, tempReal, prevOBV;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      prevOBV = inVolume[startIdx];
      prevReal = inClose[startIdx];
      outIdx = 0;
      for(i=startIdx; i <= endIdx; i++ )
      {
         tempReal = inClose[i];
         if( tempReal > prevReal )
            prevOBV += inVolume[i];
         else if( tempReal < prevReal )
            prevOBV -= inVolume[i];
         outReal[outIdx++] = prevOBV;
         prevReal = tempReal;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode obvStateInit( struct TA_obv_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct obv ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = obvLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_OBV_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode obvState( struct TA_obv_State* _state,
      double inClose,
      double inVolume,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         ( _state.value .memory+_cur_idx).value .inVolume = inVolume ;
         return RetCode.NeedMoreData ; }
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .prevOBV = inVolume;
         _state.value .prevReal = inClose;
      } else {
         if( inClose > _state.value .prevReal )
            _state.value .prevOBV += inVolume;
         else if( inClose < _state.value .prevReal )
            _state.value .prevOBV -= inVolume;
      }
      outReal.value = _state.value .prevOBV;
      _state.value .prevReal = inClose;
      return RetCode.Success ;
   }
   public RetCode obvStateFree( struct TA_obv_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode obvStateSave( struct TA_obv_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_OBV_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .prevOBV,sizeof( _state.value .prevOBV),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevReal,sizeof( _state.value .prevReal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode obvStateLoad( struct TA_obv_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct obv ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_OBV_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_OBV_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .prevOBV,sizeof( _state.value .value .prevOBV),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevReal,sizeof( _state.value .value .prevReal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode obv( int startIdx,
      int endIdx,
      float inClose[],
      float inVolume[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int i;
      int outIdx;
      double prevReal, tempReal, prevOBV;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      prevOBV = inVolume[startIdx];
      prevReal = inClose[startIdx];
      outIdx = 0;
      for(i=startIdx; i <= endIdx; i++ )
      {
         tempReal = inClose[i];
         if( tempReal > prevReal )
            prevOBV += inVolume[i];
         else if( tempReal < prevReal )
            prevOBV -= inVolume[i];
         outReal[outIdx++] = prevOBV;
         prevReal = tempReal;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int plusDILookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      if( optInTimePeriod > 1 )
         return optInTimePeriod + (this.unstablePeriod[FuncUnstId.PlusDI.ordinal()]) ;
      else
         return 1;
   }
   public RetCode plusDI( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, lookbackTotal, outIdx;
      double prevHigh, prevLow, prevClose;
      double prevPlusDM, prevTR;
      double tempReal, tempReal2, diffP, diffM;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInTimePeriod > 1 )
         lookbackTotal = optInTimePeriod + (this.unstablePeriod[FuncUnstId.PlusDI.ordinal()]) ;
      else
         lookbackTotal = 1;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      if( optInTimePeriod <= 1 )
      {
         outBegIdx.value = startIdx;
         today = startIdx-1;
         prevHigh = inHigh[today];
         prevLow = inLow[today];
         prevClose = inClose[today];
         while( today < endIdx )
         {
            today++;
            tempReal = inHigh[today];
            diffP = tempReal-prevHigh;
            prevHigh = tempReal;
            tempReal = inLow[today];
            diffM = prevLow-tempReal;
            prevLow = tempReal;
            if( (diffP > 0) && (diffP > diffM) )
            {
               { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
               if( (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
                  outReal[outIdx++] = (double)0.0;
               else
                  outReal[outIdx++] = diffP/tempReal;
            }
            else
               outReal[outIdx++] = (double)0.0;
            prevClose = inClose[today];
         }
         outNBElement.value = outIdx;
         return RetCode.Success ;
      }
      outBegIdx.value = today = startIdx;
      prevPlusDM = 0.0;
      prevTR = 0.0;
      today = startIdx - lookbackTotal;
      prevHigh = inHigh[today];
      prevLow = inLow[today];
      prevClose = inClose[today];
      i = optInTimePeriod-1;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR += tempReal;
         prevClose = inClose[today];
      }
      i = (this.unstablePeriod[FuncUnstId.PlusDI.ordinal()]) + 1;
      while( i-- != 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod) + diffP;
         }
         else
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod);
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
      }
      if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
         outReal[0] = (100.0*(prevPlusDM/prevTR)) ;
      else
         outReal[0] = 0.0;
      outIdx = 1;
      while( today < endIdx )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod) + diffP;
         }
         else
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod);
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
         if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
            outReal[outIdx++] = (100.0*(prevPlusDM/prevTR)) ;
         else
            outReal[outIdx++] = 0.0;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode plusDIStateInit( struct TA_plusDI_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct plusDI ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = plusDILookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode plusDIState( struct TA_plusDI_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      double tempReal, tempReal2, diffP, diffM;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .prevTR = 0.0;
         _state.value .prevPlusDM = 0.0;
         _state.value .prevHigh = inHigh;
         _state.value .prevLow = inLow;
         _state.value .prevClose = inClose;
         return RetCode.NeedMoreData ;
      }
      diffP = inHigh- _state.value .prevHigh;
      _state.value .prevHigh = inHigh;
      diffM = _state.value .prevLow-inLow;
      _state.value .prevLow = inLow;
      if ( _state.value .optInTimePeriod <= 1)
      {
         if( (diffP > 0) && (diffP > diffM) )
         {
            { tempReal = _state.value .prevHigh- _state.value .prevLow; tempReal2 = Math.abs ( _state.value .prevHigh- _state.value .prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs ( _state.value .prevLow- _state.value .prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
            if( (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
               outReal.value = (double)0.0;
            else
               outReal.value = diffP/tempReal;
         }
         else
            outReal.value = (double)0.0;
         _state.value .prevClose = inClose;
         return RetCode.Success ;
      }
      if ((int) _state.value .mem_index <= _state.value .optInTimePeriod )
      {
         if( (diffP > 0) && (diffP > diffM) )
         {
            _state.value .prevPlusDM += diffP;
         }
      } else
         if( (diffP > 0) && (diffP > diffM) )
      {
         _state.value .prevPlusDM = _state.value .prevPlusDM - ( _state.value .prevPlusDM/ _state.value .optInTimePeriod) + diffP;
      }
      else
      {
         _state.value .prevPlusDM = _state.value .prevPlusDM - ( _state.value .prevPlusDM/ _state.value .optInTimePeriod);
      }
      { tempReal = _state.value .prevHigh- _state.value .prevLow; tempReal2 = Math.abs ( _state.value .prevHigh- _state.value .prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs ( _state.value .prevLow- _state.value .prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
      if ((int) _state.value .mem_index <= _state.value .optInTimePeriod )
         _state.value .prevTR += tempReal;
      else
         _state.value .prevTR = _state.value .prevTR - ( _state.value .prevTR/ _state.value .optInTimePeriod) + tempReal;
      _state.value .prevClose = inClose;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      if( ! (((- (0.00000000000001) )< _state.value .prevTR)&&( _state.value .prevTR< (0.00000000000001) )) )
         outReal.value = (100.0 * ( _state.value .prevPlusDM/ _state.value .prevTR)) ;
      else
         outReal.value = 0.0;
      return RetCode.Success ;
   }
   public RetCode plusDIStateFree( struct TA_plusDI_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode plusDIStateSave( struct TA_plusDI_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_PLUS_DI_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevHigh,sizeof( _state.value .prevHigh),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevLow,sizeof( _state.value .prevLow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevClose,sizeof( _state.value .prevClose),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevTR,sizeof( _state.value .prevTR),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevPlusDM,sizeof( _state.value .prevPlusDM),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode plusDIStateLoad( struct TA_plusDI_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct plusDI ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_PLUS_DI_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_PLUS_DI_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevHigh,sizeof( _state.value .value .prevHigh),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevLow,sizeof( _state.value .value .prevLow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevClose,sizeof( _state.value .value .prevClose),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevTR,sizeof( _state.value .value .prevTR),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevPlusDM,sizeof( _state.value .value .prevPlusDM),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode plusDI( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, lookbackTotal, outIdx;
      double prevHigh, prevLow, prevClose;
      double prevPlusDM, prevTR;
      double tempReal, tempReal2, diffP, diffM;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInTimePeriod > 1 )
         lookbackTotal = optInTimePeriod + (this.unstablePeriod[FuncUnstId.PlusDI.ordinal()]) ;
      else
         lookbackTotal = 1;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      if( optInTimePeriod <= 1 )
      {
         outBegIdx.value = startIdx;
         today = startIdx-1;
         prevHigh = inHigh[today];
         prevLow = inLow[today];
         prevClose = inClose[today];
         while( today < endIdx )
         {
            today++;
            tempReal = inHigh[today];
            diffP = tempReal-prevHigh;
            prevHigh = tempReal;
            tempReal = inLow[today];
            diffM = prevLow-tempReal;
            prevLow = tempReal;
            if( (diffP > 0) && (diffP > diffM) )
            {
               { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
               if( (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
                  outReal[outIdx++] = (double)0.0;
               else
                  outReal[outIdx++] = diffP/tempReal;
            }
            else
               outReal[outIdx++] = (double)0.0;
            prevClose = inClose[today];
         }
         outNBElement.value = outIdx;
         return RetCode.Success ;
      }
      outBegIdx.value = today = startIdx;
      prevPlusDM = 0.0;
      prevTR = 0.0;
      today = startIdx - lookbackTotal;
      prevHigh = inHigh[today];
      prevLow = inLow[today];
      prevClose = inClose[today];
      i = optInTimePeriod-1;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR += tempReal;
         prevClose = inClose[today];
      }
      i = (this.unstablePeriod[FuncUnstId.PlusDI.ordinal()]) + 1;
      while( i-- != 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod) + diffP;
         }
         else
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod);
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
      }
      if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
         outReal[0] = (100.0*(prevPlusDM/prevTR)) ;
      else
         outReal[0] = 0.0;
      outIdx = 1;
      while( today < endIdx )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod) + diffP;
         }
         else
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod);
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
         if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
            outReal[outIdx++] = (100.0*(prevPlusDM/prevTR)) ;
         else
            outReal[outIdx++] = 0.0;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int plusDMLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      if( optInTimePeriod > 1 )
         return optInTimePeriod + (this.unstablePeriod[FuncUnstId.PlusDM.ordinal()]) - 1;
      else
         return 1;
   }
   public RetCode plusDM( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, lookbackTotal, outIdx;
      double prevHigh, prevLow, tempReal;
      double prevPlusDM;
      double diffP, diffM;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInTimePeriod > 1 )
         lookbackTotal = optInTimePeriod + (this.unstablePeriod[FuncUnstId.PlusDM.ordinal()]) - 1;
      else
         lookbackTotal = 1;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      if( optInTimePeriod <= 1 )
      {
         outBegIdx.value = startIdx;
         today = startIdx-1;
         prevHigh = inHigh[today];
         prevLow = inLow[today];
         while( today < endIdx )
         {
            today++;
            tempReal = inHigh[today];
            diffP = tempReal-prevHigh;
            prevHigh = tempReal;
            tempReal = inLow[today];
            diffM = prevLow-tempReal;
            prevLow = tempReal;
            if( (diffP > 0) && (diffP > diffM) )
            {
               outReal[outIdx++] = diffP;
            }
            else
               outReal[outIdx++] = 0;
         }
         outNBElement.value = outIdx;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      prevPlusDM = 0.0;
      today = startIdx - lookbackTotal;
      prevHigh = inHigh[today];
      prevLow = inLow[today];
      i = optInTimePeriod-1;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
      }
      i = (this.unstablePeriod[FuncUnstId.PlusDM.ordinal()]) ;
      while( i-- != 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod) + diffP;
         }
         else
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod);
         }
      }
      outReal[0] = prevPlusDM;
      outIdx = 1;
      while( today < endIdx )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod) + diffP;
         }
         else
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod);
         }
         outReal[outIdx++] = prevPlusDM;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode plusDMStateInit( struct TA_plusDM_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct plusDM ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = plusDMLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode plusDMState( struct TA_plusDM_State* _state,
      double inHigh,
      double inLow,
      double *outReal )
   {
      double diffP, diffM;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .prevPlusDM = 0.0;
         _state.value .prevHigh = inHigh;
         _state.value .prevLow = inLow;
         return RetCode.NeedMoreData ;
      }
      diffP = inHigh- _state.value .prevHigh;
      _state.value .prevHigh = inHigh;
      diffM = _state.value .prevLow-inLow;
      _state.value .prevLow = inLow;
      if ( _state.value .optInTimePeriod <= 1)
      {
         if( (diffP > 0) && (diffP > diffM) )
         {
            outReal.value = diffP;
         }
         else
            outReal.value = (double)0.0;
         return RetCode.Success ;
      }
      if ((int) _state.value .mem_index <= _state.value .optInTimePeriod )
      {
         if( (diffP > 0) && (diffP > diffM) )
         {
            _state.value .prevPlusDM += diffP;
         }
      } else
         if( (diffP > 0) && (diffP > diffM) )
      {
         _state.value .prevPlusDM = _state.value .prevPlusDM - ( _state.value .prevPlusDM/ _state.value .optInTimePeriod) + diffP;
      }
      else
      {
         _state.value .prevPlusDM = _state.value .prevPlusDM - ( _state.value .prevPlusDM/ _state.value .optInTimePeriod);
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      outReal.value = _state.value .prevPlusDM;
      return RetCode.Success ;
   }
   public RetCode plusDMStateFree( struct TA_plusDM_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode plusDMStateSave( struct TA_plusDM_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_PLUS_DM_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevHigh,sizeof( _state.value .prevHigh),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevLow,sizeof( _state.value .prevLow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevPlusDM,sizeof( _state.value .prevPlusDM),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode plusDMStateLoad( struct TA_plusDM_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct plusDM ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_PLUS_DM_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_PLUS_DM_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevHigh,sizeof( _state.value .value .prevHigh),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevLow,sizeof( _state.value .value .prevLow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevPlusDM,sizeof( _state.value .value .prevPlusDM),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode plusDM( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, lookbackTotal, outIdx;
      double prevHigh, prevLow, tempReal;
      double prevPlusDM;
      double diffP, diffM;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInTimePeriod > 1 )
         lookbackTotal = optInTimePeriod + (this.unstablePeriod[FuncUnstId.PlusDM.ordinal()]) - 1;
      else
         lookbackTotal = 1;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      if( optInTimePeriod <= 1 )
      {
         outBegIdx.value = startIdx;
         today = startIdx-1;
         prevHigh = inHigh[today];
         prevLow = inLow[today];
         while( today < endIdx )
         {
            today++;
            tempReal = inHigh[today];
            diffP = tempReal-prevHigh;
            prevHigh = tempReal;
            tempReal = inLow[today];
            diffM = prevLow-tempReal;
            prevLow = tempReal;
            if( (diffP > 0) && (diffP > diffM) )
            {
               outReal[outIdx++] = diffP;
            }
            else
               outReal[outIdx++] = 0;
         }
         outNBElement.value = outIdx;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      prevPlusDM = 0.0;
      today = startIdx - lookbackTotal;
      prevHigh = inHigh[today];
      prevLow = inLow[today];
      i = optInTimePeriod-1;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
      }
      i = (this.unstablePeriod[FuncUnstId.PlusDM.ordinal()]) ;
      while( i-- != 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod) + diffP;
         }
         else
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod);
         }
      }
      outReal[0] = prevPlusDM;
      outIdx = 1;
      while( today < endIdx )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod) + diffP;
         }
         else
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod);
         }
         outReal[outIdx++] = prevPlusDM;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int ppoLookback( int optInFastPeriod,
      int optInSlowPeriod,
      MAType optInMAType )
   {
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return -1;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return -1;
      return movingAverageLookback ( (((optInSlowPeriod) > (optInFastPeriod)) ? (optInSlowPeriod) : (optInFastPeriod)) , optInMAType );
   }
   public RetCode ppo( int startIdx,
      int endIdx,
      double inReal[],
      int optInFastPeriod,
      int optInSlowPeriod,
      MAType optInMAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double []tempBuffer ;
      RetCode retCode;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      tempBuffer = new double[endIdx-startIdx+1] ;
      retCode = TA_INT_PO ( startIdx, endIdx, inReal,
         optInFastPeriod,
         optInSlowPeriod,
         optInMAType,
         outBegIdx,
         outNBElement,
         outReal,
         tempBuffer,
         1 );
      return retCode;
   }
   public RetCode ppoStateInit( struct TA_ppo_State** _state,
      int optInFastPeriod,
      int optInSlowPeriod,
      MAType optInMAType )
   {
      return TA_INT_PO_StateInit ((struct apo **)_state, optInFastPeriod, optInSlowPeriod, optInMAType, 1);
   }
   public RetCode ppoState( struct TA_ppo_State* _state,
      double inReal,
      double *outReal )
   {
      return apo ((struct apo *)_state, inReal, outReal);
   }
   public RetCode ppoStateFree( struct TA_ppo_State** _state )
   {
      return apo ((struct apo **)_state);
   }
   public RetCode ppoStateSave( struct TA_ppo_State* _state,
      FILE* _file )
   {
      return TA_APO_StateSave ((struct apo *)_state, _file);
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_PPO_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInFastPeriod,sizeof( _state.value .optInFastPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInSlowPeriod,sizeof( _state.value .optInSlowPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInMAType,sizeof( _state.value .optInMAType),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode ppoStateLoad( struct TA_ppo_State** _state,
      FILE* _file )
   {
      return TA_APO_StateLoad ((struct apo **)_state, _file);
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct ppo ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_PPO_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_PPO_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInFastPeriod,sizeof( _state.value .value .optInFastPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInSlowPeriod,sizeof( _state.value .value .optInSlowPeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInMAType,sizeof( _state.value .value .optInMAType),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode ppo( int startIdx,
      int endIdx,
      float inReal[],
      int optInFastPeriod,
      int optInSlowPeriod,
      MAType optInMAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double []tempBuffer ;
      RetCode retCode;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      tempBuffer = new double[endIdx-startIdx+1] ;
      retCode = TA_INT_PO ( startIdx, endIdx, inReal,
         optInFastPeriod,
         optInSlowPeriod,
         optInMAType,
         outBegIdx,
         outNBElement,
         outReal,
         tempBuffer,
         1 );
      return retCode;
   }
   /* Generated */
   public int pviLookback( )
   {
      return 1;
   }
   public RetCode pvi( int startIdx,
      int endIdx,
      double inClose[],
      double inVolume[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double prev_pvi;
      int outIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( startIdx < 1 )
         startIdx = 1;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      prev_pvi = 100.;
      outBegIdx.value = startIdx;
      while( startIdx <= endIdx )
      {
         if (inVolume[startIdx] > inVolume[startIdx-1])
            prev_pvi *= inClose[startIdx] / inClose[startIdx-1];
         outReal[outIdx++] = prev_pvi;
         startIdx++;
      }
      outNBElement.value = outIdx;
      return TA_SUCCESS;
   }
   public RetCode pviStateInit( struct TA_pvi_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct pvi ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = pviLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_PVI_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode pviState( struct TA_pvi_State* _state,
      double inClose,
      double inVolume,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         ( _state.value .memory+_cur_idx).value .inVolume = inVolume ;
         return RetCode.NeedMoreData ; }
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .prevPVI = 100.;
      }
      if (inVolume > ( _state.value .memory+_cur_idx).value .inVolume )
         _state.value .prevPVI *= inClose / ( _state.value .memory+_cur_idx).value .inClose ;
      outReal.value = _state.value .prevPVI;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      ( _state.value .memory+_cur_idx).value .inVolume = inVolume ;
      return RetCode.Success ;
   }
   public RetCode pviStateFree( struct TA_pvi_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode pviStateSave( struct TA_pvi_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_PVI_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .prevPVI,sizeof( _state.value .prevPVI),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode pviStateLoad( struct TA_pvi_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct pvi ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_PVI_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_PVI_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .prevPVI,sizeof( _state.value .value .prevPVI),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode pvi( int startIdx,
      int endIdx,
      float inClose[],
      float inVolume[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double prev_pvi;
      int outIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( startIdx < 1 )
         startIdx = 1;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      prev_pvi = 100.;
      outBegIdx.value = startIdx;
      while( startIdx <= endIdx )
      {
         if (inVolume[startIdx] > inVolume[startIdx-1])
            prev_pvi *= inClose[startIdx] / inClose[startIdx-1];
         outReal[outIdx++] = prev_pvi;
         startIdx++;
      }
      outNBElement.value = outIdx;
      return TA_SUCCESS;
   }
   /* Generated */
   public int pvtLookback( )
   {
      return 1;
   }
   public RetCode pvt( int startIdx,
      int endIdx,
      double inClose[],
      double inVolume[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double prev_pvt;
      int outIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( startIdx < 1 )
         startIdx = 1;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      prev_pvt = 0.;
      outBegIdx.value = startIdx;
      while( startIdx <= endIdx )
      {
         prev_pvt += inVolume[startIdx] * (inClose[startIdx] / inClose[startIdx-1] - 1.0);
         outReal[outIdx++] = prev_pvt;
         startIdx++;
      }
      outNBElement.value = outIdx;
      return TA_SUCCESS;
   }
   public RetCode pvtStateInit( struct TA_pvt_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct pvt ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = pvtLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_PVT_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode pvtState( struct TA_pvt_State* _state,
      double inClose,
      double inVolume,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         ( _state.value .memory+_cur_idx).value .inVolume = inVolume ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public RetCode pvtStateFree( struct TA_pvt_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode pvtStateSave( struct TA_pvt_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_PVT_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .prevPVT,sizeof( _state.value .prevPVT),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode pvtStateLoad( struct TA_pvt_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct pvt ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_PVT_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_PVT_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .prevPVT,sizeof( _state.value .value .prevPVT),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode pvt( int startIdx,
      int endIdx,
      float inClose[],
      float inVolume[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double prev_pvt;
      int outIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( startIdx < 1 )
         startIdx = 1;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      prev_pvt = 0.;
      outBegIdx.value = startIdx;
      while( startIdx <= endIdx )
      {
         prev_pvt += inVolume[startIdx] * (inClose[startIdx] / inClose[startIdx-1] - 1.0);
         outReal[outIdx++] = prev_pvt;
         startIdx++;
      }
      outNBElement.value = outIdx;
      return TA_SUCCESS;
   }
   /* Generated */
   public int rocLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod;
   }
   public RetCode roc( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int inIdx, outIdx, trailingIdx;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( startIdx < optInTimePeriod )
         startIdx = optInTimePeriod;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      inIdx = startIdx;
      trailingIdx = startIdx - optInTimePeriod;
      while( inIdx <= endIdx )
      {
         tempReal = inReal[trailingIdx++];
         if( tempReal != 0.0 )
            outReal[outIdx++] = ((inReal[inIdx] / tempReal)-1.0)*100.0;
         else
            outReal[outIdx++] = 0.0;
         inIdx++;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode rocStateInit( struct TA_roc_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct roc ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = rocLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_ROC_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode rocState( struct TA_roc_State* _state,
      double inReal,
      double *outReal )
   {
      double tempReal;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      tempReal = ( _state.value .memory+_cur_idx).value .inReal ;
      outReal.value = (tempReal!=0.0)?((inReal / tempReal)-1.0)*100.0 : 0.0;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      return RetCode.Success ;
   }
   public RetCode rocStateFree( struct TA_roc_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode rocStateSave( struct TA_roc_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_ROC_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode rocStateLoad( struct TA_roc_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct roc ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_ROC_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_ROC_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode roc( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int inIdx, outIdx, trailingIdx;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( startIdx < optInTimePeriod )
         startIdx = optInTimePeriod;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      inIdx = startIdx;
      trailingIdx = startIdx - optInTimePeriod;
      while( inIdx <= endIdx )
      {
         tempReal = inReal[trailingIdx++];
         if( tempReal != 0.0 )
            outReal[outIdx++] = ((inReal[inIdx] / tempReal)-1.0)*100.0;
         else
            outReal[outIdx++] = 0.0;
         inIdx++;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int rocPLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod;
   }
   public RetCode rocP( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int inIdx, outIdx, trailingIdx;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( startIdx < optInTimePeriod )
         startIdx = optInTimePeriod;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      inIdx = startIdx;
      trailingIdx = startIdx - optInTimePeriod;
      while( inIdx <= endIdx )
      {
         tempReal = inReal[trailingIdx++];
         if( tempReal != 0.0 )
            outReal[outIdx++] = (inReal[inIdx]-tempReal)/tempReal;
         else
            outReal[outIdx++] = 0.0;
         inIdx++;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode rocPStateInit( struct TA_rocP_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct rocP ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = rocPLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_ROCP_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode rocPState( struct TA_rocP_State* _state,
      double inReal,
      double *outReal )
   {
      double tempReal;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      tempReal = ( _state.value .memory+_cur_idx).value .inReal ;
      outReal.value = (tempReal!=0.0)?(inReal-tempReal)/tempReal : 0.0;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      return RetCode.Success ;
   }
   public RetCode rocPStateFree( struct TA_rocP_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode rocPStateSave( struct TA_rocP_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_ROCP_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode rocPStateLoad( struct TA_rocP_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct rocP ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_ROCP_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_ROCP_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode rocP( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int inIdx, outIdx, trailingIdx;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( startIdx < optInTimePeriod )
         startIdx = optInTimePeriod;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      inIdx = startIdx;
      trailingIdx = startIdx - optInTimePeriod;
      while( inIdx <= endIdx )
      {
         tempReal = inReal[trailingIdx++];
         if( tempReal != 0.0 )
            outReal[outIdx++] = (inReal[inIdx]-tempReal)/tempReal;
         else
            outReal[outIdx++] = 0.0;
         inIdx++;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int rocRLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod;
   }
   public RetCode rocR( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int inIdx, outIdx, trailingIdx;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( startIdx < optInTimePeriod )
         startIdx = optInTimePeriod;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      inIdx = startIdx;
      trailingIdx = startIdx - optInTimePeriod;
      while( inIdx <= endIdx )
      {
         tempReal = inReal[trailingIdx++];
         if( tempReal != 0.0 )
            outReal[outIdx++] = (inReal[inIdx] / tempReal);
         else
            outReal[outIdx++] = 0.0;
         inIdx++;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode rocRStateInit( struct TA_rocR_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct rocR ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = rocRLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_ROCR_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode rocRState( struct TA_rocR_State* _state,
      double inReal,
      double *outReal )
   {
      double tempReal;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      tempReal = ( _state.value .memory+_cur_idx).value .inReal ;
      outReal.value = (tempReal!=0.0)? inReal/tempReal : 0.0;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      return RetCode.Success ;
   }
   public RetCode rocRStateFree( struct TA_rocR_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode rocRStateSave( struct TA_rocR_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_ROCR_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode rocRStateLoad( struct TA_rocR_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct rocR ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_ROCR_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_ROCR_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode rocR( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int inIdx, outIdx, trailingIdx;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( startIdx < optInTimePeriod )
         startIdx = optInTimePeriod;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      inIdx = startIdx;
      trailingIdx = startIdx - optInTimePeriod;
      while( inIdx <= endIdx )
      {
         tempReal = inReal[trailingIdx++];
         if( tempReal != 0.0 )
            outReal[outIdx++] = (inReal[inIdx] / tempReal);
         else
            outReal[outIdx++] = 0.0;
         inIdx++;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int rocR100Lookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod;
   }
   public RetCode rocR100( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int inIdx, outIdx, trailingIdx;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( startIdx < optInTimePeriod )
         startIdx = optInTimePeriod;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      inIdx = startIdx;
      trailingIdx = startIdx - optInTimePeriod;
      while( inIdx <= endIdx )
      {
         tempReal = inReal[trailingIdx++];
         if( tempReal != 0.0 )
            outReal[outIdx++] = (inReal[inIdx] / tempReal)*100.0;
         else
            outReal[outIdx++] = 0.0;
         inIdx++;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode rocR100StateInit( struct TA_rocR100_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct rocR100 ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = rocR100Lookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_ROCR100_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode rocR100State( struct TA_rocR100_State* _state,
      double inReal,
      double *outReal )
   {
      double tempReal;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      tempReal = ( _state.value .memory+_cur_idx).value .inReal ;
      outReal.value = (tempReal!=0.0)? (inReal/tempReal)*100.0 : 0.0;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      return RetCode.Success ;
   }
   public RetCode rocR100StateFree( struct TA_rocR100_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode rocR100StateSave( struct TA_rocR100_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_ROCR100_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode rocR100StateLoad( struct TA_rocR100_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct rocR100 ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_ROCR100_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_ROCR100_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode rocR100( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int inIdx, outIdx, trailingIdx;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( startIdx < optInTimePeriod )
         startIdx = optInTimePeriod;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      inIdx = startIdx;
      trailingIdx = startIdx - optInTimePeriod;
      while( inIdx <= endIdx )
      {
         tempReal = inReal[trailingIdx++];
         if( tempReal != 0.0 )
            outReal[outIdx++] = (inReal[inIdx] / tempReal)*100.0;
         else
            outReal[outIdx++] = 0.0;
         inIdx++;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int rsiLookback( int optInTimePeriod )
   {
      int retValue;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      retValue = optInTimePeriod + (this.unstablePeriod[FuncUnstId.Rsi.ordinal()]) ;
      if( (this.compatibility) == Compatibility.Metastock )
         retValue--;
      return retValue;
   }
   public RetCode rsi( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int today, lookbackTotal, unstablePeriod, i;
      double prevGain, prevLoss, prevValue, savePrevValue;
      double tempValue1, tempValue2;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      lookbackTotal = rsiLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
         return RetCode.Success ;
      outIdx = 0;
      if( optInTimePeriod == 1 )
      {
         outBegIdx.value = startIdx;
         i = (endIdx-startIdx)+1;
         outNBElement.value = i;
         System.arraycopy(inReal,startIdx,outReal,0,i) ;
         return RetCode.Success ;
      }
      today = startIdx-lookbackTotal;
      prevValue = inReal[today];
      unstablePeriod = (this.unstablePeriod[FuncUnstId.Rsi.ordinal()]) ;
      if( (unstablePeriod == 0) &&
         ( (this.compatibility) == Compatibility.Metastock ))
      {
         savePrevValue = prevValue;
         prevGain = 0.0;
         prevLoss = 0.0;
         for( i=optInTimePeriod; i > 0; i-- )
         {
            tempValue1 = inReal[today++];
            tempValue2 = tempValue1 - prevValue;
            prevValue = tempValue1;
            if( tempValue2 < 0 )
               prevLoss -= tempValue2;
            else
               prevGain += tempValue2;
         }
         tempValue1 = prevLoss/optInTimePeriod;
         tempValue2 = prevGain/optInTimePeriod;
         tempValue1 = tempValue2+tempValue1;
         if( ! (((- (0.00000000000001) )<tempValue1)&&(tempValue1< (0.00000000000001) )) )
            outReal[outIdx++] = 100*(tempValue2/tempValue1);
         else
            outReal[outIdx++] = 0.0;
         if( today > endIdx )
         {
            outBegIdx.value = startIdx;
            outNBElement.value = outIdx;
            return RetCode.Success ;
         }
         today -= optInTimePeriod;
         prevValue = savePrevValue;
      }
      prevGain = 0.0;
      prevLoss = 0.0;
      today++;
      for( i=optInTimePeriod; i > 0; i-- )
      {
         tempValue1 = inReal[today++];
         tempValue2 = tempValue1 - prevValue;
         prevValue = tempValue1;
         if( tempValue2 < 0 )
            prevLoss -= tempValue2;
         else
            prevGain += tempValue2;
      }
      prevLoss /= optInTimePeriod;
      prevGain /= optInTimePeriod;
      if( today > startIdx )
      {
         tempValue1 = prevGain+prevLoss;
         if( ! (((- (0.00000000000001) )<tempValue1)&&(tempValue1< (0.00000000000001) )) )
            outReal[outIdx++] = 100.0*(prevGain/tempValue1);
         else
            outReal[outIdx++] = 0.0;
      }
      else
      {
         while( today < startIdx )
         {
            tempValue1 = inReal[today];
            tempValue2 = tempValue1 - prevValue;
            prevValue = tempValue1;
            prevLoss *= (optInTimePeriod-1);
            prevGain *= (optInTimePeriod-1);
            if( tempValue2 < 0 )
               prevLoss -= tempValue2;
            else
               prevGain += tempValue2;
            prevLoss /= optInTimePeriod;
            prevGain /= optInTimePeriod;
            today++;
         }
      }
      while( today <= endIdx )
      {
         tempValue1 = inReal[today++];
         tempValue2 = tempValue1 - prevValue;
         prevValue = tempValue1;
         prevLoss *= (optInTimePeriod-1);
         prevGain *= (optInTimePeriod-1);
         if( tempValue2 < 0 )
            prevLoss -= tempValue2;
         else
            prevGain += tempValue2;
         prevLoss /= optInTimePeriod;
         prevGain /= optInTimePeriod;
         tempValue1 = prevGain+prevLoss;
         if( ! (((- (0.00000000000001) )<tempValue1)&&(tempValue1< (0.00000000000001) )) )
            outReal[outIdx++] = 100.0*(prevGain/tempValue1);
         else
            outReal[outIdx++] = 0.0;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode rsiStateInit( struct TA_rsi_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct rsi ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = rsiLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      if( ( (this.unstablePeriod[FuncUnstId.Rsi.ordinal()]) == 0) &&
         ( (this.compatibility) == Compatibility.Metastock ))
         _state.value .value .MetastockMode = 1;
      else
         _state.value .value .MetastockMode = 0;
      return RetCode.Success ;
   }
   public RetCode rsiState( struct TA_rsi_State* _state,
      double inReal,
      double *outReal )
   {
      double tempValue1, tempValue2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if( _state.value .optInTimePeriod == 1 )
      {
         outReal.value = inReal;
         return RetCode.Success ;
      }
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .prevLoss = 0.0;
         _state.value .prevGain = 0.0;
         _state.value .prevValue = inReal;
         if ( _state.value .MetastockMode == 0)
            return RetCode.NeedMoreData ;
      }
      tempValue2 = inReal - _state.value .prevValue;
      _state.value .prevValue = inReal;
      if ( _state.value .mem_index+ _state.value .MetastockMode-1 > (unsigned int) ( _state.value .optInTimePeriod+ _state.value .MetastockMode))
      {
         _state.value .prevLoss *= ( _state.value .optInTimePeriod-1);
         _state.value .prevGain *= ( _state.value .optInTimePeriod-1);
      }
      if (tempValue2 < 0)
         _state.value .prevLoss -= tempValue2;
      else
         _state.value .prevGain += tempValue2;
      if ( _state.value .mem_index+ _state.value .MetastockMode-1 >= (unsigned int) ( _state.value .optInTimePeriod+ _state.value .MetastockMode))
      {
         _state.value .prevLoss /= _state.value .optInTimePeriod;
         _state.value .prevGain /= _state.value .optInTimePeriod;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      tempValue1 = _state.value .prevGain+ _state.value .prevLoss;
      if( ! (((- (0.00000000000001) )<tempValue1)&&(tempValue1< (0.00000000000001) )) )
         outReal.value = 100*( _state.value .prevGain/tempValue1);
      else
         outReal.value = 0.0;
      return RetCode.Success ;
   }
   public RetCode rsiStateFree( struct TA_rsi_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode rsiStateSave( struct TA_rsi_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_RSI_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .MetastockMode,sizeof( _state.value .MetastockMode),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevGain,sizeof( _state.value .prevGain),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevLoss,sizeof( _state.value .prevLoss),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevValue,sizeof( _state.value .prevValue),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode rsiStateLoad( struct TA_rsi_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct rsi ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_RSI_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_RSI_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .MetastockMode,sizeof( _state.value .value .MetastockMode),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevGain,sizeof( _state.value .value .prevGain),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevLoss,sizeof( _state.value .value .prevLoss),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevValue,sizeof( _state.value .value .prevValue),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode rsi( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int today, lookbackTotal, unstablePeriod, i;
      double prevGain, prevLoss, prevValue, savePrevValue;
      double tempValue1, tempValue2;
      int mmmixi, mmmixdestIdx, mmmixsrcIdx ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      lookbackTotal = rsiLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
         return RetCode.Success ;
      outIdx = 0;
      if( optInTimePeriod == 1 )
      {
         outBegIdx.value = startIdx;
         i = (endIdx-startIdx)+1;
         outNBElement.value = i;
         { for( mmmixi=0, mmmixdestIdx=0, mmmixsrcIdx=startIdx; mmmixi < i; mmmixi++, mmmixdestIdx++, mmmixsrcIdx++ ) { outReal[mmmixdestIdx] = inReal[mmmixsrcIdx]; } } ;
         return RetCode.Success ;
      }
      today = startIdx-lookbackTotal;
      prevValue = inReal[today];
      unstablePeriod = (this.unstablePeriod[FuncUnstId.Rsi.ordinal()]) ;
      if( (unstablePeriod == 0) &&
         ( (this.compatibility) == Compatibility.Metastock ))
      {
         savePrevValue = prevValue;
         prevGain = 0.0;
         prevLoss = 0.0;
         for( i=optInTimePeriod; i > 0; i-- )
         {
            tempValue1 = inReal[today++];
            tempValue2 = tempValue1 - prevValue;
            prevValue = tempValue1;
            if( tempValue2 < 0 )
               prevLoss -= tempValue2;
            else
               prevGain += tempValue2;
         }
         tempValue1 = prevLoss/optInTimePeriod;
         tempValue2 = prevGain/optInTimePeriod;
         tempValue1 = tempValue2+tempValue1;
         if( ! (((- (0.00000000000001) )<tempValue1)&&(tempValue1< (0.00000000000001) )) )
            outReal[outIdx++] = 100*(tempValue2/tempValue1);
         else
            outReal[outIdx++] = 0.0;
         if( today > endIdx )
         {
            outBegIdx.value = startIdx;
            outNBElement.value = outIdx;
            return RetCode.Success ;
         }
         today -= optInTimePeriod;
         prevValue = savePrevValue;
      }
      prevGain = 0.0;
      prevLoss = 0.0;
      today++;
      for( i=optInTimePeriod; i > 0; i-- )
      {
         tempValue1 = inReal[today++];
         tempValue2 = tempValue1 - prevValue;
         prevValue = tempValue1;
         if( tempValue2 < 0 )
            prevLoss -= tempValue2;
         else
            prevGain += tempValue2;
      }
      prevLoss /= optInTimePeriod;
      prevGain /= optInTimePeriod;
      if( today > startIdx )
      {
         tempValue1 = prevGain+prevLoss;
         if( ! (((- (0.00000000000001) )<tempValue1)&&(tempValue1< (0.00000000000001) )) )
            outReal[outIdx++] = 100.0*(prevGain/tempValue1);
         else
            outReal[outIdx++] = 0.0;
      }
      else
      {
         while( today < startIdx )
         {
            tempValue1 = inReal[today];
            tempValue2 = tempValue1 - prevValue;
            prevValue = tempValue1;
            prevLoss *= (optInTimePeriod-1);
            prevGain *= (optInTimePeriod-1);
            if( tempValue2 < 0 )
               prevLoss -= tempValue2;
            else
               prevGain += tempValue2;
            prevLoss /= optInTimePeriod;
            prevGain /= optInTimePeriod;
            today++;
         }
      }
      while( today <= endIdx )
      {
         tempValue1 = inReal[today++];
         tempValue2 = tempValue1 - prevValue;
         prevValue = tempValue1;
         prevLoss *= (optInTimePeriod-1);
         prevGain *= (optInTimePeriod-1);
         if( tempValue2 < 0 )
            prevLoss -= tempValue2;
         else
            prevGain += tempValue2;
         prevLoss /= optInTimePeriod;
         prevGain /= optInTimePeriod;
         tempValue1 = prevGain+prevLoss;
         if( ! (((- (0.00000000000001) )<tempValue1)&&(tempValue1< (0.00000000000001) )) )
            outReal[outIdx++] = 100.0*(prevGain/tempValue1);
         else
            outReal[outIdx++] = 0.0;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int sarLookback( double optInAcceleration,
      double optInMaximum )
   {
      if( optInAcceleration == (-4e+37) )
         optInAcceleration = 2.000000e-2;
      else if( (optInAcceleration < 0.000000e+0) || (optInAcceleration > 3.000000e+37) )
         return -1;
      if( optInMaximum == (-4e+37) )
         optInMaximum = 2.000000e-1;
      else if( (optInMaximum < 0.000000e+0) || (optInMaximum > 3.000000e+37) )
         return -1;
      return 1;
   }
   public RetCode sar( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double optInAcceleration,
      double optInMaximum,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      RetCode retCode;
      int isLong;
      int todayIdx, outIdx;
      MInteger tempInt = new MInteger() ;
      double newHigh, newLow, prevHigh, prevLow;
      double af, ep, sar;
      double []ep_temp = new double[1] ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInAcceleration == (-4e+37) )
         optInAcceleration = 2.000000e-2;
      else if( (optInAcceleration < 0.000000e+0) || (optInAcceleration > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInMaximum == (-4e+37) )
         optInMaximum = 2.000000e-1;
      else if( (optInMaximum < 0.000000e+0) || (optInMaximum > 3.000000e+37) )
         return RetCode.BadParam ;
      if( startIdx < 1 )
         startIdx = 1;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      af = optInAcceleration;
      if( af > optInMaximum )
         af = optInAcceleration = optInMaximum;
      retCode = minusDM ( startIdx, startIdx, inHigh, inLow, 1,
         tempInt , tempInt ,
         ep_temp );
      if( ep_temp[0] > 0 )
         isLong = 0;
      else
         isLong = 1;
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      outBegIdx.value = startIdx;
      outIdx = 0;
      todayIdx = startIdx;
      newHigh = inHigh[todayIdx-1];
      newLow = inLow[todayIdx-1];
      if( isLong == 1 )
      {
         ep = inHigh[todayIdx];
         sar = newLow;
      }
      else
      {
         ep = inLow[todayIdx];
         sar = newHigh;
      }
      newLow = inLow[todayIdx];
      newHigh = inHigh[todayIdx];
      while( todayIdx <= endIdx )
      {
         prevLow = newLow;
         prevHigh = newHigh;
         newLow = inLow[todayIdx];
         newHigh = inHigh[todayIdx];
         todayIdx++;
         if( isLong == 1 )
         {
            if( newLow <= sar )
            {
               isLong = 0;
               sar = ep;
               if( sar < prevHigh )
                  sar = prevHigh;
               if( sar < newHigh )
                  sar = newHigh;
               outReal[outIdx++] = sar;
               af = optInAcceleration;
               ep = newLow;
               sar = sar + af * (ep - sar);
               if( sar < prevHigh )
                  sar = prevHigh;
               if( sar < newHigh )
                  sar = newHigh;
            }
            else
            {
               outReal[outIdx++] = sar;
               if( newHigh > ep )
               {
                  ep = newHigh;
                  af += optInAcceleration;
                  if( af > optInMaximum )
                     af = optInMaximum;
               }
               sar = sar + af * (ep - sar);
               if( sar > prevLow )
                  sar = prevLow;
               if( sar > newLow )
                  sar = newLow;
            }
         }
         else
         {
            if( newHigh >= sar )
            {
               isLong = 1;
               sar = ep;
               if( sar > prevLow )
                  sar = prevLow;
               if( sar > newLow )
                  sar = newLow;
               outReal[outIdx++] = sar;
               af = optInAcceleration;
               ep = newHigh;
               sar = sar + af * (ep - sar);
               if( sar > prevLow )
                  sar = prevLow;
               if( sar > newLow )
                  sar = newLow;
            }
            else
            {
               outReal[outIdx++] = sar;
               if( newLow < ep )
               {
                  ep = newLow;
                  af += optInAcceleration;
                  if( af > optInMaximum )
                     af = optInMaximum;
               }
               sar = sar + af * (ep - sar);
               if( sar < prevHigh )
                  sar = prevHigh;
               if( sar < newHigh )
                  sar = newHigh;
            }
         }
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode sarStateInit( struct TA_sar_State** _state,
      double optInAcceleration,
      double optInMaximum )
   {
      TA_RetCode retCode;
      if (_state == NULL)
         return RetCode.BadParam ;
      if( optInAcceleration == (-4e+37) )
         optInAcceleration = 2.000000e-2;
      else if( (optInAcceleration < 0.000000e+0) || (optInAcceleration > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInMaximum == (-4e+37) )
         optInMaximum = 2.000000e-1;
      else if( (optInMaximum < 0.000000e+0) || (optInMaximum > 3.000000e+37) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct sar ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInAcceleration = optInAcceleration;
      _state.value .value .optInMaximum = optInMaximum;
      _state.value .value .mem_size = sarLookback (optInAcceleration, optInMaximum );
      _state.value .value .memory = NULL;
      if( optInAcceleration > optInMaximum )
         _state.value .value .optInAcceleration = optInMaximum;
      retCode = minusDM ( (struct minusDM **) & _state.value .value .stateMINUS_DM, 1 );
      return retCode;
   }
   public RetCode sarState( struct TA_sar_State* _state,
      double inHigh,
      double inLow,
      double *outReal )
   {
      TA_RetCode retCode;
      double ep_temp;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if( _state.value .mem_index <= 2)
      {
         if( ( _state.value .mem_index == 1) )
         {
            _state.value .af = _state.value .optInAcceleration;
            _state.value .newHigh = inHigh;
            _state.value .newLow = inLow;
         }
         retCode = minusDM ( (struct minusDM *) _state.value .stateMINUS_DM, inHigh, inLow, &ep_temp );
         if (retCode != RetCode.Success ) return retCode;
         if (ep_temp > 0)
         {
            _state.value .isLong = 0;
            _state.value .ep = inLow;
            _state.value .sar = _state.value .newHigh;
         } else {
            _state.value .isLong = 1;
            _state.value .ep = inHigh;
            _state.value .sar = _state.value .newLow;
         }
         _state.value .newHigh = inHigh;
         _state.value .newLow = inLow;
      }
      _state.value .prevLow = _state.value .newLow;
      _state.value .prevHigh = _state.value .newHigh;
      _state.value .newLow = inLow;
      _state.value .newHigh = inHigh;
      if( _state.value .isLong == 1 )
      {
         if( _state.value .newLow <= _state.value .sar )
         {
            _state.value .isLong = 0;
            _state.value .sar = _state.value .ep;
            if( _state.value .sar < _state.value .prevHigh )
               _state.value .sar = _state.value .prevHigh;
            if( _state.value .sar < _state.value .newHigh )
               _state.value .sar = _state.value .newHigh;
            outReal.value = _state.value .sar;
            _state.value .af = _state.value .optInAcceleration;
            _state.value .ep = _state.value .newLow;
            _state.value .sar = _state.value .sar + _state.value .af * ( _state.value .ep - _state.value .sar);
            if( _state.value .sar < _state.value .prevHigh )
               _state.value .sar = _state.value .prevHigh;
            if( _state.value .sar < _state.value .newHigh )
               _state.value .sar = _state.value .newHigh;
         }
         else
         {
            outReal.value = _state.value .sar;
            if( _state.value .newHigh > _state.value .ep )
            {
               _state.value .ep = _state.value .newHigh;
               _state.value .af += _state.value .optInAcceleration;
               if( _state.value .af > _state.value .optInMaximum )
                  _state.value .af = _state.value .optInMaximum;
            }
            _state.value .sar = _state.value .sar + _state.value .af * ( _state.value .ep - _state.value .sar);
            if( _state.value .sar > _state.value .prevLow )
               _state.value .sar = _state.value .prevLow;
            if( _state.value .sar > _state.value .newLow )
               _state.value .sar = _state.value .newLow;
         }
      }
      else
      {
         if( _state.value .newHigh >= _state.value .sar )
         {
            _state.value .isLong = 1;
            _state.value .sar = _state.value .ep;
            if( _state.value .sar > _state.value .prevLow )
               _state.value .sar = _state.value .prevLow;
            if( _state.value .sar > _state.value .newLow )
               _state.value .sar = _state.value .newLow;
            outReal.value = _state.value .sar;
            _state.value .af = _state.value .optInAcceleration;
            _state.value .ep = _state.value .newHigh;
            _state.value .sar = _state.value .sar + _state.value .af * ( _state.value .ep - _state.value .sar);
            if( _state.value .sar > _state.value .prevLow )
               _state.value .sar = _state.value .prevLow;
            if( _state.value .sar > _state.value .newLow )
               _state.value .sar = _state.value .newLow;
         }
         else
         {
            outReal.value = _state.value .sar;
            if( _state.value .newLow < _state.value .ep )
            {
               _state.value .ep = _state.value .newLow;
               _state.value .af += _state.value .optInAcceleration;
               if( _state.value .af > _state.value .optInMaximum )
                  _state.value .af = _state.value .optInMaximum;
            }
            _state.value .sar = _state.value .sar + _state.value .af * ( _state.value .ep - _state.value .sar);
            if( _state.value .sar < _state.value .prevHigh )
               _state.value .sar = _state.value .prevHigh;
            if( _state.value .sar < _state.value .newHigh )
               _state.value .sar = _state.value .newHigh;
         }
      }
      return RetCode.Success ;
   }
   public RetCode sarStateFree( struct TA_sar_State** _state )
   {
      TA_RetCode retCode;
      retCode = minusDM ( (struct minusDM **) & _state.value .value .stateMINUS_DM );
      if (retCode != RetCode.Success ) return retCode;
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode sarStateSave( struct TA_sar_State* _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_SAR_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInAcceleration,sizeof( _state.value .optInAcceleration),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInMaximum,sizeof( _state.value .optInMaximum),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .newHigh,sizeof( _state.value .newHigh),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .newLow,sizeof( _state.value .newLow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevHigh,sizeof( _state.value .prevHigh),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevLow,sizeof( _state.value .prevLow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .isLong,sizeof( _state.value .isLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .sar,sizeof( _state.value .sar),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ep,sizeof( _state.value .ep),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .af,sizeof( _state.value .af),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_MINUS_DM_StateSave ( (struct minusDM *) _state.value .stateMINUS_DM, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode sarStateLoad( struct TA_sar_State** _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct sar ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_SAR_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_SAR_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInAcceleration,sizeof( _state.value .value .optInAcceleration),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInMaximum,sizeof( _state.value .value .optInMaximum),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .newHigh,sizeof( _state.value .value .newHigh),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .newLow,sizeof( _state.value .value .newLow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevHigh,sizeof( _state.value .value .prevHigh),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevLow,sizeof( _state.value .value .prevLow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .isLong,sizeof( _state.value .value .isLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .sar,sizeof( _state.value .value .sar),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ep,sizeof( _state.value .value .ep),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .af,sizeof( _state.value .value .af),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_MINUS_DM_StateLoad ( (struct minusDM **) & _state.value .value .stateMINUS_DM, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode sar( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      double optInAcceleration,
      double optInMaximum,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      RetCode retCode;
      int isLong;
      int todayIdx, outIdx;
      MInteger tempInt = new MInteger() ;
      double newHigh, newLow, prevHigh, prevLow;
      double af, ep, sar;
      double []ep_temp = new double[1] ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInAcceleration == (-4e+37) )
         optInAcceleration = 2.000000e-2;
      else if( (optInAcceleration < 0.000000e+0) || (optInAcceleration > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInMaximum == (-4e+37) )
         optInMaximum = 2.000000e-1;
      else if( (optInMaximum < 0.000000e+0) || (optInMaximum > 3.000000e+37) )
         return RetCode.BadParam ;
      if( startIdx < 1 )
         startIdx = 1;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      af = optInAcceleration;
      if( af > optInMaximum )
         af = optInAcceleration = optInMaximum;
      retCode = minusDM ( startIdx, startIdx, inHigh, inLow, 1,
         tempInt , tempInt ,
         ep_temp );
      if( ep_temp[0] > 0 )
         isLong = 0;
      else
         isLong = 1;
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      outBegIdx.value = startIdx;
      outIdx = 0;
      todayIdx = startIdx;
      newHigh = inHigh[todayIdx-1];
      newLow = inLow[todayIdx-1];
      if( isLong == 1 )
      {
         ep = inHigh[todayIdx];
         sar = newLow;
      }
      else
      {
         ep = inLow[todayIdx];
         sar = newHigh;
      }
      newLow = inLow[todayIdx];
      newHigh = inHigh[todayIdx];
      while( todayIdx <= endIdx )
      {
         prevLow = newLow;
         prevHigh = newHigh;
         newLow = inLow[todayIdx];
         newHigh = inHigh[todayIdx];
         todayIdx++;
         if( isLong == 1 )
         {
            if( newLow <= sar )
            {
               isLong = 0;
               sar = ep;
               if( sar < prevHigh )
                  sar = prevHigh;
               if( sar < newHigh )
                  sar = newHigh;
               outReal[outIdx++] = sar;
               af = optInAcceleration;
               ep = newLow;
               sar = sar + af * (ep - sar);
               if( sar < prevHigh )
                  sar = prevHigh;
               if( sar < newHigh )
                  sar = newHigh;
            }
            else
            {
               outReal[outIdx++] = sar;
               if( newHigh > ep )
               {
                  ep = newHigh;
                  af += optInAcceleration;
                  if( af > optInMaximum )
                     af = optInMaximum;
               }
               sar = sar + af * (ep - sar);
               if( sar > prevLow )
                  sar = prevLow;
               if( sar > newLow )
                  sar = newLow;
            }
         }
         else
         {
            if( newHigh >= sar )
            {
               isLong = 1;
               sar = ep;
               if( sar > prevLow )
                  sar = prevLow;
               if( sar > newLow )
                  sar = newLow;
               outReal[outIdx++] = sar;
               af = optInAcceleration;
               ep = newHigh;
               sar = sar + af * (ep - sar);
               if( sar > prevLow )
                  sar = prevLow;
               if( sar > newLow )
                  sar = newLow;
            }
            else
            {
               outReal[outIdx++] = sar;
               if( newLow < ep )
               {
                  ep = newLow;
                  af += optInAcceleration;
                  if( af > optInMaximum )
                     af = optInMaximum;
               }
               sar = sar + af * (ep - sar);
               if( sar < prevHigh )
                  sar = prevHigh;
               if( sar < newHigh )
                  sar = newHigh;
            }
         }
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int sarExtLookback( double optInStartValue,
      double optInOffsetOnReverse,
      double optInAccelerationInitLong,
      double optInAccelerationLong,
      double optInAccelerationMaxLong,
      double optInAccelerationInitShort,
      double optInAccelerationShort,
      double optInAccelerationMaxShort )
   {
      if( optInStartValue == (-4e+37) )
         optInStartValue = 0.000000e+0;
      else if( (optInStartValue < -3.000000e+37) || (optInStartValue > 3.000000e+37) )
         return -1;
      if( optInOffsetOnReverse == (-4e+37) )
         optInOffsetOnReverse = 0.000000e+0;
      else if( (optInOffsetOnReverse < 0.000000e+0) || (optInOffsetOnReverse > 3.000000e+37) )
         return -1;
      if( optInAccelerationInitLong == (-4e+37) )
         optInAccelerationInitLong = 2.000000e-2;
      else if( (optInAccelerationInitLong < 0.000000e+0) || (optInAccelerationInitLong > 3.000000e+37) )
         return -1;
      if( optInAccelerationLong == (-4e+37) )
         optInAccelerationLong = 2.000000e-2;
      else if( (optInAccelerationLong < 0.000000e+0) || (optInAccelerationLong > 3.000000e+37) )
         return -1;
      if( optInAccelerationMaxLong == (-4e+37) )
         optInAccelerationMaxLong = 2.000000e-1;
      else if( (optInAccelerationMaxLong < 0.000000e+0) || (optInAccelerationMaxLong > 3.000000e+37) )
         return -1;
      if( optInAccelerationInitShort == (-4e+37) )
         optInAccelerationInitShort = 2.000000e-2;
      else if( (optInAccelerationInitShort < 0.000000e+0) || (optInAccelerationInitShort > 3.000000e+37) )
         return -1;
      if( optInAccelerationShort == (-4e+37) )
         optInAccelerationShort = 2.000000e-2;
      else if( (optInAccelerationShort < 0.000000e+0) || (optInAccelerationShort > 3.000000e+37) )
         return -1;
      if( optInAccelerationMaxShort == (-4e+37) )
         optInAccelerationMaxShort = 2.000000e-1;
      else if( (optInAccelerationMaxShort < 0.000000e+0) || (optInAccelerationMaxShort > 3.000000e+37) )
         return -1;
      return 1;
   }
   public RetCode sarExt( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double optInStartValue,
      double optInOffsetOnReverse,
      double optInAccelerationInitLong,
      double optInAccelerationLong,
      double optInAccelerationMaxLong,
      double optInAccelerationInitShort,
      double optInAccelerationShort,
      double optInAccelerationMaxShort,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      RetCode retCode;
      int isLong;
      int todayIdx, outIdx;
      MInteger tempInt = new MInteger() ;
      double newHigh, newLow, prevHigh, prevLow;
      double afLong, afShort, ep, sar;
      double []ep_temp = new double[1] ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInStartValue == (-4e+37) )
         optInStartValue = 0.000000e+0;
      else if( (optInStartValue < -3.000000e+37) || (optInStartValue > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInOffsetOnReverse == (-4e+37) )
         optInOffsetOnReverse = 0.000000e+0;
      else if( (optInOffsetOnReverse < 0.000000e+0) || (optInOffsetOnReverse > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationInitLong == (-4e+37) )
         optInAccelerationInitLong = 2.000000e-2;
      else if( (optInAccelerationInitLong < 0.000000e+0) || (optInAccelerationInitLong > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationLong == (-4e+37) )
         optInAccelerationLong = 2.000000e-2;
      else if( (optInAccelerationLong < 0.000000e+0) || (optInAccelerationLong > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationMaxLong == (-4e+37) )
         optInAccelerationMaxLong = 2.000000e-1;
      else if( (optInAccelerationMaxLong < 0.000000e+0) || (optInAccelerationMaxLong > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationInitShort == (-4e+37) )
         optInAccelerationInitShort = 2.000000e-2;
      else if( (optInAccelerationInitShort < 0.000000e+0) || (optInAccelerationInitShort > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationShort == (-4e+37) )
         optInAccelerationShort = 2.000000e-2;
      else if( (optInAccelerationShort < 0.000000e+0) || (optInAccelerationShort > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationMaxShort == (-4e+37) )
         optInAccelerationMaxShort = 2.000000e-1;
      else if( (optInAccelerationMaxShort < 0.000000e+0) || (optInAccelerationMaxShort > 3.000000e+37) )
         return RetCode.BadParam ;
      if( startIdx < 1 )
         startIdx = 1;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      afLong = optInAccelerationInitLong;
      afShort = optInAccelerationInitShort;
      if( afLong > optInAccelerationMaxLong )
         afLong = optInAccelerationInitLong = optInAccelerationMaxLong;
      if( optInAccelerationLong > optInAccelerationMaxLong )
         optInAccelerationLong = optInAccelerationMaxLong;
      if( afShort > optInAccelerationMaxShort)
         afShort = optInAccelerationInitShort = optInAccelerationMaxShort;
      if( optInAccelerationShort > optInAccelerationMaxShort )
         optInAccelerationShort = optInAccelerationMaxShort;
      if(optInStartValue == 0)
      {
         retCode = minusDM ( startIdx, startIdx, inHigh, inLow, 1,
            tempInt , tempInt ,
            ep_temp );
         if( ep_temp[0] > 0 )
            isLong = 0;
         else
            isLong = 1;
         if( retCode != RetCode.Success )
         {
            outBegIdx.value = 0 ;
            outNBElement.value = 0 ;
            return retCode;
         }
      }
      else if( optInStartValue > 0 )
      {
         isLong = 1;
      }
      else
      {
         isLong = 0;
      }
      outBegIdx.value = startIdx;
      outIdx = 0;
      todayIdx = startIdx;
      newHigh = inHigh[todayIdx-1];
      newLow = inLow[todayIdx-1];
      if(optInStartValue == 0)
      {
         if( isLong == 1 )
         {
            ep = inHigh[todayIdx];
            sar = newLow;
         }
         else
         {
            ep = inLow[todayIdx];
            sar = newHigh;
         }
      }
      else if ( optInStartValue > 0 )
      {
         ep = inHigh[todayIdx];
         sar = optInStartValue;
      }
      else
      {
         ep = inLow[todayIdx];
         sar = Math.abs (optInStartValue);
      }
      newLow = inLow[todayIdx];
      newHigh = inHigh[todayIdx];
      while( todayIdx <= endIdx )
      {
         prevLow = newLow;
         prevHigh = newHigh;
         newLow = inLow[todayIdx];
         newHigh = inHigh[todayIdx];
         todayIdx++;
         if( isLong == 1 )
         {
            if( newLow <= sar )
            {
               isLong = 0;
               sar = ep;
               if( sar < prevHigh )
                  sar = prevHigh;
               if( sar < newHigh )
                  sar = newHigh;
               if( optInOffsetOnReverse != 0.0 )
                  sar += sar * optInOffsetOnReverse;
               outReal[outIdx++] = -sar;
               afShort = optInAccelerationInitShort;
               ep = newLow;
               sar = sar + afShort * (ep - sar);
               if( sar < prevHigh )
                  sar = prevHigh;
               if( sar < newHigh )
                  sar = newHigh;
            }
            else
            {
               outReal[outIdx++] = sar;
               if( newHigh > ep )
               {
                  ep = newHigh;
                  afLong += optInAccelerationLong;
                  if( afLong > optInAccelerationMaxLong )
                     afLong = optInAccelerationMaxLong;
               }
               sar = sar + afLong * (ep - sar);
               if( sar > prevLow )
                  sar = prevLow;
               if( sar > newLow )
                  sar = newLow;
            }
         }
         else
         {
            if( newHigh >= sar )
            {
               isLong = 1;
               sar = ep;
               if( sar > prevLow )
                  sar = prevLow;
               if( sar > newLow )
                  sar = newLow;
               if( optInOffsetOnReverse != 0.0 )
                  sar -= sar * optInOffsetOnReverse;
               outReal[outIdx++] = sar;
               afLong = optInAccelerationInitLong;
               ep = newHigh;
               sar = sar + afLong * (ep - sar);
               if( sar > prevLow )
                  sar = prevLow;
               if( sar > newLow )
                  sar = newLow;
            }
            else
            {
               outReal[outIdx++] = -sar;
               if( newLow < ep )
               {
                  ep = newLow;
                  afShort += optInAccelerationShort;
                  if( afShort > optInAccelerationMaxShort )
                     afShort = optInAccelerationMaxShort;
               }
               sar = sar + afShort * (ep - sar);
               if( sar < prevHigh )
                  sar = prevHigh;
               if( sar < newHigh )
                  sar = newHigh;
            }
         }
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode sarExtStateInit( struct TA_sarExt_State** _state,
      double optInStartValue,
      double optInOffsetOnReverse,
      double optInAccelerationInitLong,
      double optInAccelerationLong,
      double optInAccelerationMaxLong,
      double optInAccelerationInitShort,
      double optInAccelerationShort,
      double optInAccelerationMaxShort )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( optInStartValue == (-4e+37) )
         optInStartValue = 0.000000e+0;
      else if( (optInStartValue < -3.000000e+37) || (optInStartValue > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInOffsetOnReverse == (-4e+37) )
         optInOffsetOnReverse = 0.000000e+0;
      else if( (optInOffsetOnReverse < 0.000000e+0) || (optInOffsetOnReverse > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationInitLong == (-4e+37) )
         optInAccelerationInitLong = 2.000000e-2;
      else if( (optInAccelerationInitLong < 0.000000e+0) || (optInAccelerationInitLong > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationLong == (-4e+37) )
         optInAccelerationLong = 2.000000e-2;
      else if( (optInAccelerationLong < 0.000000e+0) || (optInAccelerationLong > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationMaxLong == (-4e+37) )
         optInAccelerationMaxLong = 2.000000e-1;
      else if( (optInAccelerationMaxLong < 0.000000e+0) || (optInAccelerationMaxLong > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationInitShort == (-4e+37) )
         optInAccelerationInitShort = 2.000000e-2;
      else if( (optInAccelerationInitShort < 0.000000e+0) || (optInAccelerationInitShort > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationShort == (-4e+37) )
         optInAccelerationShort = 2.000000e-2;
      else if( (optInAccelerationShort < 0.000000e+0) || (optInAccelerationShort > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationMaxShort == (-4e+37) )
         optInAccelerationMaxShort = 2.000000e-1;
      else if( (optInAccelerationMaxShort < 0.000000e+0) || (optInAccelerationMaxShort > 3.000000e+37) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct sarExt ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInStartValue = optInStartValue;
      _state.value .value .optInOffsetOnReverse = optInOffsetOnReverse;
      _state.value .value .optInAccelerationInitLong = optInAccelerationInitLong;
      _state.value .value .optInAccelerationLong = optInAccelerationLong;
      _state.value .value .optInAccelerationMaxLong = optInAccelerationMaxLong;
      _state.value .value .optInAccelerationInitShort = optInAccelerationInitShort;
      _state.value .value .optInAccelerationShort = optInAccelerationShort;
      _state.value .value .optInAccelerationMaxShort = optInAccelerationMaxShort;
      _state.value .value .mem_size = sarExtLookback (optInStartValue, optInOffsetOnReverse, optInAccelerationInitLong, optInAccelerationLong, optInAccelerationMaxLong, optInAccelerationInitShort, optInAccelerationShort, optInAccelerationMaxShort );
      _state.value .value .memory = NULL;
      _state.value .value .afLong = optInAccelerationInitLong;
      _state.value .value .afShort = optInAccelerationInitShort;
      if( optInAccelerationInitLong > optInAccelerationMaxLong )
         _state.value .value .afLong = _state.value .value .optInAccelerationInitLong = optInAccelerationMaxLong;
      if( optInAccelerationLong > optInAccelerationMaxLong )
         _state.value .value .optInAccelerationLong = optInAccelerationMaxLong;
      if( optInAccelerationInitShort > optInAccelerationMaxShort)
         _state.value .value .afShort = _state.value .value .optInAccelerationInitShort = optInAccelerationMaxShort;
      if( optInAccelerationShort > optInAccelerationMaxShort )
         _state.value .value .optInAccelerationShort = optInAccelerationMaxShort;
      if(optInStartValue == 0)
         return minusDM ( (struct minusDM **) & _state.value .value .stateMINUS_DM, 1 );
      else
         _state.value .value .stateMINUS_DM = NULL;
      return RetCode.Success ;
   }
   public RetCode sarExtState( struct TA_sarExt_State* _state,
      double inHigh,
      double inLow,
      double *outReal )
   {
      TA_RetCode retCode;
      double ep_temp;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if( _state.value .mem_index <= 2)
      {
         if( ( _state.value .mem_index == 1) )
         {
            _state.value .newHigh = inHigh;
            _state.value .newLow = inLow;
         }
         if( _state.value .optInStartValue == 0)
         {
            retCode = minusDM ( (struct minusDM *) _state.value .stateMINUS_DM, inHigh, inLow, &ep_temp );
            if (retCode != RetCode.Success ) return retCode;
            _state.value .isLong = (ep_temp > 0)?0:1;
         } else
            _state.value .isLong = ( _state.value .optInStartValue > 0)?1:0;
         if( _state.value .optInStartValue == 0)
         {
            if ( _state.value .isLong == 0)
            {
               _state.value .ep = inLow;
               _state.value .sar = _state.value .newHigh;
            } else {
               _state.value .ep = inHigh;
               _state.value .sar = _state.value .newLow;
            }
         } else
            if ( _state.value .optInStartValue > 0 )
         {
            _state.value .ep = inHigh;
            _state.value .sar = _state.value .optInStartValue;
         }
         else
         {
            _state.value .ep = inLow;
            _state.value .sar = Math.abs ( _state.value .optInStartValue);
         }
         _state.value .newHigh = inHigh;
         _state.value .newLow = inLow;
      }
      _state.value .prevLow = _state.value .newLow;
      _state.value .prevHigh = _state.value .newHigh;
      _state.value .newLow = inLow;
      _state.value .newHigh = inHigh;
      if( _state.value .isLong == 1 )
      {
         if( _state.value .newLow <= _state.value .sar )
         {
            _state.value .isLong = 0;
            _state.value .sar = _state.value .ep;
            if( _state.value .sar < _state.value .prevHigh )
               _state.value .sar = _state.value .prevHigh;
            if( _state.value .sar < _state.value .newHigh )
               _state.value .sar = _state.value .newHigh;
            if( _state.value .optInOffsetOnReverse != 0.0 )
               _state.value .sar += _state.value .sar * _state.value .optInOffsetOnReverse;
            outReal.value = - _state.value .sar;
            _state.value .afShort = _state.value .optInAccelerationInitShort;
            _state.value .ep = _state.value .newLow;
            _state.value .sar = _state.value .sar + _state.value .afShort * ( _state.value .ep - _state.value .sar);
            if( _state.value .sar < _state.value .prevHigh )
               _state.value .sar = _state.value .prevHigh;
            if( _state.value .sar < _state.value .newHigh )
               _state.value .sar = _state.value .newHigh;
         }
         else
         {
            outReal.value = _state.value .sar;
            if( _state.value .newHigh > _state.value .ep )
            {
               _state.value .ep = _state.value .newHigh;
               _state.value .afLong += _state.value .optInAccelerationLong;
               if( _state.value .afLong > _state.value .optInAccelerationMaxLong )
                  _state.value .afLong = _state.value .optInAccelerationMaxLong;
            }
            _state.value .sar = _state.value .sar + _state.value .afLong * ( _state.value .ep - _state.value .sar);
            if( _state.value .sar > _state.value .prevLow )
               _state.value .sar = _state.value .prevLow;
            if( _state.value .sar > _state.value .newLow )
               _state.value .sar = _state.value .newLow;
         }
      }
      else
      {
         if( _state.value .newHigh >= _state.value .sar )
         {
            _state.value .isLong = 1;
            _state.value .sar = _state.value .ep;
            if( _state.value .sar > _state.value .prevLow )
               _state.value .sar = _state.value .prevLow;
            if( _state.value .sar > _state.value .newLow )
               _state.value .sar = _state.value .newLow;
            if( _state.value .optInOffsetOnReverse != 0.0 )
               _state.value .sar -= _state.value .sar * _state.value .optInOffsetOnReverse;
            outReal.value = _state.value .sar;
            _state.value .afLong = _state.value .optInAccelerationInitLong;
            _state.value .ep = _state.value .newHigh;
            _state.value .sar = _state.value .sar + _state.value .afLong * ( _state.value .ep - _state.value .sar);
            if( _state.value .sar > _state.value .prevLow )
               _state.value .sar = _state.value .prevLow;
            if( _state.value .sar > _state.value .newLow )
               _state.value .sar = _state.value .newLow;
         }
         else
         {
            outReal.value = - _state.value .sar;
            if( _state.value .newLow < _state.value .ep )
            {
               _state.value .ep = _state.value .newLow;
               _state.value .afShort += _state.value .optInAccelerationShort;
               if( _state.value .afShort > _state.value .optInAccelerationMaxShort )
                  _state.value .afShort = _state.value .optInAccelerationMaxShort;
            }
            _state.value .sar = _state.value .sar + _state.value .afShort * ( _state.value .ep - _state.value .sar);
            if( _state.value .sar < _state.value .prevHigh )
               _state.value .sar = _state.value .prevHigh;
            if( _state.value .sar < _state.value .newHigh )
               _state.value .sar = _state.value .newHigh;
         }
      }
      return RetCode.Success ;
   }
   public RetCode sarExtStateFree( struct TA_sarExt_State** _state )
   {
      if ( _state.value .value .optInStartValue == 0)
      {
         TA_RetCode retCode;
         retCode = minusDM ( (struct minusDM **) & _state.value .value .stateMINUS_DM );
         if (retCode != RetCode.Success ) return retCode;
      }
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode sarExtStateSave( struct TA_sarExt_State* _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_SAREXT_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInStartValue,sizeof( _state.value .optInStartValue),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInOffsetOnReverse,sizeof( _state.value .optInOffsetOnReverse),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInAccelerationInitLong,sizeof( _state.value .optInAccelerationInitLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInAccelerationLong,sizeof( _state.value .optInAccelerationLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInAccelerationMaxLong,sizeof( _state.value .optInAccelerationMaxLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInAccelerationInitShort,sizeof( _state.value .optInAccelerationInitShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInAccelerationShort,sizeof( _state.value .optInAccelerationShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInAccelerationMaxShort,sizeof( _state.value .optInAccelerationMaxShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .newHigh,sizeof( _state.value .newHigh),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .newLow,sizeof( _state.value .newLow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevHigh,sizeof( _state.value .prevHigh),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevLow,sizeof( _state.value .prevLow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .isLong,sizeof( _state.value .isLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .sar,sizeof( _state.value .sar),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .ep,sizeof( _state.value .ep),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .afLong,sizeof( _state.value .afLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .afShort,sizeof( _state.value .afShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_MINUS_DM_StateSave ( (struct minusDM *) _state.value .stateMINUS_DM, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode sarExtStateLoad( struct TA_sarExt_State** _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct sarExt ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_SAREXT_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_SAREXT_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInStartValue,sizeof( _state.value .value .optInStartValue),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInOffsetOnReverse,sizeof( _state.value .value .optInOffsetOnReverse),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInAccelerationInitLong,sizeof( _state.value .value .optInAccelerationInitLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInAccelerationLong,sizeof( _state.value .value .optInAccelerationLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInAccelerationMaxLong,sizeof( _state.value .value .optInAccelerationMaxLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInAccelerationInitShort,sizeof( _state.value .value .optInAccelerationInitShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInAccelerationShort,sizeof( _state.value .value .optInAccelerationShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInAccelerationMaxShort,sizeof( _state.value .value .optInAccelerationMaxShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .newHigh,sizeof( _state.value .value .newHigh),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .newLow,sizeof( _state.value .value .newLow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevHigh,sizeof( _state.value .value .prevHigh),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevLow,sizeof( _state.value .value .prevLow),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .isLong,sizeof( _state.value .value .isLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .sar,sizeof( _state.value .value .sar),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .ep,sizeof( _state.value .value .ep),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .afLong,sizeof( _state.value .value .afLong),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .afShort,sizeof( _state.value .value .afShort),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_MINUS_DM_StateLoad ( (struct minusDM **) & _state.value .value .stateMINUS_DM, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode sarExt( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      double optInStartValue,
      double optInOffsetOnReverse,
      double optInAccelerationInitLong,
      double optInAccelerationLong,
      double optInAccelerationMaxLong,
      double optInAccelerationInitShort,
      double optInAccelerationShort,
      double optInAccelerationMaxShort,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      RetCode retCode;
      int isLong;
      int todayIdx, outIdx;
      MInteger tempInt = new MInteger() ;
      double newHigh, newLow, prevHigh, prevLow;
      double afLong, afShort, ep, sar;
      double []ep_temp = new double[1] ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInStartValue == (-4e+37) )
         optInStartValue = 0.000000e+0;
      else if( (optInStartValue < -3.000000e+37) || (optInStartValue > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInOffsetOnReverse == (-4e+37) )
         optInOffsetOnReverse = 0.000000e+0;
      else if( (optInOffsetOnReverse < 0.000000e+0) || (optInOffsetOnReverse > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationInitLong == (-4e+37) )
         optInAccelerationInitLong = 2.000000e-2;
      else if( (optInAccelerationInitLong < 0.000000e+0) || (optInAccelerationInitLong > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationLong == (-4e+37) )
         optInAccelerationLong = 2.000000e-2;
      else if( (optInAccelerationLong < 0.000000e+0) || (optInAccelerationLong > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationMaxLong == (-4e+37) )
         optInAccelerationMaxLong = 2.000000e-1;
      else if( (optInAccelerationMaxLong < 0.000000e+0) || (optInAccelerationMaxLong > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationInitShort == (-4e+37) )
         optInAccelerationInitShort = 2.000000e-2;
      else if( (optInAccelerationInitShort < 0.000000e+0) || (optInAccelerationInitShort > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationShort == (-4e+37) )
         optInAccelerationShort = 2.000000e-2;
      else if( (optInAccelerationShort < 0.000000e+0) || (optInAccelerationShort > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationMaxShort == (-4e+37) )
         optInAccelerationMaxShort = 2.000000e-1;
      else if( (optInAccelerationMaxShort < 0.000000e+0) || (optInAccelerationMaxShort > 3.000000e+37) )
         return RetCode.BadParam ;
      if( startIdx < 1 )
         startIdx = 1;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      afLong = optInAccelerationInitLong;
      afShort = optInAccelerationInitShort;
      if( afLong > optInAccelerationMaxLong )
         afLong = optInAccelerationInitLong = optInAccelerationMaxLong;
      if( optInAccelerationLong > optInAccelerationMaxLong )
         optInAccelerationLong = optInAccelerationMaxLong;
      if( afShort > optInAccelerationMaxShort)
         afShort = optInAccelerationInitShort = optInAccelerationMaxShort;
      if( optInAccelerationShort > optInAccelerationMaxShort )
         optInAccelerationShort = optInAccelerationMaxShort;
      if(optInStartValue == 0)
      {
         retCode = minusDM ( startIdx, startIdx, inHigh, inLow, 1,
            tempInt , tempInt ,
            ep_temp );
         if( ep_temp[0] > 0 )
            isLong = 0;
         else
            isLong = 1;
         if( retCode != RetCode.Success )
         {
            outBegIdx.value = 0 ;
            outNBElement.value = 0 ;
            return retCode;
         }
      }
      else if( optInStartValue > 0 )
      {
         isLong = 1;
      }
      else
      {
         isLong = 0;
      }
      outBegIdx.value = startIdx;
      outIdx = 0;
      todayIdx = startIdx;
      newHigh = inHigh[todayIdx-1];
      newLow = inLow[todayIdx-1];
      if(optInStartValue == 0)
      {
         if( isLong == 1 )
         {
            ep = inHigh[todayIdx];
            sar = newLow;
         }
         else
         {
            ep = inLow[todayIdx];
            sar = newHigh;
         }
      }
      else if ( optInStartValue > 0 )
      {
         ep = inHigh[todayIdx];
         sar = optInStartValue;
      }
      else
      {
         ep = inLow[todayIdx];
         sar = Math.abs (optInStartValue);
      }
      newLow = inLow[todayIdx];
      newHigh = inHigh[todayIdx];
      while( todayIdx <= endIdx )
      {
         prevLow = newLow;
         prevHigh = newHigh;
         newLow = inLow[todayIdx];
         newHigh = inHigh[todayIdx];
         todayIdx++;
         if( isLong == 1 )
         {
            if( newLow <= sar )
            {
               isLong = 0;
               sar = ep;
               if( sar < prevHigh )
                  sar = prevHigh;
               if( sar < newHigh )
                  sar = newHigh;
               if( optInOffsetOnReverse != 0.0 )
                  sar += sar * optInOffsetOnReverse;
               outReal[outIdx++] = -sar;
               afShort = optInAccelerationInitShort;
               ep = newLow;
               sar = sar + afShort * (ep - sar);
               if( sar < prevHigh )
                  sar = prevHigh;
               if( sar < newHigh )
                  sar = newHigh;
            }
            else
            {
               outReal[outIdx++] = sar;
               if( newHigh > ep )
               {
                  ep = newHigh;
                  afLong += optInAccelerationLong;
                  if( afLong > optInAccelerationMaxLong )
                     afLong = optInAccelerationMaxLong;
               }
               sar = sar + afLong * (ep - sar);
               if( sar > prevLow )
                  sar = prevLow;
               if( sar > newLow )
                  sar = newLow;
            }
         }
         else
         {
            if( newHigh >= sar )
            {
               isLong = 1;
               sar = ep;
               if( sar > prevLow )
                  sar = prevLow;
               if( sar > newLow )
                  sar = newLow;
               if( optInOffsetOnReverse != 0.0 )
                  sar -= sar * optInOffsetOnReverse;
               outReal[outIdx++] = sar;
               afLong = optInAccelerationInitLong;
               ep = newHigh;
               sar = sar + afLong * (ep - sar);
               if( sar > prevLow )
                  sar = prevLow;
               if( sar > newLow )
                  sar = newLow;
            }
            else
            {
               outReal[outIdx++] = -sar;
               if( newLow < ep )
               {
                  ep = newLow;
                  afShort += optInAccelerationShort;
                  if( afShort > optInAccelerationMaxShort )
                     afShort = optInAccelerationMaxShort;
               }
               sar = sar + afShort * (ep - sar);
               if( sar < prevHigh )
                  sar = prevHigh;
               if( sar < newHigh )
                  sar = newHigh;
            }
         }
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int sinLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode sin( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.sin (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode sinStateInit( struct TA_sin_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct sin ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = sinLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_SIN_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode sinState( struct TA_sin_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.sin (inReal);
      return RetCode.Success ;
   }
   public RetCode sinStateFree( struct TA_sin_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode sinStateSave( struct TA_sin_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_SIN_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode sinStateLoad( struct TA_sin_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct sin ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_SIN_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_SIN_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode sin( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.sin (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int sinhLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode sinh( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.sinh (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode sinhStateInit( struct TA_sinh_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct sinh ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = sinhLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_SINH_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode sinhState( struct TA_sinh_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.sinh (inReal);
      return RetCode.Success ;
   }
   public RetCode sinhStateFree( struct TA_sinh_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode sinhStateSave( struct TA_sinh_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_SINH_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode sinhStateLoad( struct TA_sinh_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct sinh ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_SINH_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_SINH_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode sinh( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.sinh (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int smaLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod - 1;
   }
   public RetCode sma( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      return TA_INT_SMA ( startIdx, endIdx,
         inReal, optInTimePeriod,
         outBegIdx, outNBElement, outReal );
   }
   RetCode TA_INT_SMA( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double periodTotal, tempReal;
      int i, outIdx, trailingIdx, lookbackTotal;
      lookbackTotal = (optInTimePeriod-1);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      periodTotal = 0;
      trailingIdx = startIdx-lookbackTotal;
      i=trailingIdx;
      if( optInTimePeriod > 1 )
      {
         while( i < startIdx )
            periodTotal += inReal[i++];
      }
      outIdx = 0;
      do
      {
         periodTotal += inReal[i++];
         tempReal = periodTotal;
         periodTotal -= inReal[trailingIdx++];
         outReal[outIdx++] = tempReal / optInTimePeriod;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode smaStateInit( struct TA_sma_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct sma ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = smaLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_SMA_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode smaState( struct TA_sma_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .periodTotal = 0;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         _state.value .periodTotal += inReal;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      _state.value .periodTotal += inReal;
      outReal.value = _state.value .periodTotal / _state.value .optInTimePeriod;
      _state.value .periodTotal -= ( _state.value .memory+_cur_idx).value .inReal ;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      return RetCode.Success ;
   }
   public RetCode smaStateFree( struct TA_sma_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode smaStateSave( struct TA_sma_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_SMA_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodTotal,sizeof( _state.value .periodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode smaStateLoad( struct TA_sma_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct sma ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_SMA_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_SMA_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodTotal,sizeof( _state.value .value .periodTotal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode sma( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      return TA_INT_SMA ( startIdx, endIdx,
         inReal, optInTimePeriod,
         outBegIdx, outNBElement, outReal );
   }
   RetCode TA_INT_SMA( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double periodTotal, tempReal;
      int i, outIdx, trailingIdx, lookbackTotal;
      lookbackTotal = (optInTimePeriod-1);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      periodTotal = 0;
      trailingIdx = startIdx-lookbackTotal;
      i=trailingIdx;
      if( optInTimePeriod > 1 )
      {
         while( i < startIdx )
            periodTotal += inReal[i++];
      }
      outIdx = 0;
      do
      {
         periodTotal += inReal[i++];
         tempReal = periodTotal;
         periodTotal -= inReal[trailingIdx++];
         outReal[outIdx++] = tempReal / optInTimePeriod;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int sqrtLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode sqrt( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.sqrt (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode sqrtStateInit( struct TA_sqrt_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct sqrt ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = sqrtLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_SQRT_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode sqrtState( struct TA_sqrt_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.sqrt (inReal);
      return RetCode.Success ;
   }
   public RetCode sqrtStateFree( struct TA_sqrt_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode sqrtStateSave( struct TA_sqrt_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_SQRT_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode sqrtStateLoad( struct TA_sqrt_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct sqrt ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_SQRT_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_SQRT_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode sqrt( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.sqrt (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int stdDevLookback( int optInTimePeriod,
      double optInNbDev )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      if( optInNbDev == (-4e+37) )
         optInNbDev = 1.000000e+0;
      else if( (optInNbDev < -3.000000e+37) || (optInNbDev > 3.000000e+37) )
         return -1;
      return varianceLookback ( optInTimePeriod, optInNbDev );
   }
   public RetCode stdDev( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      double optInNbDev,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int i;
      RetCode retCode;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInNbDev == (-4e+37) )
         optInNbDev = 1.000000e+0;
      else if( (optInNbDev < -3.000000e+37) || (optInNbDev > 3.000000e+37) )
         return RetCode.BadParam ;
      retCode = TA_INT_VAR ( startIdx, endIdx,
         inReal, optInTimePeriod,
         outBegIdx, outNBElement, outReal );
      if( retCode != RetCode.Success )
         return retCode;
      if( optInNbDev != 1.0 )
      {
         for( i=0; i < (int) outNBElement.value ; i++ )
         {
            tempReal = outReal[i];
            if( ! (tempReal< (0.00000000000001) ) )
               outReal[i] = Math.sqrt (tempReal) * optInNbDev;
            else
               outReal[i] = (double)0.0;
         }
      }
      else
      {
         for( i=0; i < (int) outNBElement.value ; i++ )
         {
            tempReal = outReal[i];
            if( ! (tempReal< (0.00000000000001) ) )
               outReal[i] = Math.sqrt (tempReal);
            else
               outReal[i] = (double)0.0;
         }
      }
      return RetCode.Success ;
   }
   void TA_INT_stddev_using_precalc_ma( double inReal[],
      double inMovAvg[],
      int inMovAvgBegIdx,
      int inMovAvgNbElement,
      int timePeriod,
      double output[] )
   {
      double tempReal, periodTotal2, meanValue2;
      int outIdx;
      int startSum, endSum;
      startSum = 1+inMovAvgBegIdx-timePeriod;
      endSum = inMovAvgBegIdx;
      periodTotal2 = 0;
      for( outIdx = startSum; outIdx < endSum; outIdx++)
      {
         tempReal = inReal[outIdx];
         tempReal *= tempReal;
         periodTotal2 += tempReal;
      }
      for( outIdx=0; outIdx < inMovAvgNbElement; outIdx++, startSum++, endSum++ )
      {
         tempReal = inReal[endSum];
         tempReal *= tempReal;
         periodTotal2 += tempReal;
         meanValue2 = periodTotal2/timePeriod;
         tempReal = inReal[startSum];
         tempReal *= tempReal;
         periodTotal2 -= tempReal;
         tempReal = inMovAvg[outIdx];
         tempReal *= tempReal;
         meanValue2 -= tempReal;
         if( ! (meanValue2< (0.00000000000001) ) )
            output[outIdx] = Math.sqrt (meanValue2);
         else
            output[outIdx] = (double)0.0;
      }
   }
   public RetCode stdDevStateInit( struct TA_stdDev_State** _state,
      int optInTimePeriod,
      double optInNbDev )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInNbDev == (-4e+37) )
         optInNbDev = 1.000000e+0;
      else if( (optInNbDev < -3.000000e+37) || (optInNbDev > 3.000000e+37) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct stdDev ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .optInNbDev = optInNbDev;
      _state.value .value .mem_size = stdDevLookback (optInTimePeriod, optInNbDev );
      _state.value .value .memory = NULL;
      return variance ((struct variance **)& _state.value .value .var_state, optInTimePeriod, optInNbDev);
   }
   public RetCode stdDevState( struct TA_stdDev_State* _state,
      double inReal,
      double *outReal )
   {
      int retCode;
      double tempReal;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      retCode = variance ( _state.value .var_state, inReal, outReal );
      if( retCode != RetCode.Success )
         return retCode;
      if( _state.value .optInNbDev != 1.0 )
      {
         tempReal = outReal.value ;
         if( ! (tempReal< (0.00000000000001) ) )
            outReal.value = Math.sqrt (tempReal) * _state.value .optInNbDev;
         else
            outReal.value = (double)0.0;
      }
      else
      {
         tempReal = outReal.value ;
         if( ! (tempReal< (0.00000000000001) ) )
            outReal.value = Math.sqrt (tempReal);
         else
            outReal.value = (double)0.0;
      }
      return RetCode.Success ;
   }
   public RetCode stdDevStateFree( struct TA_stdDev_State** _state )
   {
      variance ((struct variance **)& _state.value .value .var_state);
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode stdDevStateSave( struct TA_stdDev_State* _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_STDDEV_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInNbDev,sizeof( _state.value .optInNbDev),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_VAR_StateSave ( (struct variance *) _state.value .var_state, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode stdDevStateLoad( struct TA_stdDev_State** _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct stdDev ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_STDDEV_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_STDDEV_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInNbDev,sizeof( _state.value .value .optInNbDev),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_VAR_StateLoad ( (struct variance **) & _state.value .value .var_state, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode stdDev( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      double optInNbDev,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int i;
      RetCode retCode;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInNbDev == (-4e+37) )
         optInNbDev = 1.000000e+0;
      else if( (optInNbDev < -3.000000e+37) || (optInNbDev > 3.000000e+37) )
         return RetCode.BadParam ;
      retCode = TA_INT_VAR ( startIdx, endIdx,
         inReal, optInTimePeriod,
         outBegIdx, outNBElement, outReal );
      if( retCode != RetCode.Success )
         return retCode;
      if( optInNbDev != 1.0 )
      {
         for( i=0; i < (int) outNBElement.value ; i++ )
         {
            tempReal = outReal[i];
            if( ! (tempReal< (0.00000000000001) ) )
               outReal[i] = Math.sqrt (tempReal) * optInNbDev;
            else
               outReal[i] = (double)0.0;
         }
      }
      else
      {
         for( i=0; i < (int) outNBElement.value ; i++ )
         {
            tempReal = outReal[i];
            if( ! (tempReal< (0.00000000000001) ) )
               outReal[i] = Math.sqrt (tempReal);
            else
               outReal[i] = (double)0.0;
         }
      }
      return RetCode.Success ;
   }
   void TA_INT_stddev_using_precalc_ma( float inReal[],
      double inMovAvg[],
      int inMovAvgBegIdx,
      int inMovAvgNbElement,
      int timePeriod,
      double output[] )
   {
      double tempReal, periodTotal2, meanValue2;
      int outIdx;
      int startSum, endSum;
      startSum = 1+inMovAvgBegIdx-timePeriod;
      endSum = inMovAvgBegIdx;
      periodTotal2 = 0;
      for( outIdx = startSum; outIdx < endSum; outIdx++)
      {
         tempReal = inReal[outIdx];
         tempReal *= tempReal;
         periodTotal2 += tempReal;
      }
      for( outIdx=0; outIdx < inMovAvgNbElement; outIdx++, startSum++, endSum++ )
      {
         tempReal = inReal[endSum];
         tempReal *= tempReal;
         periodTotal2 += tempReal;
         meanValue2 = periodTotal2/timePeriod;
         tempReal = inReal[startSum];
         tempReal *= tempReal;
         periodTotal2 -= tempReal;
         tempReal = inMovAvg[outIdx];
         tempReal *= tempReal;
         meanValue2 -= tempReal;
         if( ! (meanValue2< (0.00000000000001) ) )
            output[outIdx] = Math.sqrt (meanValue2);
         else
            output[outIdx] = (double)0.0;
      }
   }
   /* Generated */
   public int stochLookback( int optInFastK_Period,
      int optInSlowK_Period,
      MAType optInSlowK_MAType, int optInSlowD_Period,
      MAType optInSlowD_MAType )
   {
      int retValue;
      if( (int)optInFastK_Period == ( Integer.MIN_VALUE ) )
         optInFastK_Period = 5;
      else if( ((int)optInFastK_Period < 1) || ((int)optInFastK_Period > 100000) )
         return -1;
      if( (int)optInSlowK_Period == ( Integer.MIN_VALUE ) )
         optInSlowK_Period = 3;
      else if( ((int)optInSlowK_Period < 1) || ((int)optInSlowK_Period > 100000) )
         return -1;
      if( (int)optInSlowD_Period == ( Integer.MIN_VALUE ) )
         optInSlowD_Period = 3;
      else if( ((int)optInSlowD_Period < 1) || ((int)optInSlowD_Period > 100000) )
         return -1;
      retValue = (optInFastK_Period - 1);
      retValue += movingAverageLookback ( optInSlowK_Period, optInSlowK_MAType );
      retValue += movingAverageLookback ( optInSlowD_Period, optInSlowD_MAType );
      return retValue;
   }
   public RetCode stoch( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      int optInFastK_Period,
      int optInSlowK_Period,
      MAType optInSlowK_MAType, int optInSlowD_Period,
      MAType optInSlowD_MAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outSlowK[],
      double outSlowD[] )
   {
      RetCode retCode;
      double lowest, highest, tmp, diff;
      double []tempBuffer ;
      int outIdx, lowestIdx, highestIdx;
      int lookbackTotal, lookbackK, lookbackKSlow, lookbackDSlow;
      int trailingIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInFastK_Period == ( Integer.MIN_VALUE ) )
         optInFastK_Period = 5;
      else if( ((int)optInFastK_Period < 1) || ((int)optInFastK_Period > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowK_Period == ( Integer.MIN_VALUE ) )
         optInSlowK_Period = 3;
      else if( ((int)optInSlowK_Period < 1) || ((int)optInSlowK_Period > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowD_Period == ( Integer.MIN_VALUE ) )
         optInSlowD_Period = 3;
      else if( ((int)optInSlowD_Period < 1) || ((int)optInSlowD_Period > 100000) )
         return RetCode.BadParam ;
      lookbackK = optInFastK_Period-1;
      lookbackKSlow = movingAverageLookback ( optInSlowK_Period, optInSlowK_MAType );
      lookbackDSlow = movingAverageLookback ( optInSlowD_Period, optInSlowD_MAType );
      lookbackTotal = lookbackK + lookbackDSlow + lookbackKSlow;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      trailingIdx = startIdx-lookbackTotal;
      today = trailingIdx+lookbackK;
      lowestIdx = highestIdx = -1;
      diff = highest = lowest = 0.0;
      if( (outSlowK == inHigh) ||
         (outSlowK == inLow) ||
         (outSlowK == inClose) )
      {
         tempBuffer = outSlowK;
      }
      else if( (outSlowD == inHigh) ||
         (outSlowD == inLow) ||
         (outSlowD == inClose) )
      {
         tempBuffer = outSlowD;
      }
      else
      {
         tempBuffer = new double[endIdx-today+1] ;
      }
      while( today <= endIdx )
      {
         tmp = inLow[today];
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inLow[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmp = inLow[i];
               if( tmp < lowest )
               {
                  lowestIdx = i;
                  lowest = tmp;
               }
            }
            diff = (highest - lowest)/100.0;
         }
         else if( tmp <= lowest )
         {
            lowestIdx = today;
            lowest = tmp;
            diff = (highest - lowest)/100.0;
         }
         tmp = inHigh[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inHigh[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmp = inHigh[i];
               if( tmp > highest )
               {
                  highestIdx = i;
                  highest = tmp;
               }
            }
            diff = (highest - lowest)/100.0;
         }
         else if( tmp >= highest )
         {
            highestIdx = today;
            highest = tmp;
            diff = (highest - lowest)/100.0;
         }
         if( diff != 0.0 )
            tempBuffer[outIdx++] = (inClose[today]-lowest)/diff;
         else
            tempBuffer[outIdx++] = 0.0;
         trailingIdx++;
         today++;
      }
      retCode = movingAverage ( 0, outIdx-1,
         tempBuffer, optInSlowK_Period,
         optInSlowK_MAType,
         outBegIdx, outNBElement, tempBuffer );
      if( (retCode != RetCode.Success ) || ((int) outNBElement.value == 0) )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      retCode = movingAverage ( 0, (int) outNBElement.value -1,
         tempBuffer, optInSlowD_Period,
         optInSlowD_MAType,
         outBegIdx, outNBElement, outSlowD );
      System.arraycopy(tempBuffer,lookbackDSlow,outSlowK,0,(int) outNBElement.value ) ;
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode stochStateInit( struct TA_stoch_State** _state,
      int optInFastK_Period,
      int optInSlowK_Period,
      MAType optInSlowK_MAType, int optInSlowD_Period,
      MAType optInSlowD_MAType )
   {
      TA_RetCode retCode;
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInFastK_Period == ( Integer.MIN_VALUE ) )
         optInFastK_Period = 5;
      else if( ((int)optInFastK_Period < 1) || ((int)optInFastK_Period > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowK_Period == ( Integer.MIN_VALUE ) )
         optInSlowK_Period = 3;
      else if( ((int)optInSlowK_Period < 1) || ((int)optInSlowK_Period > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowD_Period == ( Integer.MIN_VALUE ) )
         optInSlowD_Period = 3;
      else if( ((int)optInSlowD_Period < 1) || ((int)optInSlowD_Period > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct stoch ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInFastK_Period = optInFastK_Period;
      _state.value .value .optInSlowK_Period = optInSlowK_Period;
      _state.value .value .optInSlowK_MAType = optInSlowK_MAType;
      _state.value .value .optInSlowD_Period = optInSlowD_Period;
      _state.value .value .optInSlowD_MAType = optInSlowD_MAType;
      _state.value .value .mem_size = stochLookback (optInFastK_Period, optInSlowK_Period, optInSlowK_MAType, optInSlowD_Period, optInSlowD_MAType );
      _state.value .value .memory = NULL;
      _state.value .value .mem_size = (optInFastK_Period - 1);
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_STOCH_Data));
      else _state.value .value .memory = NULL;
      retCode = movingAverage ( (struct movingAverage **) & _state.value .value .stateMA1, optInSlowK_Period, optInSlowK_MAType );
      if (retCode != RetCode.Success ) return retCode;
      retCode = movingAverage ( (struct movingAverage **) & _state.value .value .stateMA2, optInSlowD_Period, optInSlowD_MAType );
      if (retCode != RetCode.Success ) return retCode;
      return RetCode.Success ;
   }
   public RetCode stochState( struct TA_stoch_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outSlowK,
      double *outSlowD )
   {
      TA_RetCode retCode;
      double temp;
      unsigned int j,i,p;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .lowest = inLow;
         _state.value .highest = inHigh;
         _state.value .lowest_exp = _state.value .mem_size ;
         _state.value .highest_exp = _state.value .mem_size ;
      }
      if (-- _state.value .lowest_exp <= 0)
      {
         _state.value .lowest = inLow;
         _state.value .lowest_exp = _state.value .mem_size ;
         j = _state.value .mem_index-1;
         p = _state.value .mem_size ;
         for (i = 0; i < _state.value .mem_size ; i++)
         {
            temp = ( _state.value .memory+(--j) % _state.value .mem_size ).value .inLow ;
            p--;
            if (temp < _state.value .lowest)
            {
               _state.value .lowest = temp;
               _state.value .lowest_exp = p;
            }
         }
      } else
         if (inLow <= _state.value .lowest)
      {
         _state.value .lowest = inLow;
         _state.value .lowest_exp = _state.value .mem_size ;
      }
      if (-- _state.value .highest_exp <= 0)
      {
         _state.value .highest = inHigh;
         _state.value .highest_exp = _state.value .mem_size ;
         j = _state.value .mem_index-1;
         p = _state.value .mem_size ;
         for ( i = 0; i < _state.value .mem_size ; i++)
         {
            temp = ( _state.value .memory+(--j) % _state.value .mem_size ).value .inHigh ;
            p--;
            if (temp > _state.value .highest)
            {
               _state.value .highest = temp;
               _state.value .highest_exp = p;
            }
         }
      } else
         if (inHigh >= _state.value .highest)
      {
         _state.value .highest = inHigh;
         _state.value .highest_exp = _state.value .mem_size ;
      }
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      temp = ( _state.value .highest - _state.value .lowest)/100.0;
      if( temp != 0.0 )
         temp = (inClose- _state.value .lowest)/temp;
      else
         temp = 0.0;
      retCode = movingAverage ( (struct movingAverage *) _state.value .stateMA1, temp, &temp );
      if( retCode != RetCode.Success ) return retCode;
      outSlowK.value = temp;
      retCode = movingAverage ( (struct movingAverage *) _state.value .stateMA2, temp, &temp );
      if( retCode != RetCode.Success ) return retCode;
      outSlowD.value = temp;
      return RetCode.Success ;
   }
   public RetCode stochStateFree( struct TA_stoch_State** _state )
   {
      TA_RetCode retCode;
      retCode = movingAverage ( (struct movingAverage **) & _state.value .value .stateMA1 );
      if (retCode != RetCode.Success ) return retCode;
      retCode = movingAverage ( (struct movingAverage **) & _state.value .value .stateMA2 );
      if (retCode != RetCode.Success ) return retCode;
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode stochStateSave( struct TA_stoch_State* _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_STOCH_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInFastK_Period,sizeof( _state.value .optInFastK_Period),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInSlowK_Period,sizeof( _state.value .optInSlowK_Period),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInSlowK_MAType,sizeof( _state.value .optInSlowK_MAType),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInSlowD_Period,sizeof( _state.value .optInSlowD_Period),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInSlowD_MAType,sizeof( _state.value .optInSlowD_MAType),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .lowest,sizeof( _state.value .lowest),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .highest,sizeof( _state.value .highest),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .lowest_exp,sizeof( _state.value .lowest_exp),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .highest_exp,sizeof( _state.value .highest_exp),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_MA_StateSave ( (struct movingAverage *) _state.value .stateMA1, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_MA_StateSave ( (struct movingAverage *) _state.value .stateMA2, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode stochStateLoad( struct TA_stoch_State** _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct stoch ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_STOCH_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_STOCH_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInFastK_Period,sizeof( _state.value .value .optInFastK_Period),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInSlowK_Period,sizeof( _state.value .value .optInSlowK_Period),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInSlowK_MAType,sizeof( _state.value .value .optInSlowK_MAType),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInSlowD_Period,sizeof( _state.value .value .optInSlowD_Period),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInSlowD_MAType,sizeof( _state.value .value .optInSlowD_MAType),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .lowest,sizeof( _state.value .value .lowest),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .highest,sizeof( _state.value .value .highest),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .lowest_exp,sizeof( _state.value .value .lowest_exp),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .highest_exp,sizeof( _state.value .value .highest_exp),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_MA_StateLoad ( (struct movingAverage **) & _state.value .value .stateMA1, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_MA_StateLoad ( (struct movingAverage **) & _state.value .value .stateMA2, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode stoch( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      int optInFastK_Period,
      int optInSlowK_Period,
      MAType optInSlowK_MAType, int optInSlowD_Period,
      MAType optInSlowD_MAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outSlowK[],
      double outSlowD[] )
   {
      RetCode retCode;
      double lowest, highest, tmp, diff;
      double []tempBuffer ;
      int outIdx, lowestIdx, highestIdx;
      int lookbackTotal, lookbackK, lookbackKSlow, lookbackDSlow;
      int trailingIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInFastK_Period == ( Integer.MIN_VALUE ) )
         optInFastK_Period = 5;
      else if( ((int)optInFastK_Period < 1) || ((int)optInFastK_Period > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowK_Period == ( Integer.MIN_VALUE ) )
         optInSlowK_Period = 3;
      else if( ((int)optInSlowK_Period < 1) || ((int)optInSlowK_Period > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowD_Period == ( Integer.MIN_VALUE ) )
         optInSlowD_Period = 3;
      else if( ((int)optInSlowD_Period < 1) || ((int)optInSlowD_Period > 100000) )
         return RetCode.BadParam ;
      lookbackK = optInFastK_Period-1;
      lookbackKSlow = movingAverageLookback ( optInSlowK_Period, optInSlowK_MAType );
      lookbackDSlow = movingAverageLookback ( optInSlowD_Period, optInSlowD_MAType );
      lookbackTotal = lookbackK + lookbackDSlow + lookbackKSlow;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      trailingIdx = startIdx-lookbackTotal;
      today = trailingIdx+lookbackK;
      lowestIdx = highestIdx = -1;
      diff = highest = lowest = 0.0;
      tempBuffer = new double[endIdx-today+1] ;
      while( today <= endIdx )
      {
         tmp = inLow[today];
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inLow[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmp = inLow[i];
               if( tmp < lowest )
               {
                  lowestIdx = i;
                  lowest = tmp;
               }
            }
            diff = (highest - lowest)/100.0;
         }
         else if( tmp <= lowest )
         {
            lowestIdx = today;
            lowest = tmp;
            diff = (highest - lowest)/100.0;
         }
         tmp = inHigh[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inHigh[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmp = inHigh[i];
               if( tmp > highest )
               {
                  highestIdx = i;
                  highest = tmp;
               }
            }
            diff = (highest - lowest)/100.0;
         }
         else if( tmp >= highest )
         {
            highestIdx = today;
            highest = tmp;
            diff = (highest - lowest)/100.0;
         }
         if( diff != 0.0 )
            tempBuffer[outIdx++] = (inClose[today]-lowest)/diff;
         else
            tempBuffer[outIdx++] = 0.0;
         trailingIdx++;
         today++;
      }
      retCode = movingAverage ( 0, outIdx-1,
         tempBuffer, optInSlowK_Period,
         optInSlowK_MAType,
         outBegIdx, outNBElement, tempBuffer );
      if( (retCode != RetCode.Success ) || ((int) outNBElement.value == 0) )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      retCode = movingAverage ( 0, (int) outNBElement.value -1,
         tempBuffer, optInSlowD_Period,
         optInSlowD_MAType,
         outBegIdx, outNBElement, outSlowD );
      System.arraycopy(tempBuffer,lookbackDSlow,outSlowK,0,(int) outNBElement.value ) ;
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int stochFLookback( int optInFastK_Period,
      int optInFastD_Period,
      MAType optInFastD_MAType )
   {
      int retValue;
      if( (int)optInFastK_Period == ( Integer.MIN_VALUE ) )
         optInFastK_Period = 5;
      else if( ((int)optInFastK_Period < 1) || ((int)optInFastK_Period > 100000) )
         return -1;
      if( (int)optInFastD_Period == ( Integer.MIN_VALUE ) )
         optInFastD_Period = 3;
      else if( ((int)optInFastD_Period < 1) || ((int)optInFastD_Period > 100000) )
         return -1;
      retValue = (optInFastK_Period - 1);
      retValue += movingAverageLookback ( optInFastD_Period, optInFastD_MAType );
      return retValue;
   }
   public RetCode stochF( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      int optInFastK_Period,
      int optInFastD_Period,
      MAType optInFastD_MAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outFastK[],
      double outFastD[] )
   {
      RetCode retCode;
      double lowest, highest, tmp, diff;
      double []tempBuffer ;
      int outIdx, lowestIdx, highestIdx;
      int lookbackTotal, lookbackK, lookbackFastD;
      int trailingIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInFastK_Period == ( Integer.MIN_VALUE ) )
         optInFastK_Period = 5;
      else if( ((int)optInFastK_Period < 1) || ((int)optInFastK_Period > 100000) )
         return RetCode.BadParam ;
      if( (int)optInFastD_Period == ( Integer.MIN_VALUE ) )
         optInFastD_Period = 3;
      else if( ((int)optInFastD_Period < 1) || ((int)optInFastD_Period > 100000) )
         return RetCode.BadParam ;
      lookbackK = optInFastK_Period-1;
      lookbackFastD = movingAverageLookback ( optInFastD_Period, optInFastD_MAType );
      lookbackTotal = lookbackK + lookbackFastD;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      trailingIdx = startIdx-lookbackTotal;
      today = trailingIdx+lookbackK;
      lowestIdx = highestIdx = -1;
      diff = highest = lowest = 0.0;
      if( (outFastK == inHigh) ||
         (outFastK == inLow) ||
         (outFastK == inClose) )
      {
         tempBuffer = outFastK;
      }
      else if( (outFastD == inHigh) ||
         (outFastD == inLow) ||
         (outFastD == inClose) )
      {
         tempBuffer = outFastD;
      }
      else
      {
         tempBuffer = new double[endIdx-today+1] ;
      }
      while( today <= endIdx )
      {
         tmp = inLow[today];
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inLow[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmp = inLow[i];
               if( tmp < lowest )
               {
                  lowestIdx = i;
                  lowest = tmp;
               }
            }
            diff = (highest - lowest)/100.0;
         }
         else if( tmp <= lowest )
         {
            lowestIdx = today;
            lowest = tmp;
            diff = (highest - lowest)/100.0;
         }
         tmp = inHigh[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inHigh[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmp = inHigh[i];
               if( tmp > highest )
               {
                  highestIdx = i;
                  highest = tmp;
               }
            }
            diff = (highest - lowest)/100.0;
         }
         else if( tmp >= highest )
         {
            highestIdx = today;
            highest = tmp;
            diff = (highest - lowest)/100.0;
         }
         if( diff != 0.0 )
            tempBuffer[outIdx++] = (inClose[today]-lowest)/diff;
         else
            tempBuffer[outIdx++] = 0.0;
         trailingIdx++;
         today++;
      }
      retCode = movingAverage ( 0, outIdx-1,
         tempBuffer, optInFastD_Period,
         optInFastD_MAType,
         outBegIdx, outNBElement, outFastD );
      if( (retCode != RetCode.Success ) || ((int) outNBElement.value ) == 0 )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      System.arraycopy(tempBuffer,lookbackFastD,outFastK,0,(int) outNBElement.value ) ;
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode stochFStateInit( struct TA_stochF_State** _state,
      int optInFastK_Period,
      int optInFastD_Period,
      MAType optInFastD_MAType )
   {
      TA_RetCode retCode;
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInFastK_Period == ( Integer.MIN_VALUE ) )
         optInFastK_Period = 5;
      else if( ((int)optInFastK_Period < 1) || ((int)optInFastK_Period > 100000) )
         return RetCode.BadParam ;
      if( (int)optInFastD_Period == ( Integer.MIN_VALUE ) )
         optInFastD_Period = 3;
      else if( ((int)optInFastD_Period < 1) || ((int)optInFastD_Period > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct stochF ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInFastK_Period = optInFastK_Period;
      _state.value .value .optInFastD_Period = optInFastD_Period;
      _state.value .value .optInFastD_MAType = optInFastD_MAType;
      _state.value .value .mem_size = stochFLookback (optInFastK_Period, optInFastD_Period, optInFastD_MAType );
      _state.value .value .memory = NULL;
      _state.value .value .mem_size = (optInFastK_Period - 1);
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_STOCHF_Data));
      else _state.value .value .memory = NULL;
      retCode = movingAverage ( (struct movingAverage **) & _state.value .value .stateMA1, optInFastD_Period, optInFastD_MAType );
      if (retCode != RetCode.Success ) return retCode;
      return RetCode.Success ;
   }
   public RetCode stochFState( struct TA_stochF_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outFastK,
      double *outFastD )
   {
      TA_RetCode retCode;
      double temp;
      unsigned int j,i,p;
      if (!_state || !outFastK || !outFastD) return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .lowest = inLow;
         _state.value .highest = inHigh;
         _state.value .lowest_exp = _state.value .mem_size ;
         _state.value .highest_exp = _state.value .mem_size ;
      }
      if (-- _state.value .lowest_exp <= 0)
      {
         _state.value .lowest = inLow;
         _state.value .lowest_exp = _state.value .mem_size ;
         j = _state.value .mem_index-1;
         p = _state.value .mem_size ;
         for (i = 0; i < _state.value .mem_size ; i++)
         {
            temp = ( _state.value .memory+(--j) % _state.value .mem_size ).value .inLow ;
            p--;
            if (temp < _state.value .lowest)
            {
               _state.value .lowest = temp;
               _state.value .lowest_exp = p;
            }
         }
      } else
         if (inLow <= _state.value .lowest)
      {
         _state.value .lowest = inLow;
         _state.value .lowest_exp = _state.value .mem_size ;
      }
      if (-- _state.value .highest_exp <= 0)
      {
         _state.value .highest = inHigh;
         _state.value .highest_exp = _state.value .mem_size ;
         j = _state.value .mem_index-1;
         p = _state.value .mem_size ;
         for ( i = 0; i < _state.value .mem_size ; i++)
         {
            temp = ( _state.value .memory+(--j) % _state.value .mem_size ).value .inHigh ;
            p--;
            if (temp > _state.value .highest)
            {
               _state.value .highest = temp;
               _state.value .highest_exp = p;
            }
         }
      } else
         if (inHigh >= _state.value .highest)
      {
         _state.value .highest = inHigh;
         _state.value .highest_exp = _state.value .mem_size ;
      }
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      temp = ( _state.value .highest - _state.value .lowest)/100.0;
      if( temp != 0.0 )
         temp = (inClose- _state.value .lowest)/temp;
      else
         temp = 0.0;
      outFastK.value = temp;
      retCode = movingAverage ( (struct movingAverage *) _state.value .stateMA1, temp, &temp );
      if( retCode != RetCode.Success ) return retCode;
      outFastD.value = temp;
      return RetCode.Success ;
   }
   public RetCode stochFStateFree( struct TA_stochF_State** _state )
   {
      TA_RetCode retCode;
      retCode = movingAverage ( (struct movingAverage **) & _state.value .value .stateMA1 );
      if (retCode != RetCode.Success ) return retCode;
      return RetCode.Success ;
   }
   public RetCode stochFStateSave( struct TA_stochF_State* _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      retCode = TA_MA_StateSave ( (struct movingAverage *) _state.value .stateMA1, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode stochFStateLoad( struct TA_stochF_State** _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      retCode = TA_MA_StateLoad ( (struct movingAverage **) & _state.value .value .stateMA1, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode stochF( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      int optInFastK_Period,
      int optInFastD_Period,
      MAType optInFastD_MAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outFastK[],
      double outFastD[] )
   {
      RetCode retCode;
      double lowest, highest, tmp, diff;
      double []tempBuffer ;
      int outIdx, lowestIdx, highestIdx;
      int lookbackTotal, lookbackK, lookbackFastD;
      int trailingIdx, today, i;
      lookbackK = optInFastK_Period-1;
      lookbackFastD = movingAverageLookback ( optInFastD_Period, optInFastD_MAType );
      lookbackTotal = lookbackK + lookbackFastD;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      trailingIdx = startIdx-lookbackTotal;
      today = trailingIdx+lookbackK;
      lowestIdx = highestIdx = -1;
      diff = highest = lowest = 0.0;
      tempBuffer = new double[endIdx-today+1] ;
      while( today <= endIdx )
      {
         tmp = inLow[today];
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inLow[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmp = inLow[i];
               if( tmp < lowest )
               {
                  lowestIdx = i;
                  lowest = tmp;
               }
            }
            diff = (highest - lowest)/100.0;
         }
         else if( tmp <= lowest )
         {
            lowestIdx = today;
            lowest = tmp;
            diff = (highest - lowest)/100.0;
         }
         tmp = inHigh[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inHigh[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmp = inHigh[i];
               if( tmp > highest )
               {
                  highestIdx = i;
                  highest = tmp;
               }
            }
            diff = (highest - lowest)/100.0;
         }
         else if( tmp >= highest )
         {
            highestIdx = today;
            highest = tmp;
            diff = (highest - lowest)/100.0;
         }
         if( diff != 0.0 )
            tempBuffer[outIdx++] = (inClose[today]-lowest)/diff;
         else
            tempBuffer[outIdx++] = 0.0;
         trailingIdx++;
         today++;
      }
      retCode = movingAverage ( 0, outIdx-1,
         tempBuffer, optInFastD_Period,
         optInFastD_MAType,
         outBegIdx, outNBElement, outFastD );
      if( (retCode != RetCode.Success ) || ((int) outNBElement.value ) == 0 )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      System.arraycopy(tempBuffer,lookbackFastD,outFastK,0,(int) outNBElement.value ) ;
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int stochRsiLookback( int optInTimePeriod,
      int optInFastK_Period,
      int optInFastD_Period,
      MAType optInFastD_MAType )
   {
      int retValue;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      if( (int)optInFastK_Period == ( Integer.MIN_VALUE ) )
         optInFastK_Period = 5;
      else if( ((int)optInFastK_Period < 1) || ((int)optInFastK_Period > 100000) )
         return -1;
      if( (int)optInFastD_Period == ( Integer.MIN_VALUE ) )
         optInFastD_Period = 3;
      else if( ((int)optInFastD_Period < 1) || ((int)optInFastD_Period > 100000) )
         return -1;
      retValue = rsiLookback ( optInTimePeriod ) + stochFLookback ( optInFastK_Period, optInFastD_Period, optInFastD_MAType );
      return retValue;
   }
   public RetCode stochRsi( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      int optInFastK_Period,
      int optInFastD_Period,
      MAType optInFastD_MAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outFastK[],
      double outFastD[] )
   {
      double []tempRSIBuffer ;
      RetCode retCode;
      int lookbackTotal, lookbackSTOCHF, tempArraySize;
      MInteger outBegIdx1 = new MInteger() ;
      MInteger outBegIdx2 = new MInteger() ;
      MInteger outNbElement1 = new MInteger() ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInFastK_Period == ( Integer.MIN_VALUE ) )
         optInFastK_Period = 5;
      else if( ((int)optInFastK_Period < 1) || ((int)optInFastK_Period > 100000) )
         return RetCode.BadParam ;
      if( (int)optInFastD_Period == ( Integer.MIN_VALUE ) )
         optInFastD_Period = 3;
      else if( ((int)optInFastD_Period < 1) || ((int)optInFastD_Period > 100000) )
         return RetCode.BadParam ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      lookbackSTOCHF = stochFLookback ( optInFastK_Period, optInFastD_Period, optInFastD_MAType );
      lookbackTotal = rsiLookback ( optInTimePeriod ) + lookbackSTOCHF;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      tempArraySize = (endIdx - startIdx) + 1 + lookbackSTOCHF;
      tempRSIBuffer = new double[tempArraySize] ;
      retCode = rsi (startIdx-lookbackSTOCHF,
         endIdx,
         inReal,
         optInTimePeriod,
         outBegIdx1 ,
         outNbElement1 ,
         tempRSIBuffer);
      if( retCode != RetCode.Success || outNbElement1.value == 0 )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      retCode = stochF (0,
         tempArraySize-1,
         tempRSIBuffer,
         tempRSIBuffer,
         tempRSIBuffer,
         optInFastK_Period,
         optInFastD_Period,
         optInFastD_MAType,
         outBegIdx2 ,
         outNBElement,
         outFastK,
         outFastD);
      if( retCode != RetCode.Success || ((int) outNBElement.value ) == 0 )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      return RetCode.Success ;
   }
   public RetCode stochRsiStateInit( struct TA_stochRsi_State** _state,
      int optInTimePeriod,
      int optInFastK_Period,
      int optInFastD_Period,
      MAType optInFastD_MAType )
   {
      TA_RetCode retCode;
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInFastK_Period == ( Integer.MIN_VALUE ) )
         optInFastK_Period = 5;
      else if( ((int)optInFastK_Period < 1) || ((int)optInFastK_Period > 100000) )
         return RetCode.BadParam ;
      if( (int)optInFastD_Period == ( Integer.MIN_VALUE ) )
         optInFastD_Period = 3;
      else if( ((int)optInFastD_Period < 1) || ((int)optInFastD_Period > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct stochRsi ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .optInFastK_Period = optInFastK_Period;
      _state.value .value .optInFastD_Period = optInFastD_Period;
      _state.value .value .optInFastD_MAType = optInFastD_MAType;
      _state.value .value .mem_size = stochRsiLookback (optInTimePeriod, optInFastK_Period, optInFastD_Period, optInFastD_MAType );
      _state.value .value .memory = NULL;
      retCode = rsi ( (struct rsi **) & _state.value .value .stateRSI, optInTimePeriod );
      if (retCode != RetCode.Success ) return retCode;
      retCode = stochF ( (struct stochF **) & _state.value .value .stateSTOCHF, optInFastK_Period, optInFastD_Period, optInFastD_MAType );
      if (retCode != RetCode.Success ) return retCode;
      return RetCode.Success ;
   }
   public RetCode stochRsiState( struct TA_stochRsi_State* _state,
      double inReal,
      double *outFastK,
      double *outFastD )
   {
      TA_RetCode retCode;
      double tempReal;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      retCode = rsi ( (struct rsi *) _state.value .stateRSI, inReal, &tempReal );
      if (retCode != RetCode.Success ) return retCode;
      retCode = stochF ( (struct stochF *) _state.value .stateSTOCHF, tempReal, tempReal, tempReal, outFastK, outFastD );
      if (retCode != RetCode.Success ) return retCode;
      return RetCode.Success ;
   }
   public RetCode stochRsiStateFree( struct TA_stochRsi_State** _state )
   {
      TA_RetCode retCode;
      retCode = rsi ( (struct rsi **) & _state.value .value .stateRSI );
      if (retCode != RetCode.Success ) return retCode;
      retCode = stochF ( (struct stochF **) & _state.value .value .stateSTOCHF );
      if (retCode != RetCode.Success ) return retCode;
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode stochRsiStateSave( struct TA_stochRsi_State* _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_STOCHRSI_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInFastK_Period,sizeof( _state.value .optInFastK_Period),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInFastD_Period,sizeof( _state.value .optInFastD_Period),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInFastD_MAType,sizeof( _state.value .optInFastD_MAType),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_RSI_StateSave ( (struct rsi *) _state.value .stateRSI, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_STOCHF_StateSave ( (struct stochF *) _state.value .stateSTOCHF, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode stochRsiStateLoad( struct TA_stochRsi_State** _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct stochRsi ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_STOCHRSI_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_STOCHRSI_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInFastK_Period,sizeof( _state.value .value .optInFastK_Period),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInFastD_Period,sizeof( _state.value .value .optInFastD_Period),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInFastD_MAType,sizeof( _state.value .value .optInFastD_MAType),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_RSI_StateLoad ( (struct rsi **) & _state.value .value .stateRSI, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_STOCHF_StateLoad ( (struct stochF **) & _state.value .value .stateSTOCHF, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode stochRsi( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      int optInFastK_Period,
      int optInFastD_Period,
      MAType optInFastD_MAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outFastK[],
      double outFastD[] )
   {
      double []tempRSIBuffer ;
      RetCode retCode;
      int lookbackTotal, lookbackSTOCHF, tempArraySize;
      MInteger outBegIdx1 = new MInteger() ;
      MInteger outBegIdx2 = new MInteger() ;
      MInteger outNbElement1 = new MInteger() ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInFastK_Period == ( Integer.MIN_VALUE ) )
         optInFastK_Period = 5;
      else if( ((int)optInFastK_Period < 1) || ((int)optInFastK_Period > 100000) )
         return RetCode.BadParam ;
      if( (int)optInFastD_Period == ( Integer.MIN_VALUE ) )
         optInFastD_Period = 3;
      else if( ((int)optInFastD_Period < 1) || ((int)optInFastD_Period > 100000) )
         return RetCode.BadParam ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      lookbackSTOCHF = stochFLookback ( optInFastK_Period, optInFastD_Period, optInFastD_MAType );
      lookbackTotal = rsiLookback ( optInTimePeriod ) + lookbackSTOCHF;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      tempArraySize = (endIdx - startIdx) + 1 + lookbackSTOCHF;
      tempRSIBuffer = new double[tempArraySize] ;
      retCode = rsi (startIdx-lookbackSTOCHF,
         endIdx,
         inReal,
         optInTimePeriod,
         outBegIdx1 ,
         outNbElement1 ,
         tempRSIBuffer);
      if( retCode != RetCode.Success || outNbElement1.value == 0 )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      retCode = stochF (0,
         tempArraySize-1,
         tempRSIBuffer,
         tempRSIBuffer,
         tempRSIBuffer,
         optInFastK_Period,
         optInFastD_Period,
         optInFastD_MAType,
         outBegIdx2 ,
         outNBElement,
         outFastK,
         outFastD);
      if( retCode != RetCode.Success || ((int) outNBElement.value ) == 0 )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      return RetCode.Success ;
   }
   /* Generated */
   public int subLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode sub( int startIdx,
      int endIdx,
      double inReal0[],
      double inReal1[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = inReal0[i]-inReal1[i];
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode subStateInit( struct TA_sub_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct sub ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = subLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_SUB_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode subState( struct TA_sub_State* _state,
      double inReal0,
      double inReal1,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal0 = inReal0 ;
         ( _state.value .memory+_cur_idx).value .inReal1 = inReal1 ;
         return RetCode.NeedMoreData ; }
      outReal.value = inReal0-inReal1;
      return RetCode.Success ;
   }
   public RetCode subStateFree( struct TA_sub_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode subStateSave( struct TA_sub_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_SUB_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode subStateLoad( struct TA_sub_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct sub ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_SUB_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_SUB_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode sub( int startIdx,
      int endIdx,
      float inReal0[],
      float inReal1[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = inReal0[i]-inReal1[i];
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int sumLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod-1;
   }
   public RetCode sum( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double periodTotal, tempReal;
      int i, outIdx, trailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = (optInTimePeriod-1);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      periodTotal = 0;
      trailingIdx = startIdx-lookbackTotal;
      i=trailingIdx;
      if( optInTimePeriod > 1 )
      {
         while( i < startIdx )
            periodTotal += inReal[i++];
      }
      outIdx = 0;
      do
      {
         periodTotal += inReal[i++];
         tempReal = periodTotal;
         periodTotal -= inReal[trailingIdx++];
         outReal[outIdx++] = tempReal;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode sumStateInit( struct TA_sum_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct sum ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = sumLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_SUM_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode sumState( struct TA_sum_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
         _state->tempSum = 0;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
      {
         _state->tempSum += inReal;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         outReal.value = 0;
         return RetCode.NeedMoreData ;
      } else {
         _state->tempSum -= ( _state.value .memory+_cur_idx).value .inReal ;
         _state->tempSum += inReal;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         outReal.value = inReal;
         return RetCode.Success ;
      }
   }
   public RetCode sumStateFree( struct TA_sum_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode sumStateSave( struct TA_sum_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_SUM_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .tempSum,sizeof( _state.value .tempSum),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode sumStateLoad( struct TA_sum_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct sum ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_SUM_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_SUM_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .tempSum,sizeof( _state.value .value .tempSum),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode sum( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double periodTotal, tempReal;
      int i, outIdx, trailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = (optInTimePeriod-1);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      periodTotal = 0;
      trailingIdx = startIdx-lookbackTotal;
      i=trailingIdx;
      if( optInTimePeriod > 1 )
      {
         while( i < startIdx )
            periodTotal += inReal[i++];
      }
      outIdx = 0;
      do
      {
         periodTotal += inReal[i++];
         tempReal = periodTotal;
         periodTotal -= inReal[trailingIdx++];
         outReal[outIdx++] = tempReal;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int t3Lookback( int optInTimePeriod,
      double optInVFactor )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      if( optInVFactor == (-4e+37) )
         optInVFactor = 7.000000e-1;
      else if( (optInVFactor < 0.000000e+0) || (optInVFactor > 1.000000e+0) )
         return -1;
      return 6 * (optInTimePeriod-1) + (this.unstablePeriod[FuncUnstId.T3.ordinal()]) ;
   }
   public RetCode t3( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      double optInVFactor,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, lookbackTotal;
      int today, i;
      double k, one_minus_k;
      double e1, e2, e3, e4, e5, e6;
      double c1, c2, c3, c4;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInVFactor == (-4e+37) )
         optInVFactor = 7.000000e-1;
      else if( (optInVFactor < 0.000000e+0) || (optInVFactor > 1.000000e+0) )
         return RetCode.BadParam ;
      lookbackTotal = 6 * (optInTimePeriod - 1) + (this.unstablePeriod[FuncUnstId.T3.ordinal()]) ;
      if( startIdx <= lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outNBElement.value = 0 ;
         outBegIdx.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      today = startIdx - lookbackTotal;
      k = 2.0/(optInTimePeriod+1.0);
      one_minus_k = 1.0-k;
      tempReal = inReal[today++];
      for( i=optInTimePeriod-1; i > 0 ; i-- )
         tempReal += inReal[today++];
      e1 = tempReal / optInTimePeriod;
      tempReal = e1;
      for( i=optInTimePeriod-1; i > 0 ; i-- )
      {
         e1 = (k*inReal[today++])+(one_minus_k*e1);
         tempReal += e1;
      }
      e2 = tempReal / optInTimePeriod;
      tempReal = e2;
      for( i=optInTimePeriod-1; i > 0 ; i-- )
      {
         e1 = (k*inReal[today++])+(one_minus_k*e1);
         e2 = (k*e1)+(one_minus_k*e2);
         tempReal += e2;
      }
      e3 = tempReal / optInTimePeriod;
      tempReal = e3;
      for( i=optInTimePeriod-1; i > 0 ; i-- )
      {
         e1 = (k*inReal[today++])+(one_minus_k*e1);
         e2 = (k*e1)+(one_minus_k*e2);
         e3 = (k*e2)+(one_minus_k*e3);
         tempReal += e3;
      }
      e4 = tempReal / optInTimePeriod;
      tempReal = e4;
      for( i=optInTimePeriod-1; i > 0 ; i-- )
      {
         e1 = (k*inReal[today++])+(one_minus_k*e1);
         e2 = (k*e1)+(one_minus_k*e2);
         e3 = (k*e2)+(one_minus_k*e3);
         e4 = (k*e3)+(one_minus_k*e4);
         tempReal += e4;
      }
      e5 = tempReal / optInTimePeriod;
      tempReal = e5;
      for( i=optInTimePeriod-1; i > 0 ; i-- )
      {
         e1 = (k*inReal[today++])+(one_minus_k*e1);
         e2 = (k*e1)+(one_minus_k*e2);
         e3 = (k*e2)+(one_minus_k*e3);
         e4 = (k*e3)+(one_minus_k*e4);
         e5 = (k*e4)+(one_minus_k*e5);
         tempReal += e5;
      }
      e6 = tempReal / optInTimePeriod;
      while( today <= startIdx )
      {
         e1 = (k*inReal[today++])+(one_minus_k*e1);
         e2 = (k*e1)+(one_minus_k*e2);
         e3 = (k*e2)+(one_minus_k*e3);
         e4 = (k*e3)+(one_minus_k*e4);
         e5 = (k*e4)+(one_minus_k*e5);
         e6 = (k*e5)+(one_minus_k*e6);
      }
      tempReal = optInVFactor * optInVFactor;
      c1 = -(tempReal * optInVFactor);
      c2 = 3.0 * (tempReal - c1);
      c3 = -6.0 * tempReal - 3.0 * (optInVFactor-c1);
      c4 = 1.0 + 3.0 * optInVFactor - c1 + 3.0 * tempReal;
      outIdx = 0;
      outReal[outIdx++] = c1*e6+c2*e5+c3*e4+c4*e3;
      while( today <= endIdx )
      {
         e1 = (k*inReal[today++])+(one_minus_k*e1);
         e2 = (k*e1)+(one_minus_k*e2);
         e3 = (k*e2)+(one_minus_k*e3);
         e4 = (k*e3)+(one_minus_k*e4);
         e5 = (k*e4)+(one_minus_k*e5);
         e6 = (k*e5)+(one_minus_k*e6);
         outReal[outIdx++] = c1*e6+c2*e5+c3*e4+c4*e3;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode t3StateInit( struct TA_t3_State** _state,
      int optInTimePeriod,
      double optInVFactor )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInVFactor == (-4e+37) )
         optInVFactor = 7.000000e-1;
      else if( (optInVFactor < 0.000000e+0) || (optInVFactor > 1.000000e+0) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct t3 ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .optInVFactor = optInVFactor;
      _state.value .value .mem_size = t3Lookback (optInTimePeriod, optInVFactor );
      _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode t3State( struct TA_t3_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      _cur_idx = _state.value .mem_index -1;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .k = 2.0/( _state.value .optInTimePeriod+1.0);
         _state.value .one_minus_k = 1.0 - _state.value .k;
         _state.value .tempReal = 0.;
         _state.value .firstOutput = 0;
         double t = _state.value .optInVFactor * _state.value .optInVFactor;
         _state.value .c1 = -(t * _state.value .optInVFactor);
         _state.value .c2 = 3.0 * (t - _state.value .c1);
         _state.value .c3 = -6.0 * t - 3.0 * ( _state.value .optInVFactor- _state.value .c1);
         _state.value .c4 = 1.0 + 3.0 * _state.value .optInVFactor - _state.value .c1 + 3.0 * t;
      }
      if ((int)_cur_idx < _state.value .optInTimePeriod)
      {
         _state.value .tempReal += inReal;
         if ((int)_cur_idx == _state.value .optInTimePeriod-1)
         {
            _state.value .e1 = _state.value .tempReal / _state.value .optInTimePeriod;
            _state.value .tempReal = _state.value .e1;
         }
         return RetCode.NeedMoreData ;
      } else
         if ((int)_cur_idx < 2* _state.value .optInTimePeriod-1)
      {
         _state.value .e1 = ( _state.value .k*inReal)+( _state.value .one_minus_k* _state.value .e1);
         _state.value .tempReal += _state.value .e1;
         if ((int)_cur_idx == 2* _state.value .optInTimePeriod-2)
         {
            _state.value .e2 = _state.value .tempReal / _state.value .optInTimePeriod;
            _state.value .tempReal = _state.value .e2;
         }
         return RetCode.NeedMoreData ;
      } else
         if ((int)_cur_idx < 3* _state.value .optInTimePeriod-2)
      {
         _state.value .e1 = ( _state.value .k*inReal)+( _state.value .one_minus_k* _state.value .e1);
         _state.value .e2 = ( _state.value .k* _state.value .e1)+( _state.value .one_minus_k* _state.value .e2);
         _state.value .tempReal += _state.value .e2;
         if ((int)_cur_idx == 3* _state.value .optInTimePeriod-3)
         {
            _state.value .e3 = _state.value .tempReal / _state.value .optInTimePeriod;
            _state.value .tempReal = _state.value .e3;
         }
         return RetCode.NeedMoreData ;
      } else
         if ((int)_cur_idx < 4* _state.value .optInTimePeriod-3)
      {
         _state.value .e1 = ( _state.value .k*inReal)+( _state.value .one_minus_k* _state.value .e1);
         _state.value .e2 = ( _state.value .k* _state.value .e1)+( _state.value .one_minus_k* _state.value .e2);
         _state.value .e3 = ( _state.value .k* _state.value .e2)+( _state.value .one_minus_k* _state.value .e3);
         _state.value .tempReal += _state.value .e3;
         if ((int)_cur_idx == 4* _state.value .optInTimePeriod-4)
         {
            _state.value .e4 = _state.value .tempReal / _state.value .optInTimePeriod;
            _state.value .tempReal = _state.value .e4;
         }
         return RetCode.NeedMoreData ;
      } else
         if ((int)_cur_idx < 5* _state.value .optInTimePeriod-4)
      {
         _state.value .e1 = ( _state.value .k*inReal)+( _state.value .one_minus_k* _state.value .e1);
         _state.value .e2 = ( _state.value .k* _state.value .e1)+( _state.value .one_minus_k* _state.value .e2);
         _state.value .e3 = ( _state.value .k* _state.value .e2)+( _state.value .one_minus_k* _state.value .e3);
         _state.value .e4 = ( _state.value .k* _state.value .e3)+( _state.value .one_minus_k* _state.value .e4);
         _state.value .tempReal += _state.value .e4;
         if ((int)_cur_idx == 5* _state.value .optInTimePeriod-5)
         {
            _state.value .e5 = _state.value .tempReal / _state.value .optInTimePeriod;
            _state.value .tempReal = _state.value .e5;
         }
         return RetCode.NeedMoreData ;
      } else
         if ((int)_cur_idx < 6* _state.value .optInTimePeriod-5)
      {
         _state.value .e1 = ( _state.value .k*inReal)+( _state.value .one_minus_k* _state.value .e1);
         _state.value .e2 = ( _state.value .k* _state.value .e1)+( _state.value .one_minus_k* _state.value .e2);
         _state.value .e3 = ( _state.value .k* _state.value .e2)+( _state.value .one_minus_k* _state.value .e3);
         _state.value .e4 = ( _state.value .k* _state.value .e3)+( _state.value .one_minus_k* _state.value .e4);
         _state.value .e5 = ( _state.value .k* _state.value .e4)+( _state.value .one_minus_k* _state.value .e5);
         _state.value .tempReal += _state.value .e5;
         if ((int)_cur_idx == 6* _state.value .optInTimePeriod-6)
         {
            _state.value .e6 = _state.value .tempReal / _state.value .optInTimePeriod;
            _state.value .tempReal = _state.value .e6;
         } else
            return RetCode.NeedMoreData ;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
      {
         _state.value .e1 = ( _state.value .k*inReal)+( _state.value .one_minus_k* _state.value .e1);
         _state.value .e2 = ( _state.value .k* _state.value .e1)+( _state.value .one_minus_k* _state.value .e2);
         _state.value .e3 = ( _state.value .k* _state.value .e2)+( _state.value .one_minus_k* _state.value .e3);
         _state.value .e4 = ( _state.value .k* _state.value .e3)+( _state.value .one_minus_k* _state.value .e4);
         _state.value .e5 = ( _state.value .k* _state.value .e4)+( _state.value .one_minus_k* _state.value .e5);
         _state.value .e6 = ( _state.value .k* _state.value .e5)+( _state.value .one_minus_k* _state.value .e6);
         return RetCode.NeedMoreData ;
      } else
         if ( _state.value .firstOutput == 0)
      {
         _state.value .firstOutput = 1;
         outReal.value = _state.value .c1* _state.value .e6+ _state.value .c2* _state.value .e5+ _state.value .c3* _state.value .e4+ _state.value .c4* _state.value .e3;
         return RetCode.Success ;
      }
      _state.value .e1 = ( _state.value .k*inReal)+( _state.value .one_minus_k* _state.value .e1);
      _state.value .e2 = ( _state.value .k* _state.value .e1)+( _state.value .one_minus_k* _state.value .e2);
      _state.value .e3 = ( _state.value .k* _state.value .e2)+( _state.value .one_minus_k* _state.value .e3);
      _state.value .e4 = ( _state.value .k* _state.value .e3)+( _state.value .one_minus_k* _state.value .e4);
      _state.value .e5 = ( _state.value .k* _state.value .e4)+( _state.value .one_minus_k* _state.value .e5);
      _state.value .e6 = ( _state.value .k* _state.value .e5)+( _state.value .one_minus_k* _state.value .e6);
      outReal.value = _state.value .c1* _state.value .e6+ _state.value .c2* _state.value .e5+ _state.value .c3* _state.value .e4+ _state.value .c4* _state.value .e3;
      return RetCode.Success ;
   }
   public RetCode t3StateFree( struct TA_t3_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode t3StateSave( struct TA_t3_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_T3_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInVFactor,sizeof( _state.value .optInVFactor),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .k,sizeof( _state.value .k),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .one_minus_k,sizeof( _state.value .one_minus_k),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .e1,sizeof( _state.value .e1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .e2,sizeof( _state.value .e2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .e3,sizeof( _state.value .e3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .e4,sizeof( _state.value .e4),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .e5,sizeof( _state.value .e5),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .e6,sizeof( _state.value .e6),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .c1,sizeof( _state.value .c1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .c2,sizeof( _state.value .c2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .c3,sizeof( _state.value .c3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .c4,sizeof( _state.value .c4),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .tempReal,sizeof( _state.value .tempReal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .firstOutput,sizeof( _state.value .firstOutput),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode t3StateLoad( struct TA_t3_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct t3 ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_T3_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_T3_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInVFactor,sizeof( _state.value .value .optInVFactor),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .k,sizeof( _state.value .value .k),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .one_minus_k,sizeof( _state.value .value .one_minus_k),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .e1,sizeof( _state.value .value .e1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .e2,sizeof( _state.value .value .e2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .e3,sizeof( _state.value .value .e3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .e4,sizeof( _state.value .value .e4),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .e5,sizeof( _state.value .value .e5),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .e6,sizeof( _state.value .value .e6),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .c1,sizeof( _state.value .value .c1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .c2,sizeof( _state.value .value .c2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .c3,sizeof( _state.value .value .c3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .c4,sizeof( _state.value .value .c4),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .tempReal,sizeof( _state.value .value .tempReal),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .firstOutput,sizeof( _state.value .value .firstOutput),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode t3( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      double optInVFactor,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, lookbackTotal;
      int today, i;
      double k, one_minus_k;
      double e1, e2, e3, e4, e5, e6;
      double c1, c2, c3, c4;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInVFactor == (-4e+37) )
         optInVFactor = 7.000000e-1;
      else if( (optInVFactor < 0.000000e+0) || (optInVFactor > 1.000000e+0) )
         return RetCode.BadParam ;
      lookbackTotal = 6 * (optInTimePeriod - 1) + (this.unstablePeriod[FuncUnstId.T3.ordinal()]) ;
      if( startIdx <= lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outNBElement.value = 0 ;
         outBegIdx.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      today = startIdx - lookbackTotal;
      k = 2.0/(optInTimePeriod+1.0);
      one_minus_k = 1.0-k;
      tempReal = inReal[today++];
      for( i=optInTimePeriod-1; i > 0 ; i-- )
         tempReal += inReal[today++];
      e1 = tempReal / optInTimePeriod;
      tempReal = e1;
      for( i=optInTimePeriod-1; i > 0 ; i-- )
      {
         e1 = (k*inReal[today++])+(one_minus_k*e1);
         tempReal += e1;
      }
      e2 = tempReal / optInTimePeriod;
      tempReal = e2;
      for( i=optInTimePeriod-1; i > 0 ; i-- )
      {
         e1 = (k*inReal[today++])+(one_minus_k*e1);
         e2 = (k*e1)+(one_minus_k*e2);
         tempReal += e2;
      }
      e3 = tempReal / optInTimePeriod;
      tempReal = e3;
      for( i=optInTimePeriod-1; i > 0 ; i-- )
      {
         e1 = (k*inReal[today++])+(one_minus_k*e1);
         e2 = (k*e1)+(one_minus_k*e2);
         e3 = (k*e2)+(one_minus_k*e3);
         tempReal += e3;
      }
      e4 = tempReal / optInTimePeriod;
      tempReal = e4;
      for( i=optInTimePeriod-1; i > 0 ; i-- )
      {
         e1 = (k*inReal[today++])+(one_minus_k*e1);
         e2 = (k*e1)+(one_minus_k*e2);
         e3 = (k*e2)+(one_minus_k*e3);
         e4 = (k*e3)+(one_minus_k*e4);
         tempReal += e4;
      }
      e5 = tempReal / optInTimePeriod;
      tempReal = e5;
      for( i=optInTimePeriod-1; i > 0 ; i-- )
      {
         e1 = (k*inReal[today++])+(one_minus_k*e1);
         e2 = (k*e1)+(one_minus_k*e2);
         e3 = (k*e2)+(one_minus_k*e3);
         e4 = (k*e3)+(one_minus_k*e4);
         e5 = (k*e4)+(one_minus_k*e5);
         tempReal += e5;
      }
      e6 = tempReal / optInTimePeriod;
      while( today <= startIdx )
      {
         e1 = (k*inReal[today++])+(one_minus_k*e1);
         e2 = (k*e1)+(one_minus_k*e2);
         e3 = (k*e2)+(one_minus_k*e3);
         e4 = (k*e3)+(one_minus_k*e4);
         e5 = (k*e4)+(one_minus_k*e5);
         e6 = (k*e5)+(one_minus_k*e6);
      }
      tempReal = optInVFactor * optInVFactor;
      c1 = -(tempReal * optInVFactor);
      c2 = 3.0 * (tempReal - c1);
      c3 = -6.0 * tempReal - 3.0 * (optInVFactor-c1);
      c4 = 1.0 + 3.0 * optInVFactor - c1 + 3.0 * tempReal;
      outIdx = 0;
      outReal[outIdx++] = c1*e6+c2*e5+c3*e4+c4*e3;
      while( today <= endIdx )
      {
         e1 = (k*inReal[today++])+(one_minus_k*e1);
         e2 = (k*e1)+(one_minus_k*e2);
         e3 = (k*e2)+(one_minus_k*e3);
         e4 = (k*e3)+(one_minus_k*e4);
         e5 = (k*e4)+(one_minus_k*e5);
         e6 = (k*e5)+(one_minus_k*e6);
         outReal[outIdx++] = c1*e6+c2*e5+c3*e4+c4*e3;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int tanLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode tan( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.tan (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode tanStateInit( struct TA_tan_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct tan ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = tanLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_TAN_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode tanState( struct TA_tan_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.tan (inReal);
      return RetCode.Success ;
   }
   public RetCode tanStateFree( struct TA_tan_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode tanStateSave( struct TA_tan_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_TAN_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode tanStateLoad( struct TA_tan_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct tan ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_TAN_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_TAN_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode tan( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.tan (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int tanhLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode tanh( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.tanh (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode tanhStateInit( struct TA_tanh_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct tanh ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = tanhLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_TANH_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode tanhState( struct TA_tanh_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.tanh (inReal);
      return RetCode.Success ;
   }
   public RetCode tanhStateFree( struct TA_tanh_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode tanhStateSave( struct TA_tanh_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_TANH_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode tanhStateLoad( struct TA_tanh_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct tanh ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_TANH_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_TANH_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode tanh( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.tanh (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int temaLookback( int optInTimePeriod )
   {
      int retValue;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      retValue = emaLookback ( optInTimePeriod );
      return retValue * 3;
   }
   public RetCode tema( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double []firstEMA ;
      double []secondEMA ;
      double k;
      MInteger firstEMABegIdx = new MInteger() ;
      MInteger firstEMANbElement = new MInteger() ;
      MInteger secondEMABegIdx = new MInteger() ;
      MInteger secondEMANbElement = new MInteger() ;
      MInteger thirdEMABegIdx = new MInteger() ;
      MInteger thirdEMANbElement = new MInteger() ;
      int tempInt, outIdx, lookbackTotal, lookbackEMA;
      int firstEMAIdx, secondEMAIdx;
      RetCode retCode;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      outNBElement.value = 0 ;
      outBegIdx.value = 0 ;
      lookbackEMA = emaLookback ( optInTimePeriod );
      lookbackTotal = lookbackEMA * 3;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
         return RetCode.Success ;
      tempInt = lookbackTotal+(endIdx-startIdx)+1;
      firstEMA = new double[tempInt] ;
      k = ((double)2.0 / ((double)(optInTimePeriod + 1))) ;
      retCode = TA_INT_EMA ( startIdx-(lookbackEMA*2), endIdx, inReal,
         optInTimePeriod, k,
         firstEMABegIdx , firstEMANbElement ,
         firstEMA );
      if( (retCode != RetCode.Success ) || ( firstEMANbElement.value == 0) )
      {
         return retCode;
      }
      secondEMA = new double[firstEMANbElement.value ] ;
      retCode = TA_INT_EMA ( 0, firstEMANbElement.value -1, firstEMA,
         optInTimePeriod, k,
         secondEMABegIdx , secondEMANbElement ,
         secondEMA );
      if( (retCode != RetCode.Success ) || ( secondEMANbElement.value == 0) )
      {
         return retCode;
      }
      retCode = TA_INT_EMA ( 0, secondEMANbElement.value -1, secondEMA,
         optInTimePeriod, k,
         thirdEMABegIdx , thirdEMANbElement ,
         outReal );
      if( (retCode != RetCode.Success ) || ( thirdEMANbElement.value == 0) )
      {
         return retCode;
      }
      firstEMAIdx = thirdEMABegIdx.value + secondEMABegIdx.value ;
      secondEMAIdx = thirdEMABegIdx.value ;
      outBegIdx.value = firstEMAIdx + firstEMABegIdx.value ;
      outIdx = 0;
      while( outIdx < thirdEMANbElement.value )
      {
         outReal[outIdx] += (3.0*firstEMA[firstEMAIdx++]) - (3.0*secondEMA[secondEMAIdx++]);
         outIdx++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode temaStateInit( struct TA_tema_State** _state,
      int optInTimePeriod )
   {
      int res;
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct tema ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = temaLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      res = ema ((struct ema **)& _state.value .value .state_EMA, optInTimePeriod);
      if (res == RetCode.Success )
      {
         res = ema ((struct ema **)& _state.value .value .state_EMA2, optInTimePeriod);
      }
      if (res == RetCode.Success )
      {
         res = ema ((struct ema **)& _state.value .value .state_EMA3, optInTimePeriod);
      }
      return res;
   }
   public RetCode temaState( struct TA_tema_State* _state,
      double inReal,
      double *outReal )
   {
      double ema, ema2, ema3;
      int retCode;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      retCode = ema ( _state.value .state_EMA, inReal, &ema );
      if( retCode != RetCode.Success )
         return retCode;
      retCode = ema ( _state.value .state_EMA2, ema, &ema2 );
      if( retCode != RetCode.Success )
         return retCode;
      retCode = ema ( _state.value .state_EMA3, ema2, &ema3 );
      if( retCode != RetCode.Success )
         return retCode;
      outReal.value = (3.0*ema) - (3.0*ema2) + ema3;
      return RetCode.Success ;
   }
   public RetCode temaStateFree( struct TA_tema_State** _state )
   {
      int res = ema ((struct ema **)& _state.value .value .state_EMA);
      if (res == RetCode.Success )
      {
         res = ema ((struct ema **)& _state.value .value .state_EMA2);
      }
      if (res == RetCode.Success )
      {
         res = ema ((struct ema **)& _state.value .value .state_EMA3);
      }
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return res;
   }
   public RetCode temaStateSave( struct TA_tema_State* _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_TEMA_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_EMA_StateSave ( (struct ema *) _state.value .state_EMA, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_EMA_StateSave ( (struct ema *) _state.value .state_EMA2, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_EMA_StateSave ( (struct ema *) _state.value .state_EMA3, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode temaStateLoad( struct TA_tema_State** _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct tema ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_TEMA_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_TEMA_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_EMA_StateLoad ( (struct ema **) & _state.value .value .state_EMA, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_EMA_StateLoad ( (struct ema **) & _state.value .value .state_EMA2, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_EMA_StateLoad ( (struct ema **) & _state.value .value .state_EMA3, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode tema( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double []firstEMA ;
      double []secondEMA ;
      double k;
      MInteger firstEMABegIdx = new MInteger() ;
      MInteger firstEMANbElement = new MInteger() ;
      MInteger secondEMABegIdx = new MInteger() ;
      MInteger secondEMANbElement = new MInteger() ;
      MInteger thirdEMABegIdx = new MInteger() ;
      MInteger thirdEMANbElement = new MInteger() ;
      int tempInt, outIdx, lookbackTotal, lookbackEMA;
      int firstEMAIdx, secondEMAIdx;
      RetCode retCode;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      outNBElement.value = 0 ;
      outBegIdx.value = 0 ;
      lookbackEMA = emaLookback ( optInTimePeriod );
      lookbackTotal = lookbackEMA * 3;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
         return RetCode.Success ;
      tempInt = lookbackTotal+(endIdx-startIdx)+1;
      firstEMA = new double[tempInt] ;
      k = ((double)2.0 / ((double)(optInTimePeriod + 1))) ;
      retCode = TA_INT_EMA ( startIdx-(lookbackEMA*2), endIdx, inReal,
         optInTimePeriod, k,
         firstEMABegIdx , firstEMANbElement ,
         firstEMA );
      if( (retCode != RetCode.Success ) || ( firstEMANbElement.value == 0) )
      {
         return retCode;
      }
      secondEMA = new double[firstEMANbElement.value ] ;
      retCode = TA_INT_EMA ( 0, firstEMANbElement.value -1, firstEMA,
         optInTimePeriod, k,
         secondEMABegIdx , secondEMANbElement ,
         secondEMA );
      if( (retCode != RetCode.Success ) || ( secondEMANbElement.value == 0) )
      {
         return retCode;
      }
      retCode = TA_INT_EMA ( 0, secondEMANbElement.value -1, secondEMA,
         optInTimePeriod, k,
         thirdEMABegIdx , thirdEMANbElement ,
         outReal );
      if( (retCode != RetCode.Success ) || ( thirdEMANbElement.value == 0) )
      {
         return retCode;
      }
      firstEMAIdx = thirdEMABegIdx.value + secondEMABegIdx.value ;
      secondEMAIdx = thirdEMABegIdx.value ;
      outBegIdx.value = firstEMAIdx + firstEMABegIdx.value ;
      outIdx = 0;
      while( outIdx < thirdEMANbElement.value )
      {
         outReal[outIdx] += (3.0*firstEMA[firstEMAIdx++]) - (3.0*secondEMA[secondEMAIdx++]);
         outIdx++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int trueRangeLookback( )
   {
      return 1;
   }
   public RetCode trueRange( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, outIdx;
      double val2, val3, greatest;
      double tempCY, tempLT, tempHT;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( startIdx < 1 )
         startIdx = 1;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      while( today <= endIdx )
      {
         tempLT = inLow[today];
         tempHT = inHigh[today];
         tempCY = inClose[today-1];
         greatest = tempHT - tempLT;
         val2 = Math.abs ( tempCY - tempHT );
         if( val2 > greatest )
            greatest = val2;
         val3 = Math.abs ( tempCY - tempLT );
         if( val3 > greatest )
            greatest = val3;
         outReal[outIdx++] = greatest;
         today++;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode trueRangeStateInit( struct TA_trueRange_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct trueRange ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = trueRangeLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_TRANGE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode trueRangeState( struct TA_trueRange_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      double val2, val3, greatest, tempCY;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      tempCY = ( _state.value .memory+_cur_idx).value .inClose ;
      greatest = inHigh - inLow;
      val2 = Math.abs ( tempCY - inHigh );
      if( val2 > greatest )
         greatest = val2;
      val3 = Math.abs ( tempCY - inLow );
      if( val3 > greatest )
         greatest = val3;
      outReal.value = greatest;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      return RetCode.Success ;
   }
   public RetCode trueRangeStateFree( struct TA_trueRange_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode trueRangeStateSave( struct TA_trueRange_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_TRANGE_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode trueRangeStateLoad( struct TA_trueRange_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct trueRange ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_TRANGE_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_TRANGE_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode trueRange( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, outIdx;
      double val2, val3, greatest;
      double tempCY, tempLT, tempHT;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( startIdx < 1 )
         startIdx = 1;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      while( today <= endIdx )
      {
         tempLT = inLow[today];
         tempHT = inHigh[today];
         tempCY = inClose[today-1];
         greatest = tempHT - tempLT;
         val2 = Math.abs ( tempCY - tempHT );
         if( val2 > greatest )
            greatest = val2;
         val3 = Math.abs ( tempCY - tempLT );
         if( val3 > greatest )
            greatest = val3;
         outReal[outIdx++] = greatest;
         today++;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int trimaLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod-1;
   }
   public RetCode trima( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int lookbackTotal;
      double numerator;
      double numeratorSub;
      double numeratorAdd;
      int i, outIdx, todayIdx, trailingIdx, middleIdx;
      double factor, tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = (optInTimePeriod-1);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      if( (optInTimePeriod % 2) == 1 )
      {
         i = (optInTimePeriod>>1);
         factor = (i+1)*(i+1);
         factor = 1.0/factor;
         trailingIdx = startIdx-lookbackTotal;
         middleIdx = trailingIdx + i;
         todayIdx = middleIdx + i;
         numerator = 0.0;
         numeratorSub = 0.0;
         for( i=middleIdx; i >= trailingIdx; i-- )
         {
            tempReal = inReal[i];
            numeratorSub += tempReal;
            numerator += numeratorSub;
         }
         numeratorAdd = 0.0;
         middleIdx++;
         for( i=middleIdx; i <= todayIdx; i++ )
         {
            tempReal = inReal[i];
            numeratorAdd += tempReal;
            numerator += numeratorAdd;
         }
         outIdx = 0;
         tempReal = inReal[trailingIdx++];
         outReal[outIdx++] = numerator * factor;
         todayIdx++;
         while( todayIdx <= endIdx )
         {
            numerator -= numeratorSub;
            numeratorSub -= tempReal;
            tempReal = inReal[middleIdx++];
            numeratorSub += tempReal;
            numerator += numeratorAdd;
            numeratorAdd -= tempReal;
            tempReal = inReal[todayIdx++];
            numeratorAdd += tempReal;
            numerator += tempReal;
            tempReal = inReal[trailingIdx++];
            outReal[outIdx++] = numerator * factor;
         }
      }
      else
      {
         i = (optInTimePeriod>>1);
         factor = i*(i+1);
         factor = 1.0/factor;
         trailingIdx = startIdx-lookbackTotal;
         middleIdx = trailingIdx + i - 1;
         todayIdx = middleIdx + i;
         numerator = 0.0;
         numeratorSub = 0.0;
         for( i=middleIdx; i >= trailingIdx; i-- )
         {
            tempReal = inReal[i];
            numeratorSub += tempReal;
            numerator += numeratorSub;
         }
         numeratorAdd = 0.0;
         middleIdx++;
         for( i=middleIdx; i <= todayIdx; i++ )
         {
            tempReal = inReal[i];
            numeratorAdd += tempReal;
            numerator += numeratorAdd;
         }
         outIdx = 0;
         tempReal = inReal[trailingIdx++];
         outReal[outIdx++] = numerator * factor;
         todayIdx++;
         while( todayIdx <= endIdx )
         {
            numerator -= numeratorSub;
            numeratorSub -= tempReal;
            tempReal = inReal[middleIdx++];
            numeratorSub += tempReal;
            numeratorAdd -= tempReal;
            numerator += numeratorAdd;
            tempReal = inReal[todayIdx++];
            numeratorAdd += tempReal;
            numerator += tempReal;
            tempReal = inReal[trailingIdx++];
            outReal[outIdx++] = numerator * factor;
         }
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode trimaStateInit( struct TA_trima_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct trima ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = trimaLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_TRIMA_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode trimaState( struct TA_trima_State* _state,
      double inReal,
      double *outReal )
   {
      int i, middle;
      double tempReal;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .numerator = 0;
         _state.value .numeratorSub = 0;
         _state.value .numeratorAdd = 0;
         if( ( _state.value .optInTimePeriod % 2) == 1 )
         {
            i = ( _state.value .optInTimePeriod>>1);
            _state.value .factor = (i+1)*(i+1);
            _state.value .factor = 1.0/ _state.value .factor;
            _state.value .middleIdx = i;
         } else {
            i = ( _state.value .optInTimePeriod>>1);
            _state.value .factor = i*(i+1);
            _state.value .factor = 1.0/ _state.value .factor;
            _state.value .middleIdx = i - 1;
         }
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
      {
         if ((int)_cur_idx <= _state.value .middleIdx)
         {
            _state.value .numerator -= _state.value .numeratorSub;
            _state.value .numeratorSub += inReal;
            _state.value .numerator += ( _state.value .middleIdx+1) * inReal;
         }
         if ((int)_cur_idx > _state.value .middleIdx)
         {
            _state.value .numeratorAdd += inReal;
            _state.value .numerator += _state.value .numeratorAdd;
         }
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      } else
         if ( _state.value .mem_size == _state.value .mem_index - 1)
         ++ _state.value .middleIdx;
      _state.value .numeratorAdd += inReal;
      if ( _state.value .mem_size == _state.value .mem_index - 1)
         _state.value .numerator += _state.value .numeratorAdd;
      else
         _state.value .numerator += inReal;
      outReal.value = _state.value .numerator * _state.value .factor;
      _state.value .numerator -= _state.value .numeratorSub;
      _state.value .numeratorSub -= ( _state.value .memory+_cur_idx).value .inReal ;
      middle = _state.value .middleIdx++ % _state.value .mem_size;
      tempReal = ( _state.value .memory+middle).value .inReal ;
      _state.value .numeratorSub += tempReal;
      if( ( _state.value .optInTimePeriod % 2) == 1 )
      {
         _state.value .numerator += _state.value .numeratorAdd;
         _state.value .numeratorAdd -= tempReal;
      } else {
         _state.value .numeratorAdd -= tempReal;
         _state.value .numerator += _state.value .numeratorAdd;
      }
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      return RetCode.Success ;
   }
   public RetCode trimaStateFree( struct TA_trima_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode trimaStateSave( struct TA_trima_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_TRIMA_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .numerator,sizeof( _state.value .numerator),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .numeratorSub,sizeof( _state.value .numeratorSub),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .numeratorAdd,sizeof( _state.value .numeratorAdd),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .factor,sizeof( _state.value .factor),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .middleIdx,sizeof( _state.value .middleIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode trimaStateLoad( struct TA_trima_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct trima ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_TRIMA_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_TRIMA_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .numerator,sizeof( _state.value .value .numerator),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .numeratorSub,sizeof( _state.value .value .numeratorSub),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .numeratorAdd,sizeof( _state.value .value .numeratorAdd),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .factor,sizeof( _state.value .value .factor),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .middleIdx,sizeof( _state.value .value .middleIdx),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode trima( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int lookbackTotal;
      double numerator;
      double numeratorSub;
      double numeratorAdd;
      int i, outIdx, todayIdx, trailingIdx, middleIdx;
      double factor, tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = (optInTimePeriod-1);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      if( (optInTimePeriod % 2) == 1 )
      {
         i = (optInTimePeriod>>1);
         factor = (i+1)*(i+1);
         factor = 1.0/factor;
         trailingIdx = startIdx-lookbackTotal;
         middleIdx = trailingIdx + i;
         todayIdx = middleIdx + i;
         numerator = 0.0;
         numeratorSub = 0.0;
         for( i=middleIdx; i >= trailingIdx; i-- )
         {
            tempReal = inReal[i];
            numeratorSub += tempReal;
            numerator += numeratorSub;
         }
         numeratorAdd = 0.0;
         middleIdx++;
         for( i=middleIdx; i <= todayIdx; i++ )
         {
            tempReal = inReal[i];
            numeratorAdd += tempReal;
            numerator += numeratorAdd;
         }
         outIdx = 0;
         tempReal = inReal[trailingIdx++];
         outReal[outIdx++] = numerator * factor;
         todayIdx++;
         while( todayIdx <= endIdx )
         {
            numerator -= numeratorSub;
            numeratorSub -= tempReal;
            tempReal = inReal[middleIdx++];
            numeratorSub += tempReal;
            numerator += numeratorAdd;
            numeratorAdd -= tempReal;
            tempReal = inReal[todayIdx++];
            numeratorAdd += tempReal;
            numerator += tempReal;
            tempReal = inReal[trailingIdx++];
            outReal[outIdx++] = numerator * factor;
         }
      }
      else
      {
         i = (optInTimePeriod>>1);
         factor = i*(i+1);
         factor = 1.0/factor;
         trailingIdx = startIdx-lookbackTotal;
         middleIdx = trailingIdx + i - 1;
         todayIdx = middleIdx + i;
         numerator = 0.0;
         numeratorSub = 0.0;
         for( i=middleIdx; i >= trailingIdx; i-- )
         {
            tempReal = inReal[i];
            numeratorSub += tempReal;
            numerator += numeratorSub;
         }
         numeratorAdd = 0.0;
         middleIdx++;
         for( i=middleIdx; i <= todayIdx; i++ )
         {
            tempReal = inReal[i];
            numeratorAdd += tempReal;
            numerator += numeratorAdd;
         }
         outIdx = 0;
         tempReal = inReal[trailingIdx++];
         outReal[outIdx++] = numerator * factor;
         todayIdx++;
         while( todayIdx <= endIdx )
         {
            numerator -= numeratorSub;
            numeratorSub -= tempReal;
            tempReal = inReal[middleIdx++];
            numeratorSub += tempReal;
            numeratorAdd -= tempReal;
            numerator += numeratorAdd;
            tempReal = inReal[todayIdx++];
            numeratorAdd += tempReal;
            numerator += tempReal;
            tempReal = inReal[trailingIdx++];
            outReal[outIdx++] = numerator * factor;
         }
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int trixLookback( int optInTimePeriod )
   {
      int emaLookback;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      emaLookback = emaLookback ( optInTimePeriod );
      return (emaLookback*3) + rocRLookback ( 1 );
   }
   public RetCode trix( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double k;
      double []tempBuffer ;
      MInteger nbElement = new MInteger() ;
      MInteger begIdx = new MInteger() ;
      int totalLookback;
      int emaLookback, rocLookback;
      RetCode retCode;
      int nbElementToOutput;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      emaLookback = emaLookback ( optInTimePeriod );
      rocLookback = rocRLookback ( 1 );
      totalLookback = (emaLookback*3) + rocLookback;
      if( startIdx < totalLookback )
         startIdx = totalLookback;
      if( startIdx > endIdx )
      {
         outNBElement.value = 0 ;
         outBegIdx.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      nbElementToOutput = (endIdx-startIdx)+1+totalLookback;
      tempBuffer = new double[nbElementToOutput] ;
      k = ((double)2.0 / ((double)(optInTimePeriod + 1))) ;
      retCode = TA_INT_EMA ( (startIdx-totalLookback), endIdx, inReal,
         optInTimePeriod, k,
         begIdx , nbElement ,
         tempBuffer );
      if( (retCode != RetCode.Success ) || ( nbElement.value == 0) )
      {
         outNBElement.value = 0 ;
         outBegIdx.value = 0 ;
         return retCode;
      }
      nbElementToOutput--;
      nbElementToOutput -= emaLookback;
      retCode = TA_INT_EMA ( 0, nbElementToOutput, tempBuffer,
         optInTimePeriod, k,
         begIdx , nbElement ,
         tempBuffer );
      if( (retCode != RetCode.Success ) || ( nbElement.value == 0) )
      {
         outNBElement.value = 0 ;
         outBegIdx.value = 0 ;
         return retCode;
      }
      nbElementToOutput -= emaLookback;
      retCode = TA_INT_EMA ( 0, nbElementToOutput, tempBuffer,
         optInTimePeriod, k,
         begIdx , nbElement ,
         tempBuffer );
      if( (retCode != RetCode.Success ) || ( nbElement.value == 0) )
      {
         outNBElement.value = 0 ;
         outBegIdx.value = 0 ;
         return retCode;
      }
      nbElementToOutput -= emaLookback;
      retCode = roc ( 0, nbElementToOutput,
         tempBuffer,
         1, begIdx , outNBElement,
         outReal );
      if( (retCode != RetCode.Success ) || ((int) outNBElement.value == 0) )
      {
         outNBElement.value = 0 ;
         outBegIdx.value = 0 ;
         return retCode;
      }
      return RetCode.Success ;
   }
   public RetCode trixStateInit( struct TA_trix_State** _state,
      int optInTimePeriod )
   {
      TA_RetCode retCode;
      double k;
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct trix ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = trixLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      k = ((double)2.0 / ((double)(optInTimePeriod + 1))) ;
      retCode = TA_INT_EMA_StateInit ( (struct ema **) & _state.value .value .stateEMA1, optInTimePeriod, k );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_INT_EMA_StateInit ( (struct ema **) & _state.value .value .stateEMA2, optInTimePeriod, k );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_INT_EMA_StateInit ( (struct ema **) & _state.value .value .stateEMA3, optInTimePeriod, k );
      if (retCode != RetCode.Success ) return retCode;
      retCode = roc ( (struct roc **) & _state.value .value .stateROC, 1);
      if (retCode != RetCode.Success ) return retCode;
      return RetCode.Success ;
   }
   public RetCode trixState( struct TA_trix_State* _state,
      double inReal,
      double *outReal )
   {
      TA_RetCode retCode;
      double tempReal;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      retCode = ema ( (struct ema *) _state.value .stateEMA1, inReal, &tempReal );
      if( retCode != RetCode.Success ) return retCode;
      retCode = ema ( (struct ema *) _state.value .stateEMA2, tempReal, &tempReal );
      if( retCode != RetCode.Success ) return retCode;
      retCode = ema ( (struct ema *) _state.value .stateEMA3, tempReal, &tempReal );
      if( retCode != RetCode.Success ) return retCode;
      retCode = roc ( (struct roc *) _state.value .stateROC, tempReal, &tempReal );
      if( retCode != RetCode.Success ) return retCode;
      outReal.value = tempReal;
      return RetCode.Success ;
   }
   public RetCode trixStateFree( struct TA_trix_State** _state )
   {
      TA_RetCode retCode;
      retCode = ema ( (struct ema **) & _state.value .value .stateEMA1 );
      if (retCode != RetCode.Success ) return retCode;
      retCode = ema ( (struct ema **) & _state.value .value .stateEMA2 );
      if (retCode != RetCode.Success ) return retCode;
      retCode = ema ( (struct ema **) & _state.value .value .stateEMA3 );
      if (retCode != RetCode.Success ) return retCode;
      retCode = roc ( (struct roc **) & _state.value .value .stateROC );
      if (retCode != RetCode.Success ) return retCode;
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode trixStateSave( struct TA_trix_State* _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_TRIX_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_EMA_StateSave ( (struct ema *) _state.value .stateEMA1, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_EMA_StateSave ( (struct ema *) _state.value .stateEMA2, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_EMA_StateSave ( (struct ema *) _state.value .stateEMA3, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_ROC_StateSave ( (struct roc *) _state.value .stateROC, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode trixStateLoad( struct TA_trix_State** _state,
      FILE* _file )
   {
      TA_RetCode retCode;
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct trix ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_TRIX_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_TRIX_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      retCode = TA_EMA_StateLoad ( (struct ema **) & _state.value .value .stateEMA1, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_EMA_StateLoad ( (struct ema **) & _state.value .value .stateEMA2, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_EMA_StateLoad ( (struct ema **) & _state.value .value .stateEMA3, _file );
      if (retCode != RetCode.Success ) return retCode;
      retCode = TA_ROC_StateLoad ( (struct roc **) & _state.value .value .stateROC, _file );
      if (retCode != RetCode.Success ) return retCode;
      return 0;
   }
   public RetCode trix( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double k;
      double []tempBuffer ;
      MInteger nbElement = new MInteger() ;
      MInteger begIdx = new MInteger() ;
      int totalLookback;
      int emaLookback, rocLookback;
      RetCode retCode;
      int nbElementToOutput;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      emaLookback = emaLookback ( optInTimePeriod );
      rocLookback = rocRLookback ( 1 );
      totalLookback = (emaLookback*3) + rocLookback;
      if( startIdx < totalLookback )
         startIdx = totalLookback;
      if( startIdx > endIdx )
      {
         outNBElement.value = 0 ;
         outBegIdx.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      nbElementToOutput = (endIdx-startIdx)+1+totalLookback;
      tempBuffer = new double[nbElementToOutput] ;
      k = ((double)2.0 / ((double)(optInTimePeriod + 1))) ;
      retCode = TA_INT_EMA ( (startIdx-totalLookback), endIdx, inReal,
         optInTimePeriod, k,
         begIdx , nbElement ,
         tempBuffer );
      if( (retCode != RetCode.Success ) || ( nbElement.value == 0) )
      {
         outNBElement.value = 0 ;
         outBegIdx.value = 0 ;
         return retCode;
      }
      nbElementToOutput--;
      nbElementToOutput -= emaLookback;
      retCode = TA_INT_EMA ( 0, nbElementToOutput, tempBuffer,
         optInTimePeriod, k,
         begIdx , nbElement ,
         tempBuffer );
      if( (retCode != RetCode.Success ) || ( nbElement.value == 0) )
      {
         outNBElement.value = 0 ;
         outBegIdx.value = 0 ;
         return retCode;
      }
      nbElementToOutput -= emaLookback;
      retCode = TA_INT_EMA ( 0, nbElementToOutput, tempBuffer,
         optInTimePeriod, k,
         begIdx , nbElement ,
         tempBuffer );
      if( (retCode != RetCode.Success ) || ( nbElement.value == 0) )
      {
         outNBElement.value = 0 ;
         outBegIdx.value = 0 ;
         return retCode;
      }
      nbElementToOutput -= emaLookback;
      retCode = roc ( 0, nbElementToOutput,
         tempBuffer,
         1, begIdx , outNBElement,
         outReal );
      if( (retCode != RetCode.Success ) || ((int) outNBElement.value == 0) )
      {
         outNBElement.value = 0 ;
         outBegIdx.value = 0 ;
         return retCode;
      }
      return RetCode.Success ;
   }
   /* Generated */
   public int tsfLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod-1;
   }
   public RetCode tsf( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int today, lookbackTotal;
      double SumX, SumXY, SumY, SumXSqr, Divisor;
      double m, b;
      int i;
      double tempValue1;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = tsfLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      SumX = optInTimePeriod * ( optInTimePeriod - 1 ) * 0.5;
      SumXSqr = optInTimePeriod * ( optInTimePeriod - 1 ) * ( 2 * optInTimePeriod - 1 ) / 6;
      Divisor = SumX * SumX - optInTimePeriod * SumXSqr;
      while( today <= endIdx )
      {
         SumXY = 0;
         SumY = 0;
         for( i = optInTimePeriod; i-- != 0; )
         {
            SumY += tempValue1 = inReal[today - i];
            SumXY += (double)i * tempValue1;
         }
         m = ( optInTimePeriod * SumXY - SumX * SumY) / Divisor;
         b = ( SumY - m * SumX ) / (double)optInTimePeriod;
         outReal[outIdx++] = b + m * (double)optInTimePeriod;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode tsfStateInit( struct TA_tsf_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct tsf ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = tsfLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_TSF_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode tsfState( struct TA_tsf_State* _state,
      double inReal,
      double *outReal )
   {
      double m, b, tempReal;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .SumX = _state.value .optInTimePeriod * ( _state.value .optInTimePeriod - 1 ) * 0.5;
         _state.value .SumXSqr = _state.value .optInTimePeriod * ( _state.value .optInTimePeriod - 1 ) * ( 2 * _state.value .optInTimePeriod - 1 ) / 6;
         _state.value .Divisor = _state.value .SumX * _state.value .SumX - _state.value .optInTimePeriod * _state.value .SumXSqr;
         _state.value .SumXY = 0;
         _state.value .SumY = 0;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
      {
         _state.value .SumY += inReal;
         _state.value .SumXY += _state.value .SumY;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      }
      _state.value .SumY += inReal;
      _state.value .SumXY += _state.value .SumY;
      m = ( _state.value .optInTimePeriod * _state.value .SumXY - _state.value .SumX * _state.value .SumY) / _state.value .Divisor;
      b = ( _state.value .SumY - m * _state.value .SumX ) / (double) _state.value .optInTimePeriod;
      outReal.value = b + m * (double) _state.value .optInTimePeriod;
      tempReal = ( _state.value .memory+_cur_idx).value .inReal ;
      _state.value .SumY -= tempReal;
      _state.value .SumXY -= tempReal* _state.value .optInTimePeriod;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      return RetCode.Success ;
   }
   public RetCode tsfStateFree( struct TA_tsf_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode tsfStateSave( struct TA_tsf_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_TSF_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .SumX,sizeof( _state.value .SumX),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .SumXY,sizeof( _state.value .SumXY),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .SumY,sizeof( _state.value .SumY),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .SumXSqr,sizeof( _state.value .SumXSqr),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .Divisor,sizeof( _state.value .Divisor),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode tsfStateLoad( struct TA_tsf_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct tsf ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_TSF_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_TSF_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .SumX,sizeof( _state.value .value .SumX),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .SumXY,sizeof( _state.value .value .SumXY),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .SumY,sizeof( _state.value .value .SumY),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .SumXSqr,sizeof( _state.value .value .SumXSqr),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .Divisor,sizeof( _state.value .value .Divisor),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode tsf( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int today, lookbackTotal;
      double SumX, SumXY, SumY, SumXSqr, Divisor;
      double m, b;
      int i;
      double tempValue1;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = tsfLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      SumX = optInTimePeriod * ( optInTimePeriod - 1 ) * 0.5;
      SumXSqr = optInTimePeriod * ( optInTimePeriod - 1 ) * ( 2 * optInTimePeriod - 1 ) / 6;
      Divisor = SumX * SumX - optInTimePeriod * SumXSqr;
      while( today <= endIdx )
      {
         SumXY = 0;
         SumY = 0;
         for( i = optInTimePeriod; i-- != 0; )
         {
            SumY += tempValue1 = inReal[today - i];
            SumXY += (double)i * tempValue1;
         }
         m = ( optInTimePeriod * SumXY - SumX * SumY) / Divisor;
         b = ( SumY - m * SumX ) / (double)optInTimePeriod;
         outReal[outIdx++] = b + m * (double)optInTimePeriod;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int typPriceLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode typPrice( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      outIdx = 0;
      for( i= startIdx; i <= endIdx; i++ )
      {
         outReal[outIdx++] = ( inHigh [i] +
            inLow [i] +
            inClose[i] ) / 3.0;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode typPriceStateInit( struct TA_typPrice_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct typPrice ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = typPriceLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_TYPPRICE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode typPriceState( struct TA_typPrice_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      outReal.value = ( inHigh + inLow + inClose ) / 3.0;
      return RetCode.Success ;
   }
   public RetCode typPriceStateFree( struct TA_typPrice_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode typPriceStateSave( struct TA_typPrice_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_TYPPRICE_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode typPriceStateLoad( struct TA_typPrice_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct typPrice ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_TYPPRICE_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_TYPPRICE_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode typPrice( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      outIdx = 0;
      for( i= startIdx; i <= endIdx; i++ )
      {
         outReal[outIdx++] = ( inHigh [i] +
            inLow [i] +
            inClose[i] ) / 3.0;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int ultOscLookback( int optInTimePeriod1,
      int optInTimePeriod2,
      int optInTimePeriod3 )
   {
      int maxPeriod;
      if( (int)optInTimePeriod1 == ( Integer.MIN_VALUE ) )
         optInTimePeriod1 = 7;
      else if( ((int)optInTimePeriod1 < 1) || ((int)optInTimePeriod1 > 100000) )
         return -1;
      if( (int)optInTimePeriod2 == ( Integer.MIN_VALUE ) )
         optInTimePeriod2 = 14;
      else if( ((int)optInTimePeriod2 < 1) || ((int)optInTimePeriod2 > 100000) )
         return -1;
      if( (int)optInTimePeriod3 == ( Integer.MIN_VALUE ) )
         optInTimePeriod3 = 28;
      else if( ((int)optInTimePeriod3 < 1) || ((int)optInTimePeriod3 > 100000) )
         return -1;
      maxPeriod = ((( (((optInTimePeriod1) > (optInTimePeriod2)) ? (optInTimePeriod1) : (optInTimePeriod2)) ) > (optInTimePeriod3)) ? ( (((optInTimePeriod1) > (optInTimePeriod2)) ? (optInTimePeriod1) : (optInTimePeriod2)) ) : (optInTimePeriod3)) ;
      return smaLookback ( maxPeriod ) + 1;
   }
   public RetCode ultOsc( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      int optInTimePeriod1,
      int optInTimePeriod2,
      int optInTimePeriod3,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double a1Total, a2Total, a3Total;
      double b1Total, b2Total, b3Total;
      double trueLow, trueRange, closeMinusTrueLow;
      double tempDouble, output, tempHT, tempLT, tempCY;
      int lookbackTotal;
      int longestPeriod, longestIndex;
      int i,j,today,outIdx;
      int trailingIdx1, trailingIdx2, trailingIdx3;
      int []usedFlag = new int[3] ;
      int []periods = new int[3] ;
      int []sortedPeriods = new int[3] ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod1 == ( Integer.MIN_VALUE ) )
         optInTimePeriod1 = 7;
      else if( ((int)optInTimePeriod1 < 1) || ((int)optInTimePeriod1 > 100000) )
         return RetCode.BadParam ;
      if( (int)optInTimePeriod2 == ( Integer.MIN_VALUE ) )
         optInTimePeriod2 = 14;
      else if( ((int)optInTimePeriod2 < 1) || ((int)optInTimePeriod2 > 100000) )
         return RetCode.BadParam ;
      if( (int)optInTimePeriod3 == ( Integer.MIN_VALUE ) )
         optInTimePeriod3 = 28;
      else if( ((int)optInTimePeriod3 < 1) || ((int)optInTimePeriod3 > 100000) )
         return RetCode.BadParam ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      periods[0] = optInTimePeriod1;
      periods[1] = optInTimePeriod2;
      periods[2] = optInTimePeriod3;
      usedFlag[0] = 0;
      usedFlag[1] = 0;
      usedFlag[2] = 0;
      for ( i = 0; i < 3; ++i )
      {
         longestPeriod = 0;
         longestIndex = 0;
         for ( j = 0; j < 3; ++j )
         {
            if ( (usedFlag[j] == 0) && (periods[j] > longestPeriod) )
            {
               longestPeriod = periods[j];
               longestIndex = j;
            }
         }
         usedFlag[longestIndex] = 1;
         sortedPeriods[i] = longestPeriod;
      }
      optInTimePeriod1 = sortedPeriods[2];
      optInTimePeriod2 = sortedPeriods[1];
      optInTimePeriod3 = sortedPeriods[0];
      lookbackTotal = ultOscLookback ( optInTimePeriod1, optInTimePeriod2, optInTimePeriod3 );
      if( startIdx < lookbackTotal ) startIdx = lookbackTotal;
      if( startIdx > endIdx ) return RetCode.Success ;
      { a1Total = 0; b1Total = 0; for ( i = startIdx-optInTimePeriod1+1; i < startIdx; ++i ) { { tempLT = inLow[i]; tempHT = inHigh[i]; tempCY = inClose[i-1]; trueLow = (((tempLT) < (tempCY)) ? (tempLT) : (tempCY)) ; closeMinusTrueLow = inClose[i] - trueLow; trueRange = tempHT - tempLT; tempDouble = Math.abs ( tempCY - tempHT ); if( tempDouble > trueRange ) trueRange = tempDouble; tempDouble = Math.abs ( tempCY - tempLT ); if( tempDouble > trueRange ) trueRange = tempDouble; } ; a1Total += closeMinusTrueLow; b1Total += trueRange; } } ;
      { a2Total = 0; b2Total = 0; for ( i = startIdx-optInTimePeriod2+1; i < startIdx; ++i ) { { tempLT = inLow[i]; tempHT = inHigh[i]; tempCY = inClose[i-1]; trueLow = (((tempLT) < (tempCY)) ? (tempLT) : (tempCY)) ; closeMinusTrueLow = inClose[i] - trueLow; trueRange = tempHT - tempLT; tempDouble = Math.abs ( tempCY - tempHT ); if( tempDouble > trueRange ) trueRange = tempDouble; tempDouble = Math.abs ( tempCY - tempLT ); if( tempDouble > trueRange ) trueRange = tempDouble; } ; a2Total += closeMinusTrueLow; b2Total += trueRange; } } ;
      { a3Total = 0; b3Total = 0; for ( i = startIdx-optInTimePeriod3+1; i < startIdx; ++i ) { { tempLT = inLow[i]; tempHT = inHigh[i]; tempCY = inClose[i-1]; trueLow = (((tempLT) < (tempCY)) ? (tempLT) : (tempCY)) ; closeMinusTrueLow = inClose[i] - trueLow; trueRange = tempHT - tempLT; tempDouble = Math.abs ( tempCY - tempHT ); if( tempDouble > trueRange ) trueRange = tempDouble; tempDouble = Math.abs ( tempCY - tempLT ); if( tempDouble > trueRange ) trueRange = tempDouble; } ; a3Total += closeMinusTrueLow; b3Total += trueRange; } } ;
      today = startIdx;
      outIdx = 0;
      trailingIdx1 = today - optInTimePeriod1 + 1;
      trailingIdx2 = today - optInTimePeriod2 + 1;
      trailingIdx3 = today - optInTimePeriod3 + 1;
      while( today <= endIdx )
      {
         { tempLT = inLow[today]; tempHT = inHigh[today]; tempCY = inClose[today-1]; trueLow = (((tempLT) < (tempCY)) ? (tempLT) : (tempCY)) ; closeMinusTrueLow = inClose[today] - trueLow; trueRange = tempHT - tempLT; tempDouble = Math.abs ( tempCY - tempHT ); if( tempDouble > trueRange ) trueRange = tempDouble; tempDouble = Math.abs ( tempCY - tempLT ); if( tempDouble > trueRange ) trueRange = tempDouble; } ;
         a1Total += closeMinusTrueLow;
         a2Total += closeMinusTrueLow;
         a3Total += closeMinusTrueLow;
         b1Total += trueRange;
         b2Total += trueRange;
         b3Total += trueRange;
         output = 0.0;
         if( ! (((- (0.00000000000001) )<b1Total)&&(b1Total< (0.00000000000001) )) ) output += 4.0*(a1Total/b1Total);
         if( ! (((- (0.00000000000001) )<b2Total)&&(b2Total< (0.00000000000001) )) ) output += 2.0*(a2Total/b2Total);
         if( ! (((- (0.00000000000001) )<b3Total)&&(b3Total< (0.00000000000001) )) ) output += a3Total/b3Total;
         { tempLT = inLow[trailingIdx1]; tempHT = inHigh[trailingIdx1]; tempCY = inClose[trailingIdx1-1]; trueLow = (((tempLT) < (tempCY)) ? (tempLT) : (tempCY)) ; closeMinusTrueLow = inClose[trailingIdx1] - trueLow; trueRange = tempHT - tempLT; tempDouble = Math.abs ( tempCY - tempHT ); if( tempDouble > trueRange ) trueRange = tempDouble; tempDouble = Math.abs ( tempCY - tempLT ); if( tempDouble > trueRange ) trueRange = tempDouble; } ;
         a1Total -= closeMinusTrueLow;
         b1Total -= trueRange;
         { tempLT = inLow[trailingIdx2]; tempHT = inHigh[trailingIdx2]; tempCY = inClose[trailingIdx2-1]; trueLow = (((tempLT) < (tempCY)) ? (tempLT) : (tempCY)) ; closeMinusTrueLow = inClose[trailingIdx2] - trueLow; trueRange = tempHT - tempLT; tempDouble = Math.abs ( tempCY - tempHT ); if( tempDouble > trueRange ) trueRange = tempDouble; tempDouble = Math.abs ( tempCY - tempLT ); if( tempDouble > trueRange ) trueRange = tempDouble; } ;
         a2Total -= closeMinusTrueLow;
         b2Total -= trueRange;
         { tempLT = inLow[trailingIdx3]; tempHT = inHigh[trailingIdx3]; tempCY = inClose[trailingIdx3-1]; trueLow = (((tempLT) < (tempCY)) ? (tempLT) : (tempCY)) ; closeMinusTrueLow = inClose[trailingIdx3] - trueLow; trueRange = tempHT - tempLT; tempDouble = Math.abs ( tempCY - tempHT ); if( tempDouble > trueRange ) trueRange = tempDouble; tempDouble = Math.abs ( tempCY - tempLT ); if( tempDouble > trueRange ) trueRange = tempDouble; } ;
         a3Total -= closeMinusTrueLow;
         b3Total -= trueRange;
         outReal[outIdx] = 100.0 * (output / 7.0);
         outIdx++;
         today++;
         trailingIdx1++;
         trailingIdx2++;
         trailingIdx3++;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   struct TA_ULTOSC_STATE_CIRCBUF { int idx; double* circbuf; int size; };
   public RetCode ultOscStateInit( struct TA_ultOsc_State** _state,
      int optInTimePeriod1,
      int optInTimePeriod2,
      int optInTimePeriod3 )
   {
      if (optInTimePeriod1 < optInTimePeriod2) {
         if (optInTimePeriod3 < optInTimePeriod1) { optInTimePeriod1 = optInTimePeriod1 ^ optInTimePeriod3; optInTimePeriod3 = optInTimePeriod1 ^ optInTimePeriod3; optInTimePeriod1 = optInTimePeriod1 ^ optInTimePeriod3; } ;
      } else {
         if (optInTimePeriod2 < optInTimePeriod3) { { optInTimePeriod1 = optInTimePeriod1 ^ optInTimePeriod2; optInTimePeriod2 = optInTimePeriod1 ^ optInTimePeriod2; optInTimePeriod1 = optInTimePeriod1 ^ optInTimePeriod2; } ; }
         else { optInTimePeriod1 = optInTimePeriod1 ^ optInTimePeriod3; optInTimePeriod3 = optInTimePeriod1 ^ optInTimePeriod3; optInTimePeriod1 = optInTimePeriod1 ^ optInTimePeriod3; } ;
      }
      if(optInTimePeriod3 < optInTimePeriod2) { optInTimePeriod2 = optInTimePeriod2 ^ optInTimePeriod3; optInTimePeriod3 = optInTimePeriod2 ^ optInTimePeriod3; optInTimePeriod2 = optInTimePeriod2 ^ optInTimePeriod3; } ;
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod1 == ( Integer.MIN_VALUE ) )
         optInTimePeriod1 = 7;
      else if( ((int)optInTimePeriod1 < 1) || ((int)optInTimePeriod1 > 100000) )
         return RetCode.BadParam ;
      if( (int)optInTimePeriod2 == ( Integer.MIN_VALUE ) )
         optInTimePeriod2 = 14;
      else if( ((int)optInTimePeriod2 < 1) || ((int)optInTimePeriod2 > 100000) )
         return RetCode.BadParam ;
      if( (int)optInTimePeriod3 == ( Integer.MIN_VALUE ) )
         optInTimePeriod3 = 28;
      else if( ((int)optInTimePeriod3 < 1) || ((int)optInTimePeriod3 > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct ultOsc ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod1 = optInTimePeriod1;
      _state.value .value .optInTimePeriod2 = optInTimePeriod2;
      _state.value .value .optInTimePeriod3 = optInTimePeriod3;
      _state.value .value .mem_size = ultOscLookback (optInTimePeriod1, optInTimePeriod2, optInTimePeriod3 );
      _state.value .value .memory = NULL;
      { _state.value .value .periodA = calloc(1, sizeof(struct TA_ULTOSC_STATE_CIRCBUF )); if ( _state.value .value .periodA == NULL) return RetCode.AllocErr ; struct TA_ULTOSC_STATE_CIRCBUF * buf = (struct TA_ULTOSC_STATE_CIRCBUF *) _state.value .value .periodA; buf->idx = 0; buf->size = optInTimePeriod3+1; buf->circbuf = calloc(optInTimePeriod3+1, sizeof(double)); if (!buf->circbuf) return RetCode.AllocErr ;} ;
      { _state.value .value .periodB = calloc(1, sizeof(struct TA_ULTOSC_STATE_CIRCBUF )); if ( _state.value .value .periodB == NULL) return RetCode.AllocErr ; struct TA_ULTOSC_STATE_CIRCBUF * buf = (struct TA_ULTOSC_STATE_CIRCBUF *) _state.value .value .periodB; buf->idx = 0; buf->size = optInTimePeriod3+1; buf->circbuf = calloc(optInTimePeriod3+1, sizeof(double)); if (!buf->circbuf) return RetCode.AllocErr ;} ;
      return RetCode.Success ;
   }
   public RetCode ultOscState( struct TA_ultOsc_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      double closeMinusTrueLow, trueRange, tempDouble;
      int idx;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .a1Total = 0;
         _state.value .a2Total = 0;
         _state.value .a3Total = 0;
         _state.value .b1Total = 0;
         _state.value .b2Total = 0;
         _state.value .b3Total = 0;
         _state.value .gap2 = _state.value .optInTimePeriod3 - _state.value .optInTimePeriod2;
         _state.value .gap1 = _state.value .optInTimePeriod3 - _state.value .optInTimePeriod1;
         _state.value .prevClose = inClose;
         return RetCode.NeedMoreData ;
      }
      closeMinusTrueLow = inClose - (((inLow) < ( _state.value .prevClose)) ? (inLow) : ( _state.value .prevClose)) ;
      trueRange = inHigh - inLow;
      tempDouble = Math.abs ( _state.value .prevClose - inHigh );
      if( tempDouble > trueRange )
         trueRange = tempDouble;
      tempDouble = Math.abs ( _state.value .prevClose - inLow );
      if( tempDouble > trueRange )
         trueRange = tempDouble;
      _state.value .a3Total += closeMinusTrueLow;
      _state.value .b3Total += trueRange;
      if ( _state.value .mem_index-1 > _state.value .gap2)
      {
         _state.value .a2Total += closeMinusTrueLow;
         _state.value .b2Total += trueRange;
      }
      if ( _state.value .mem_index-1 > _state.value .gap1)
      {
         _state.value .a1Total += closeMinusTrueLow;
         _state.value .b1Total += trueRange;
      }
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         tempDouble = 0.0;
         if( ! (((- (0.00000000000001) )< _state.value .b1Total)&&( _state.value .b1Total< (0.00000000000001) )) ) tempDouble += 4.0*( _state.value .a1Total/ _state.value .b1Total);
         if( ! (((- (0.00000000000001) )< _state.value .b2Total)&&( _state.value .b2Total< (0.00000000000001) )) ) tempDouble += 2.0*( _state.value .a2Total/ _state.value .b2Total);
         if( ! (((- (0.00000000000001) )< _state.value .b3Total)&&( _state.value .b3Total< (0.00000000000001) )) ) tempDouble += _state.value .a3Total/ _state.value .b3Total;
         outReal.value = 100.0 * (tempDouble / 7.0);
         idx = ( _state.value .mem_index-1 - _state.value .optInTimePeriod3) % ( _state.value .mem_size +1);
         _state.value .a3Total -= (*( ((struct TA_ULTOSC_STATE_CIRCBUF *) _state.value .periodA)->circbuf +idx)) ;
         _state.value .b3Total -= (*( ((struct TA_ULTOSC_STATE_CIRCBUF *) _state.value .periodB)->circbuf +idx)) ;
         idx = ( _state.value .mem_index-1 - _state.value .optInTimePeriod2) % ( _state.value .mem_size +1);
         _state.value .a2Total -= (*( ((struct TA_ULTOSC_STATE_CIRCBUF *) _state.value .periodA)->circbuf +idx)) ;
         _state.value .b2Total -= (*( ((struct TA_ULTOSC_STATE_CIRCBUF *) _state.value .periodB)->circbuf +idx)) ;
         idx = ( _state.value .mem_index-1 - _state.value .optInTimePeriod1) % ( _state.value .mem_size +1);
         _state.value .a1Total -= (*( ((struct TA_ULTOSC_STATE_CIRCBUF *) _state.value .periodA)->circbuf +idx)) ;
         _state.value .b1Total -= (*( ((struct TA_ULTOSC_STATE_CIRCBUF *) _state.value .periodB)->circbuf +idx)) ;
      }
      (*( ((struct TA_ULTOSC_STATE_CIRCBUF *) _state.value .periodA)->circbuf + ((struct TA_ULTOSC_STATE_CIRCBUF *) _state.value .periodA)->idx )) = closeMinusTrueLow;
      (*( ((struct TA_ULTOSC_STATE_CIRCBUF *) _state.value .periodB)->circbuf + ((struct TA_ULTOSC_STATE_CIRCBUF *) _state.value .periodB)->idx )) = trueRange;
      { struct TA_ULTOSC_STATE_CIRCBUF * buf = (struct TA_ULTOSC_STATE_CIRCBUF *) _state.value .periodA; if(buf->idx < buf->size-1) buf->idx++; else buf->idx = 0;} ;
      { struct TA_ULTOSC_STATE_CIRCBUF * buf = (struct TA_ULTOSC_STATE_CIRCBUF *) _state.value .periodB; if(buf->idx < buf->size-1) buf->idx++; else buf->idx = 0;} ;
      _state.value .prevClose = inClose;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      return RetCode.Success ;
   }
   public RetCode ultOscStateFree( struct TA_ultOsc_State** _state )
   {
      { struct TA_ULTOSC_STATE_CIRCBUF * buf = (struct TA_ULTOSC_STATE_CIRCBUF *) _state.value .value .periodA; if (buf != NULL) { if (buf->circbuf != NULL) free(buf->circbuf); free (buf); _state.value .value .periodA = NULL; } } ;
      { struct TA_ULTOSC_STATE_CIRCBUF * buf = (struct TA_ULTOSC_STATE_CIRCBUF *) _state.value .value .periodB; if (buf != NULL) { if (buf->circbuf != NULL) free(buf->circbuf); free (buf); _state.value .value .periodB = NULL; } } ;
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode ultOscStateSave( struct TA_ultOsc_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_ULTOSC_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod1,sizeof( _state.value .optInTimePeriod1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInTimePeriod2,sizeof( _state.value .optInTimePeriod2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInTimePeriod3,sizeof( _state.value .optInTimePeriod3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .a1Total,sizeof( _state.value .a1Total),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .a2Total,sizeof( _state.value .a2Total),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .a3Total,sizeof( _state.value .a3Total),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .b1Total,sizeof( _state.value .b1Total),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .b2Total,sizeof( _state.value .b2Total),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .b3Total,sizeof( _state.value .b3Total),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .prevClose,sizeof( _state.value .prevClose),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gap2,sizeof( _state.value .gap2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .gap1,sizeof( _state.value .gap1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      { int io_circbuf_res; struct TA_ULTOSC_STATE_CIRCBUF * str_circbuf = _state.value .periodA; io_circbuf_res = fwrite(&str_circbuf->idx,sizeof(str_circbuf->idx),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; io_circbuf_res = fwrite(&str_circbuf->size,sizeof(str_circbuf->size),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; if (str_circbuf->size > 0) { io_circbuf_res = fwrite(str_circbuf->circbuf,sizeof(str_circbuf->circbuf),str_circbuf->size,_file); if (io_circbuf_res < str_circbuf->size) return RetCode.IOFailed ; } }
      { int io_circbuf_res; struct TA_ULTOSC_STATE_CIRCBUF * str_circbuf = _state.value .periodB; io_circbuf_res = fwrite(&str_circbuf->idx,sizeof(str_circbuf->idx),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; io_circbuf_res = fwrite(&str_circbuf->size,sizeof(str_circbuf->size),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; if (str_circbuf->size > 0) { io_circbuf_res = fwrite(str_circbuf->circbuf,sizeof(str_circbuf->circbuf),str_circbuf->size,_file); if (io_circbuf_res < str_circbuf->size) return RetCode.IOFailed ; } }
      return 0;
   }
   public RetCode ultOscStateLoad( struct TA_ultOsc_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct ultOsc ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_ULTOSC_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_ULTOSC_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod1,sizeof( _state.value .value .optInTimePeriod1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInTimePeriod2,sizeof( _state.value .value .optInTimePeriod2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInTimePeriod3,sizeof( _state.value .value .optInTimePeriod3),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .a1Total,sizeof( _state.value .value .a1Total),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .a2Total,sizeof( _state.value .value .a2Total),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .a3Total,sizeof( _state.value .value .a3Total),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .b1Total,sizeof( _state.value .value .b1Total),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .b2Total,sizeof( _state.value .value .b2Total),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .b3Total,sizeof( _state.value .value .b3Total),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .prevClose,sizeof( _state.value .value .prevClose),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gap2,sizeof( _state.value .value .gap2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .gap1,sizeof( _state.value .value .gap1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      { int io_circbuf_res; int circbuf_idx; int circbuf_size; if ( _state.value .value .periodA != NULL) return RetCode.BadParam ; io_circbuf_res = fread(&circbuf_idx,sizeof(circbuf_idx),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; io_circbuf_res = fread(&circbuf_size,sizeof(circbuf_size),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; { _state.value .value .periodA = calloc(1, sizeof(struct TA_ULTOSC_STATE_CIRCBUF )); if ( _state.value .value .periodA == NULL) return RetCode.AllocErr ; struct TA_ULTOSC_STATE_CIRCBUF * buf = (struct TA_ULTOSC_STATE_CIRCBUF *) _state.value .value .periodA; buf->idx = 0; buf->size = circbuf_size; buf->circbuf = calloc(circbuf_size, sizeof(double)); if (!buf->circbuf) return RetCode.AllocErr ;} struct TA_ULTOSC_STATE_CIRCBUF * str_circbuf = _state.value .value .periodA; str_circbuf->idx = circbuf_idx; if (str_circbuf->size > 0) { io_circbuf_res = fread(str_circbuf->circbuf,sizeof(str_circbuf->circbuf),str_circbuf->size,_file); if (io_circbuf_res < str_circbuf->size) return RetCode.IOFailed ; } }
      { int io_circbuf_res; int circbuf_idx; int circbuf_size; if ( _state.value .value .periodB != NULL) return RetCode.BadParam ; io_circbuf_res = fread(&circbuf_idx,sizeof(circbuf_idx),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; io_circbuf_res = fread(&circbuf_size,sizeof(circbuf_size),1,_file); if (io_circbuf_res < 0) return RetCode.IOFailed ; { _state.value .value .periodB = calloc(1, sizeof(struct TA_ULTOSC_STATE_CIRCBUF )); if ( _state.value .value .periodB == NULL) return RetCode.AllocErr ; struct TA_ULTOSC_STATE_CIRCBUF * buf = (struct TA_ULTOSC_STATE_CIRCBUF *) _state.value .value .periodB; buf->idx = 0; buf->size = circbuf_size; buf->circbuf = calloc(circbuf_size, sizeof(double)); if (!buf->circbuf) return RetCode.AllocErr ;} struct TA_ULTOSC_STATE_CIRCBUF * str_circbuf = _state.value .value .periodB; str_circbuf->idx = circbuf_idx; if (str_circbuf->size > 0) { io_circbuf_res = fread(str_circbuf->circbuf,sizeof(str_circbuf->circbuf),str_circbuf->size,_file); if (io_circbuf_res < str_circbuf->size) return RetCode.IOFailed ; } }
      return 0;
   }
   public RetCode ultOsc( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      int optInTimePeriod1,
      int optInTimePeriod2,
      int optInTimePeriod3,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double a1Total, a2Total, a3Total;
      double b1Total, b2Total, b3Total;
      double trueLow, trueRange, closeMinusTrueLow;
      double tempDouble, output, tempHT, tempLT, tempCY;
      int lookbackTotal;
      int longestPeriod, longestIndex;
      int i,j,today,outIdx;
      int trailingIdx1, trailingIdx2, trailingIdx3;
      int []usedFlag = new int[3] ;
      int []periods = new int[3] ;
      int []sortedPeriods = new int[3] ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod1 == ( Integer.MIN_VALUE ) )
         optInTimePeriod1 = 7;
      else if( ((int)optInTimePeriod1 < 1) || ((int)optInTimePeriod1 > 100000) )
         return RetCode.BadParam ;
      if( (int)optInTimePeriod2 == ( Integer.MIN_VALUE ) )
         optInTimePeriod2 = 14;
      else if( ((int)optInTimePeriod2 < 1) || ((int)optInTimePeriod2 > 100000) )
         return RetCode.BadParam ;
      if( (int)optInTimePeriod3 == ( Integer.MIN_VALUE ) )
         optInTimePeriod3 = 28;
      else if( ((int)optInTimePeriod3 < 1) || ((int)optInTimePeriod3 > 100000) )
         return RetCode.BadParam ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      periods[0] = optInTimePeriod1;
      periods[1] = optInTimePeriod2;
      periods[2] = optInTimePeriod3;
      usedFlag[0] = 0;
      usedFlag[1] = 0;
      usedFlag[2] = 0;
      for ( i = 0; i < 3; ++i )
      {
         longestPeriod = 0;
         longestIndex = 0;
         for ( j = 0; j < 3; ++j )
         {
            if ( (usedFlag[j] == 0) && (periods[j] > longestPeriod) )
            {
               longestPeriod = periods[j];
               longestIndex = j;
            }
         }
         usedFlag[longestIndex] = 1;
         sortedPeriods[i] = longestPeriod;
      }
      optInTimePeriod1 = sortedPeriods[2];
      optInTimePeriod2 = sortedPeriods[1];
      optInTimePeriod3 = sortedPeriods[0];
      lookbackTotal = ultOscLookback ( optInTimePeriod1, optInTimePeriod2, optInTimePeriod3 );
      if( startIdx < lookbackTotal ) startIdx = lookbackTotal;
      if( startIdx > endIdx ) return RetCode.Success ;
      { a1Total = 0; b1Total = 0; for ( i = startIdx-optInTimePeriod1+1; i < startIdx; ++i ) { { tempLT = inLow[i]; tempHT = inHigh[i]; tempCY = inClose[i-1]; trueLow = (((tempLT) < (tempCY)) ? (tempLT) : (tempCY)) ; closeMinusTrueLow = inClose[i] - trueLow; trueRange = tempHT - tempLT; tempDouble = Math.abs ( tempCY - tempHT ); if( tempDouble > trueRange ) trueRange = tempDouble; tempDouble = Math.abs ( tempCY - tempLT ); if( tempDouble > trueRange ) trueRange = tempDouble; } ; a1Total += closeMinusTrueLow; b1Total += trueRange; } } ;
      { a2Total = 0; b2Total = 0; for ( i = startIdx-optInTimePeriod2+1; i < startIdx; ++i ) { { tempLT = inLow[i]; tempHT = inHigh[i]; tempCY = inClose[i-1]; trueLow = (((tempLT) < (tempCY)) ? (tempLT) : (tempCY)) ; closeMinusTrueLow = inClose[i] - trueLow; trueRange = tempHT - tempLT; tempDouble = Math.abs ( tempCY - tempHT ); if( tempDouble > trueRange ) trueRange = tempDouble; tempDouble = Math.abs ( tempCY - tempLT ); if( tempDouble > trueRange ) trueRange = tempDouble; } ; a2Total += closeMinusTrueLow; b2Total += trueRange; } } ;
      { a3Total = 0; b3Total = 0; for ( i = startIdx-optInTimePeriod3+1; i < startIdx; ++i ) { { tempLT = inLow[i]; tempHT = inHigh[i]; tempCY = inClose[i-1]; trueLow = (((tempLT) < (tempCY)) ? (tempLT) : (tempCY)) ; closeMinusTrueLow = inClose[i] - trueLow; trueRange = tempHT - tempLT; tempDouble = Math.abs ( tempCY - tempHT ); if( tempDouble > trueRange ) trueRange = tempDouble; tempDouble = Math.abs ( tempCY - tempLT ); if( tempDouble > trueRange ) trueRange = tempDouble; } ; a3Total += closeMinusTrueLow; b3Total += trueRange; } } ;
      today = startIdx;
      outIdx = 0;
      trailingIdx1 = today - optInTimePeriod1 + 1;
      trailingIdx2 = today - optInTimePeriod2 + 1;
      trailingIdx3 = today - optInTimePeriod3 + 1;
      while( today <= endIdx )
      {
         { tempLT = inLow[today]; tempHT = inHigh[today]; tempCY = inClose[today-1]; trueLow = (((tempLT) < (tempCY)) ? (tempLT) : (tempCY)) ; closeMinusTrueLow = inClose[today] - trueLow; trueRange = tempHT - tempLT; tempDouble = Math.abs ( tempCY - tempHT ); if( tempDouble > trueRange ) trueRange = tempDouble; tempDouble = Math.abs ( tempCY - tempLT ); if( tempDouble > trueRange ) trueRange = tempDouble; } ;
         a1Total += closeMinusTrueLow;
         a2Total += closeMinusTrueLow;
         a3Total += closeMinusTrueLow;
         b1Total += trueRange;
         b2Total += trueRange;
         b3Total += trueRange;
         output = 0.0;
         if( ! (((- (0.00000000000001) )<b1Total)&&(b1Total< (0.00000000000001) )) ) output += 4.0*(a1Total/b1Total);
         if( ! (((- (0.00000000000001) )<b2Total)&&(b2Total< (0.00000000000001) )) ) output += 2.0*(a2Total/b2Total);
         if( ! (((- (0.00000000000001) )<b3Total)&&(b3Total< (0.00000000000001) )) ) output += a3Total/b3Total;
         { tempLT = inLow[trailingIdx1]; tempHT = inHigh[trailingIdx1]; tempCY = inClose[trailingIdx1-1]; trueLow = (((tempLT) < (tempCY)) ? (tempLT) : (tempCY)) ; closeMinusTrueLow = inClose[trailingIdx1] - trueLow; trueRange = tempHT - tempLT; tempDouble = Math.abs ( tempCY - tempHT ); if( tempDouble > trueRange ) trueRange = tempDouble; tempDouble = Math.abs ( tempCY - tempLT ); if( tempDouble > trueRange ) trueRange = tempDouble; } ;
         a1Total -= closeMinusTrueLow;
         b1Total -= trueRange;
         { tempLT = inLow[trailingIdx2]; tempHT = inHigh[trailingIdx2]; tempCY = inClose[trailingIdx2-1]; trueLow = (((tempLT) < (tempCY)) ? (tempLT) : (tempCY)) ; closeMinusTrueLow = inClose[trailingIdx2] - trueLow; trueRange = tempHT - tempLT; tempDouble = Math.abs ( tempCY - tempHT ); if( tempDouble > trueRange ) trueRange = tempDouble; tempDouble = Math.abs ( tempCY - tempLT ); if( tempDouble > trueRange ) trueRange = tempDouble; } ;
         a2Total -= closeMinusTrueLow;
         b2Total -= trueRange;
         { tempLT = inLow[trailingIdx3]; tempHT = inHigh[trailingIdx3]; tempCY = inClose[trailingIdx3-1]; trueLow = (((tempLT) < (tempCY)) ? (tempLT) : (tempCY)) ; closeMinusTrueLow = inClose[trailingIdx3] - trueLow; trueRange = tempHT - tempLT; tempDouble = Math.abs ( tempCY - tempHT ); if( tempDouble > trueRange ) trueRange = tempDouble; tempDouble = Math.abs ( tempCY - tempLT ); if( tempDouble > trueRange ) trueRange = tempDouble; } ;
         a3Total -= closeMinusTrueLow;
         b3Total -= trueRange;
         outReal[outIdx] = 100.0 * (output / 7.0);
         outIdx++;
         today++;
         trailingIdx1++;
         trailingIdx2++;
         trailingIdx3++;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int varianceLookback( int optInTimePeriod,
      double optInNbDev )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      if( optInNbDev == (-4e+37) )
         optInNbDev = 1.000000e+0;
      else if( (optInNbDev < -3.000000e+37) || (optInNbDev > 3.000000e+37) )
         return -1;
      return optInTimePeriod-1;
   }
   public RetCode variance( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      double optInNbDev,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInNbDev == (-4e+37) )
         optInNbDev = 1.000000e+0;
      else if( (optInNbDev < -3.000000e+37) || (optInNbDev > 3.000000e+37) )
         return RetCode.BadParam ;
      return TA_INT_VAR ( startIdx, endIdx, inReal,
         optInTimePeriod,
         outBegIdx, outNBElement, outReal );
   }
   public RetCode TA_INT_VAR( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double tempReal, periodTotal1, periodTotal2, meanValue1, meanValue2;
      int i, outIdx, trailingIdx, nbInitialElementNeeded;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      periodTotal1 = 0;
      periodTotal2 = 0;
      trailingIdx = startIdx-nbInitialElementNeeded;
      i=trailingIdx;
      if( optInTimePeriod > 1 )
      {
         while( i < startIdx ) {
            tempReal = inReal[i++];
            periodTotal1 += tempReal;
            tempReal *= tempReal;
            periodTotal2 += tempReal;
         }
      }
      outIdx = 0;
      do
      {
         tempReal = inReal[i++];
         periodTotal1 += tempReal;
         tempReal *= tempReal;
         periodTotal2 += tempReal;
         meanValue1 = periodTotal1 / optInTimePeriod;
         meanValue2 = periodTotal2 / optInTimePeriod;
         tempReal = inReal[trailingIdx++];
         periodTotal1 -= tempReal;
         tempReal *= tempReal;
         periodTotal2 -= tempReal;
         outReal[outIdx++] = meanValue2-meanValue1*meanValue1;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode varianceStateInit( struct TA_variance_State** _state,
      int optInTimePeriod,
      double optInNbDev )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInNbDev == (-4e+37) )
         optInNbDev = 1.000000e+0;
      else if( (optInNbDev < -3.000000e+37) || (optInNbDev > 3.000000e+37) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct variance ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .optInNbDev = optInNbDev;
      _state.value .value .mem_size = varianceLookback (optInTimePeriod, optInNbDev );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_VAR_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode varianceState( struct TA_variance_State* _state,
      double inReal,
      double *outReal )
   {
      double tempReal, meanValue1, meanValue2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .periodTotal1 = 0.;
         _state.value .periodTotal2 = 0.;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
      {
         _state.value .periodTotal1 += inReal;
         _state.value .periodTotal2 += inReal*inReal;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      }
      _state.value .periodTotal1 += inReal;
      _state.value .periodTotal2 += inReal*inReal;
      meanValue1 = _state.value .periodTotal1 / _state.value .optInTimePeriod;
      meanValue2 = _state.value .periodTotal2 / _state.value .optInTimePeriod;
      outReal.value = meanValue2 - meanValue1 * meanValue1;
      tempReal = ( _state.value .memory+_cur_idx).value .inReal ;
      _state.value .periodTotal1 -= tempReal;
      _state.value .periodTotal2 -= tempReal*tempReal;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      return RetCode.Success ;
   }
   public RetCode varianceStateFree( struct TA_variance_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode varianceStateSave( struct TA_variance_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_VAR_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .optInNbDev,sizeof( _state.value .optInNbDev),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodTotal1,sizeof( _state.value .periodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodTotal2,sizeof( _state.value .periodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode varianceStateLoad( struct TA_variance_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct variance ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_VAR_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_VAR_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .optInNbDev,sizeof( _state.value .value .optInNbDev),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodTotal1,sizeof( _state.value .value .periodTotal1),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodTotal2,sizeof( _state.value .value .periodTotal2),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode variance( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      double optInNbDev,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInNbDev == (-4e+37) )
         optInNbDev = 1.000000e+0;
      else if( (optInNbDev < -3.000000e+37) || (optInNbDev > 3.000000e+37) )
         return RetCode.BadParam ;
      return TA_INT_VAR ( startIdx, endIdx, inReal,
         optInTimePeriod,
         outBegIdx, outNBElement, outReal );
   }
   public RetCode TA_INT_VAR( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double tempReal, periodTotal1, periodTotal2, meanValue1, meanValue2;
      int i, outIdx, trailingIdx, nbInitialElementNeeded;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      periodTotal1 = 0;
      periodTotal2 = 0;
      trailingIdx = startIdx-nbInitialElementNeeded;
      i=trailingIdx;
      if( optInTimePeriod > 1 )
      {
         while( i < startIdx ) {
            tempReal = inReal[i++];
            periodTotal1 += tempReal;
            tempReal *= tempReal;
            periodTotal2 += tempReal;
         }
      }
      outIdx = 0;
      do
      {
         tempReal = inReal[i++];
         periodTotal1 += tempReal;
         tempReal *= tempReal;
         periodTotal2 += tempReal;
         meanValue1 = periodTotal1 / optInTimePeriod;
         meanValue2 = periodTotal2 / optInTimePeriod;
         tempReal = inReal[trailingIdx++];
         periodTotal1 -= tempReal;
         tempReal *= tempReal;
         periodTotal2 -= tempReal;
         outReal[outIdx++] = meanValue2-meanValue1*meanValue1;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int wclPriceLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode wclPrice( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      outIdx = 0;
      for( i= startIdx; i <= endIdx; i++ )
      {
         outReal[outIdx++] = ( inHigh [i] +
            inLow [i] +
            (inClose[i]*2.0) ) / 4.0;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode wclPriceStateInit( struct TA_wclPrice_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct wclPrice ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = wclPriceLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_WCLPRICE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode wclPriceState( struct TA_wclPrice_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      outReal.value = ( inHigh + inLow + (inClose*2.0) ) / 4.0;
      return RetCode.Success ;
   }
   public RetCode wclPriceStateFree( struct TA_wclPrice_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode wclPriceStateSave( struct TA_wclPrice_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_WCLPRICE_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode wclPriceStateLoad( struct TA_wclPrice_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct wclPrice ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_WCLPRICE_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_WCLPRICE_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      return 0;
   }
   public RetCode wclPrice( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      outIdx = 0;
      for( i= startIdx; i <= endIdx; i++ )
      {
         outReal[outIdx++] = ( inHigh [i] +
            inLow [i] +
            (inClose[i]*2.0) ) / 4.0;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int willRLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return (optInTimePeriod-1);
   }
   public RetCode willR( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double lowest, highest, tmp, diff;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, lowestIdx, highestIdx;
      int today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      diff = 0.0;
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      lowestIdx = highestIdx = -1;
      diff = highest = lowest = 0.0;
      while( today <= endIdx )
      {
         tmp = inLow[today];
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inLow[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmp = inLow[i];
               if( tmp < lowest )
               {
                  lowestIdx = i;
                  lowest = tmp;
               }
            }
            diff = (highest - lowest)/(-100.0);
         }
         else if( tmp <= lowest )
         {
            lowestIdx = today;
            lowest = tmp;
            diff = (highest - lowest)/(-100.0);
         }
         tmp = inHigh[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inHigh[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmp = inHigh[i];
               if( tmp > highest )
               {
                  highestIdx = i;
                  highest = tmp;
               }
            }
            diff = (highest - lowest)/(-100.0);
         }
         else if( tmp >= highest )
         {
            highestIdx = today;
            highest = tmp;
            diff = (highest - lowest)/(-100.0);
         }
         if( diff != 0.0 )
            outReal[outIdx++] = (highest-inClose[today])/diff;
         else
            outReal[outIdx++] = 0.0;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public RetCode willRStateInit( struct TA_willR_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct willR ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = willRLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_WILLR_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode willRState( struct TA_willR_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      unsigned int i;
      int j,p;
      double temp;
      double diff;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .lowest = inLow;
         _state.value .highest = inHigh;
         _state.value .lowest_exp = _state.value .optInTimePeriod;
         _state.value .highest_exp = _state.value .optInTimePeriod;
      }
      if (-- _state.value .lowest_exp <= 0)
      {
         _state.value .lowest = inLow;
         _state.value .lowest_exp = _state.value .optInTimePeriod;
         j = _state.value .mem_index-1;
         p = _state.value .optInTimePeriod;
         for (i = 0; i < _state.value .mem_size ; i++)
         {
            temp = ( _state.value .memory+(--j) % _state.value .mem_size ).value .inLow ;
            p--;
            if (temp <= _state.value .lowest)
            {
               _state.value .lowest = temp;
               _state.value .lowest_exp = p;
            }
         }
      } else if (inLow <= _state.value .lowest)
      {
         _state.value .lowest = inLow;
         _state.value .lowest_exp = _state.value .optInTimePeriod;
      }
      if (-- _state.value .highest_exp <= 0)
      {
         _state.value .highest = inHigh;
         _state.value .highest_exp = _state.value .optInTimePeriod;
         j = _state.value .mem_index-1;
         p = _state.value .optInTimePeriod;
         for ( i = 0; i < _state.value .mem_size ; i++)
         {
            temp = ( _state.value .memory+(--j) % _state.value .mem_size ).value .inHigh ;
            p--;
            if (temp >= _state.value .highest)
            {
               _state.value .highest = temp;
               _state.value .highest_exp = p;
            }
         }
      } else if (inHigh >= _state.value .highest)
      {
         _state.value .highest = inHigh;
         _state.value .highest_exp = _state.value .optInTimePeriod;
      }
      ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
      ( _state.value .memory+_cur_idx).value .inLow = inLow ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      diff = ( _state.value .highest - _state.value .lowest)/(-100.0);
      if( diff != 0.0 )
         outReal.value = ( _state.value .highest-inClose)/diff;
      else
         outReal.value = 0.0;
      return RetCode.Success ;
   }
   public RetCode willRStateFree( struct TA_willR_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode willRStateSave( struct TA_willR_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_WILLR_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .lowest,sizeof( _state.value .lowest),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .highest,sizeof( _state.value .highest),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .lowest_exp,sizeof( _state.value .lowest_exp),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .highest_exp,sizeof( _state.value .highest_exp),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode willRStateLoad( struct TA_willR_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct willR ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_WILLR_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_WILLR_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .lowest,sizeof( _state.value .value .lowest),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .highest,sizeof( _state.value .value .highest),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .lowest_exp,sizeof( _state.value .value .lowest_exp),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .highest_exp,sizeof( _state.value .value .highest_exp),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode willR( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double lowest, highest, tmp, diff;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, lowestIdx, highestIdx;
      int today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      diff = 0.0;
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      lowestIdx = highestIdx = -1;
      diff = highest = lowest = 0.0;
      while( today <= endIdx )
      {
         tmp = inLow[today];
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inLow[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmp = inLow[i];
               if( tmp < lowest )
               {
                  lowestIdx = i;
                  lowest = tmp;
               }
            }
            diff = (highest - lowest)/(-100.0);
         }
         else if( tmp <= lowest )
         {
            lowestIdx = today;
            lowest = tmp;
            diff = (highest - lowest)/(-100.0);
         }
         tmp = inHigh[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inHigh[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmp = inHigh[i];
               if( tmp > highest )
               {
                  highestIdx = i;
                  highest = tmp;
               }
            }
            diff = (highest - lowest)/(-100.0);
         }
         else if( tmp >= highest )
         {
            highestIdx = today;
            highest = tmp;
            diff = (highest - lowest)/(-100.0);
         }
         if( diff != 0.0 )
            outReal[outIdx++] = (highest-inClose[today])/diff;
         else
            outReal[outIdx++] = 0.0;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int wmaLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod - 1;
   }
   public RetCode wma( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int inIdx, outIdx, i, trailingIdx, divider;
      double periodSum, periodSub, tempReal, trailingValue;
      int lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = optInTimePeriod-1;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      if( optInTimePeriod == 1 )
      {
         outBegIdx.value = startIdx;
         outNBElement.value = endIdx-startIdx+1;
         System.arraycopy(inReal,startIdx,outReal,0,(int) outNBElement.value ) ;
         return RetCode.Success ;
      }
      divider = (optInTimePeriod*(optInTimePeriod+1))>>1;
      outIdx = 0;
      trailingIdx = startIdx - lookbackTotal;
      periodSum = periodSub = (double)0.0;
      inIdx=trailingIdx;
      i = 1;
      while( inIdx < startIdx )
      {
         tempReal = inReal[inIdx++];
         periodSub += tempReal;
         periodSum += tempReal*i;
         i++;
      }
      trailingValue = 0.0;
      while( inIdx <= endIdx )
      {
         tempReal = inReal[inIdx++];
         periodSub += tempReal;
         periodSub -= trailingValue;
         periodSum += tempReal*optInTimePeriod;
         trailingValue = inReal[trailingIdx++];
         outReal[outIdx++] = periodSum / divider;
         periodSum -= periodSub;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public RetCode wmaStateInit( struct TA_wma_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct wma ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = wmaLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_WMA_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public RetCode wmaState( struct TA_wma_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .periodSum = 0.;
         _state.value .periodSub = 0.;
         _state.value .divider = ( _state.value .optInTimePeriod*( _state.value .optInTimePeriod+1))>>1;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
      {
         _state.value .periodSum += inReal* _state.value .optInTimePeriod;
         _state.value .periodSub += inReal;
         _state.value .periodSum -= _state.value .periodSub;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      }
      _state.value .periodSub += inReal;
      _state.value .periodSum += inReal* _state.value .optInTimePeriod;
      outReal.value = _state.value .periodSum / _state.value .divider;
      _state.value .periodSum -= _state.value .periodSub;
      _state.value .periodSub -= ( _state.value .memory+_cur_idx).value .inReal ;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      return RetCode.Success ;
   }
   public RetCode wmaStateFree( struct TA_wma_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode wmaStateSave( struct TA_wma_State* _state,
      FILE* _file )
   {
      int io_res; int state_is_null; state_is_null = (_state == NULL);
      io_res = fwrite(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      io_res = fwrite(& _state.value .mem_index,sizeof( _state.value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .mem_size,sizeof( _state.value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      memory_allocated = _state.value .memory != NULL;
      io_res = fwrite(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (memory_allocated && _state.value .mem_size > 0) { io_res = fwrite( _state.value .memory,sizeof(struct TA_WMA_Data), _state.value .mem_size,_file);
         if (io_res < (int) _state.value .mem_size) return RetCode.IOFailed ; }
      io_res = fwrite(& _state.value .optInTimePeriod,sizeof( _state.value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodSum,sizeof( _state.value .periodSum),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .periodSub,sizeof( _state.value .periodSub),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fwrite(& _state.value .divider,sizeof( _state.value .divider),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode wmaStateLoad( struct TA_wma_State** _state,
      FILE* _file )
   {
      int io_res; int state_is_null;
      io_res = fread(&state_is_null,sizeof(state_is_null),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if (state_is_null) return RetCode.Success ;
      if ( _state.value != NULL) return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct wma ));
      io_res = fread(& _state.value .value .mem_index,sizeof( _state.value .value .mem_index),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .mem_size,sizeof( _state.value .value .mem_size),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      int memory_allocated;
      io_res = fread(&memory_allocated,sizeof(memory_allocated),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      if ( _state.value .value .mem_size > 0 && memory_allocated) { _state.value .value .memory = TA_Calloc( _state.value .value .mem_size, sizeof(struct TA_WMA_Data));
         io_res = fread( _state.value .value .memory,sizeof(struct TA_WMA_Data), _state.value .value .mem_size,_file);
         if (io_res < (int) _state.value .value .mem_size) return RetCode.IOFailed ; }
      io_res = fread(& _state.value .value .optInTimePeriod,sizeof( _state.value .value .optInTimePeriod),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodSum,sizeof( _state.value .value .periodSum),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .periodSub,sizeof( _state.value .value .periodSub),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      io_res = fread(& _state.value .value .divider,sizeof( _state.value .value .divider),1,_file);
      if (io_res < 1) return RetCode.IOFailed ;
      return 0;
   }
   public RetCode wma( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int inIdx, outIdx, i, trailingIdx, divider;
      double periodSum, periodSub, tempReal, trailingValue;
      int lookbackTotal;
      int mmmixi, mmmixdestIdx, mmmixsrcIdx ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = optInTimePeriod-1;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      if( optInTimePeriod == 1 )
      {
         outBegIdx.value = startIdx;
         outNBElement.value = endIdx-startIdx+1;
         { for( mmmixi=0, mmmixdestIdx=0, mmmixsrcIdx=startIdx; mmmixi < (int) outNBElement.value ; mmmixi++, mmmixdestIdx++, mmmixsrcIdx++ ) { outReal[mmmixdestIdx] = inReal[mmmixsrcIdx]; } } ;
         return RetCode.Success ;
      }
      divider = (optInTimePeriod*(optInTimePeriod+1))>>1;
      outIdx = 0;
      trailingIdx = startIdx - lookbackTotal;
      periodSum = periodSub = (double)0.0;
      inIdx=trailingIdx;
      i = 1;
      while( inIdx < startIdx )
      {
         tempReal = inReal[inIdx++];
         periodSub += tempReal;
         periodSum += tempReal*i;
         i++;
      }
      trailingValue = 0.0;
      while( inIdx <= endIdx )
      {
         tempReal = inReal[inIdx++];
         periodSub += tempReal;
         periodSub -= trailingValue;
         periodSum += tempReal*optInTimePeriod;
         trailingValue = inReal[trailingIdx++];
         outReal[outIdx++] = periodSum / divider;
         periodSum -= periodSub;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   /**** END GENCODE SECTION 1 - DO NOT DELETE THIS LINE ****/
   
}
